local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.pathfind")local c=require("am.core")local d=require("am.turtle")local e=require("am.log")local f=require("am.event")local g=require("am.helpers")local h=require("am.progress")local i={}local j={}j.trees={name="tree.trees",default={},type="table"}j.status={name="tree.status",default="",type="string"}j.canResume={name="tree.canResume",default=false,type="boolean"}i.s=c.makeSettingWrapper(j)local k=f.c.RunType.Running;local l=true;local m=false;local n=nil;local o={}local p=60;local q=p*60;local r=0;local s=0;local function t()local u,v=turtle.inspect()return u and(v.tags["minecraft:saplings"]or v.tags["minecraft:logs"])end;local function w(x)a.expect(1,x,"table","nil")if x~=nil then g.requirePosition(1,x)end;if x==nil then x=b.s.position.get()end;f.TreeProgressEvent(x,i.s.trees.get(),i.s.status.get(),r):send()end;local function y(z)local A=0;for B,C in ipairs(z.items)do if C.tags["minecraft:logs"]then A=A+C.count end end;local D=os.clock()local E=math.max(s,D-q)local F=D-E;local G=60;if F<q then G=F/p end;local H={}if A>0 then H={[D]=A}end;local I=A;for J,K in pairs(o)do if J>=E then H[J]=K;I=I+K end end;r=I/G;o=H;w()end;local function L(M)i.s.status.set(M)w()end;local function N()i.s.trees.set({})e.info("Discovering trees...")L("Discover Trees")local O={}local P=nil;e.info(".Discover left")L("Discover Left Trees")while b.forward()do b.turnLeft()if t()then if P==nil then P={width=1,start=b.s.position.get()}else P.width=P.width+1 end elseif P~=nil then O[#O+1]=P;e.info(string.format("..Found tree width %d",P.width))P=nil end;b.turnRight()end;if P~=nil then O[#O+1]=P;e.info(string.format("..Found tree width %d",P.width))P=nil end;b.turnTo(b.c.Turtle.Direction.Back)e.info(".Discover right")L("Discover Right Trees")while not b.atOrigin()and b.forward()do b.turnLeft()if t()then if P==nil then P={width=1,start=b.s.position.get()}else P.width=P.width+1 end elseif P~=nil then O[#O+1]=P;e.info(string.format("..Found tree width %d",P.width))P=nil end;b.turnRight()end;if P~=nil then O[#O+1]=P;e.info(string.format("..Found tree width %d",P.width))P=nil end;e.info(string.format("Discovered %d trees",#O))L(string.format("Discovered %d Trees",#O))i.s.trees.set(O)b.goToOrigin()end;local function Q(R,S)local T=d.digUp;if R then T=d.dig end;if S==1 then T()local u,v=turtle.inspectUp()return u and v.tags["minecraft:logs"]end;local U=0;T()local u,v=turtle.inspectUp()local V=u and v.tags["minecraft:logs"]while U<S do for W=2,S,1 do d.dig()u,v=turtle.inspectUp()V=V or u and v.tags["minecraft:logs"]end;U=U+1;if U<S then local X=b.turnRight;if U%2==0 then X=b.turnLeft end;X()d.dig()u,v=turtle.inspectUp()V=V or u and v.tags["minecraft:logs"]X()end end;b.turnRight()return V end;local function Y(S)if S==1 then d.fillDown()return end;local U=0;while U<S do for W=1,S,1 do d.fillDown()if W<S then b.forward()end end;U=U+1;if U<S then local X=b.turnRight;if U%2==0 then X=b.turnLeft end;X()b.forward()X()end end end;local function Z(_,a0)L(string.format("Harvest %d: (%d, %d)",_,a0.start.v.x,a0.start.v.z))e.info(string.format(".Harvest %d: (%d, %d)",_,a0.start.v.x,a0.start.v.z))while not b.goTo(a0.start.v.x,a0.start.v.z,a0.start.v.y,a0.start.dir)do d.error("Cannot go to tree")sleep(5)end;local u,v=turtle.inspect()while not u or not v.tags["minecraft:logs"]do L(string.format("Wait Grow %d: (%d, %d)",_,a0.start.v.x,a0.start.v.z))e.info(".Wait Grow %d: (%d, %d)")sleep(5)if k~=f.c.RunType.Running then return end;u,v=turtle.inspect()end;L(string.format("Harvest %d: (%d, %d)",_,a0.start.v.x,a0.start.v.z))local R=true;while Q(R,a0.width)do R=false end;local x=b.s.position.get()L(string.format("Replant %d: (%d, %d)",_,a0.start.v.x,a0.start.v.z))e.info(string.format(".Replant %d: (%d, %d)",_,a0.start.v.x,a0.start.v.z))b.goTo(x.v.x,x.v.z,1)Y(a0.width)b.goTo(a0.start.v.x,a0.start.v.z,a0.start.v.y)end;local function a1()s=os.clock()f.TurtleStartedEvent():send()if m then b.goToOrigin()else b.resetPosition()b.resetNodes()N()end;if b.atOrigin()then d.discoverChests()d.emptyInventory()end;i.s.canResume.set(true)local O=i.s.trees.get()d.refuel(175*#O)e.info(string.format("Harvesting %d trees...",#O))while k==f.c.RunType.Running or k==f.c.RunType.Paused do if k==f.c.RunType.Running then for _,a2 in ipairs(O)do Z(_,a2)if k~=f.c.RunType.Running then break end end;d.emptyInventory()if k==f.c.RunType.Paused then d.emptyInventory()f.TurtlePausedEvent():send()end else sleep(5)end end;i.s.canResume.set(false)b.goToOrigin()d.emptyInventory()f.TurtleExitEvent(true):send()sleep(5)l=false end;local function a3()while l do local a4=os.startTimer(3)local z,a5=c.cleanEventArgs(os.pullEvent())if z==f.c.Event.Pathfind.position then local x=b.TurtlePosition.deserialize(nil,a5[1].position)w(x)elseif z==f.c.Event.Pathfind.go_to then local a6=a5[1]if a6.gotoType==f.c.Turtle.GoTo.Return then if a6.success==nil then L("Resuming")end end elseif z==f.c.Event.Progress.tree then h.print(f.getComputer(),a5[1])elseif z==f.c.Event.Turtle.empty then L("Emptying Inventory")if a5[1].completed then y(a5[1])end elseif z==f.c.Event.Turtle.exited then L("error:Stopped")k=f.c.RunType.Halted elseif z==f.c.Event.Turtle.request_pause then k=f.c.RunType.Paused;e.info("Pausing...")elseif z==f.c.Event.Turtle.request_halt then k=f.c.RunType.Halted;e.info("Halting...")elseif z==f.c.Event.Turtle.request_continue then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()elseif z==f.c.Event.Turtle.paused then L("warning:Paused")elseif z==f.c.Event.Turtle.fetch_fill then L("Getting Fill Block")elseif z==f.c.Event.Turtle.refuel then L("Refueling")elseif z==f.c.Event.Turtle.error then n=i.s.status.get()L(string.format("error:%s",a5[1].error))elseif z==f.c.Event.Turtle.error_clear then if n~=nil then L(n)n=nil end end;h.handle(f.getComputer(),z,a5)os.cancelTimer(a4)end end;local function a7()f.initNetwork()if not f.online then return end;while l do local v=f.receive()if v~=nil then local a8=os.getComputerID()if v.name==f.c.Event.Turtle.request_halt and v.event.id==a8 then k=f.c.RunType.Halted;e.info("Halting...")elseif v.name==f.c.Event.Turtle.request_pause and v.event.id==a8 then k=f.c.RunType.Paused;e.info("Pausing...")elseif v.name==f.c.Event.Turtle.request_continue and v.event.id==a8 then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()end end end end;local function a9(aa)if aa==nil then aa=false end;m=aa;e.s.print.set(false)parallel.waitForAll(a1,a3,a7)e.s.print.set(true)end;i.harvestTrees=a9;return i
