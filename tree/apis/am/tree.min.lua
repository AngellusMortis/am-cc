local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.pathfind")local c=require("am.core")local d=require("am.turtle")local e=require("am.log")local f=require("am.event")local g=require("am.helpers")local h=require("am.progress")local i={}local j={}j.trees={name="tree.trees",default={},type="table"}j.status={name="tree.status",default="",type="string"}j.canResume={name="tree.canResume",default=false,type="boolean"}i.s=c.makeSettingWrapper(j)local k=f.c.RunType.Running;local l=true;local m=false;local n=nil;local o={}local p=20*60;local q=p*60;local r=0;local function s()local t,u=turtle.inspect()return t and(u.tags["minecraft:saplings"]or u.tags["minecraft:logs"])end;local function v(w)a.expect(1,w,"table","nil")if w~=nil then g.requirePosition(1,w)end;if w==nil then w=b.s.position.get()end;f.TreeProgressEvent(w,i.s.trees.get(),i.s.status.get(),r):send()end;local function x(y)local z=0;for A,B in ipairs(y.items)do if B.tags["minecraft:logs"]then z=z+B.count end end;local C=os.clock()local D=60;if C<q then D=C/p end;local E=math.max(0,C-q)local F={}local G=z;for H,I in pairs(o)do if H>=E then F[H]=I;G=G+I end end;r=G/D;o=F;v()end;local function J(K)i.s.status.set(K)v()end;local function L()i.s.trees.set({})e.info("Discovering trees...")J("Discover Trees")local M={}local N=nil;e.info(".Discover left")J("Discover Left Trees")while b.forward()do b.turnLeft()if s()then if N==nil then N={width=1,start=b.s.position.get()}else N.width=N.width+1 end elseif N~=nil then M[#M+1]=N;e.info(string.format("..Found tree width %d",N.width))N=nil end;b.turnRight()end;if N~=nil then M[#M+1]=N;e.info(string.format("..Found tree width %d",N.width))N=nil end;b.turnTo(b.c.Turtle.Direction.Back)e.info(".Discover right")J("Discover Right Trees")while not b.atOrigin()and b.forward()do b.turnLeft()if s()then if N==nil then N={width=1,start=b.s.position.get()}else N.width=N.width+1 end elseif N~=nil then M[#M+1]=N;e.info(string.format("..Found tree width %d",N.width))N=nil end;b.turnRight()end;if N~=nil then M[#M+1]=N;e.info(string.format("..Found tree width %d",N.width))N=nil end;e.info(string.format("Discovered %d trees",#M))J(string.format("Discovered %d Trees",#M))i.s.trees.set(M)b.goToOrigin()end;local function O(P,Q)local R=d.digUp;if P then R=d.dig end;if Q==1 then R()local t,u=turtle.inspectUp()return t and u.tags["minecraft:logs"]end;local S=0;R()local t,u=turtle.inspectUp()local T=t and u.tags["minecraft:logs"]while S<Q do for U=2,Q,1 do d.dig()t,u=turtle.inspectUp()T=T or t and u.tags["minecraft:logs"]end;S=S+1;if S<Q then local V=b.turnRight;if S%2==0 then V=b.turnLeft end;V()d.dig()t,u=turtle.inspectUp()T=T or t and u.tags["minecraft:logs"]V()end end;b.turnRight()return T end;local function W(Q)if Q==1 then d.fillDown()return end;local S=0;while S<Q do for U=1,Q,1 do d.fillDown()if U<Q then b.forward()end end;S=S+1;if S<Q then local V=b.turnRight;if S%2==0 then V=b.turnLeft end;V()b.forward()V()end end end;local function X(Y)J(string.format("Harvest: (%d, %d)",Y.start.v.x,Y.start.v.z))e.info(string.format(".Harvest: (%d, %d)",Y.start.v.x,Y.start.v.z))while not b.goTo(Y.start.v.x,Y.start.v.z,Y.start.v.y,Y.start.dir)do d.error("Cannot go to tree")sleep(5)end;local t,u=turtle.inspect()while not t or not u.tags["minecraft:logs"]do J(string.format("Wait Grow: (%d, %d)",Y.start.v.x,Y.start.v.z))e.info("Waiting for tree to grow...")sleep(5)if k~=f.c.RunType.Running then return end;t,u=turtle.inspect()end;J(string.format("Harvest: (%d, %d)",Y.start.v.x,Y.start.v.z))local P=true;while O(P,Y.width)do P=false end;local w=b.s.position.get()J(string.format("Replant: (%d, %d)",Y.start.v.x,Y.start.v.z))e.info(string.format(".Replant: (%d, %d)",Y.start.v.x,Y.start.v.z))b.goTo(w.v.x,w.v.z,1)W(Y.width)b.goTo(Y.start.v.x,Y.start.v.z,Y.start.v.y)end;local function Z()f.TurtleStartedEvent():send()if m then b.goToOrigin()else b.resetPosition()b.resetNodes()L()end;if b.atOrigin()then d.discoverChests()d.emptyInventory()end;i.s.canResume.set(true)local M=i.s.trees.get()d.refuel(500)e.info(string.format("Harvesting %d trees...",#M))while k==f.c.RunType.Running or k==f.c.RunType.Paused do if k==f.c.RunType.Running then for A,_ in ipairs(M)do X(_)if k~=f.c.RunType.Running then break end end;d.emptyInventory()if k==f.c.RunType.Paused then d.emptyInventory()f.TurtlePausedEvent():send()end else sleep(5)end end;i.s.canResume.set(false)b.goToOrigin()d.emptyInventory()f.TurtleExitEvent(true):send()sleep(5)l=false end;local function a0()while l do local a1=os.startTimer(3)local y,a2=c.cleanEventArgs(os.pullEvent())if y==f.c.Event.Pathfind.position then local w=b.TurtlePosition.deserialize(nil,a2[1].position)v(w)elseif y==f.c.Event.Pathfind.go_to then local a3=a2[1]if a3.gotoType==f.c.Turtle.GoTo.Return then if a3.success==nil then J("Resuming")end end elseif y==f.c.Event.Progress.tree then h.print(f.getComputer(),a2[1])elseif y==f.c.Event.Turtle.empty then J("Emptying Inventory")if a2[1].completed then x(a2[1])end elseif y==f.c.Event.Turtle.exited then J("error:Stopped")k=f.c.RunType.Halted elseif y==f.c.Event.Turtle.request_pause then k=f.c.RunType.Paused;e.info("Pausing...")elseif y==f.c.Event.Turtle.request_halt then k=f.c.RunType.Halted;e.info("Halting...")elseif y==f.c.Event.Turtle.request_continue then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()elseif y==f.c.Event.Turtle.paused then J("warning:Paused")elseif y==f.c.Event.Turtle.fetch_fill then J("Getting Fill Block")elseif y==f.c.Event.Turtle.refuel then J("Refueling")elseif y==f.c.Event.Turtle.error then n=i.s.status.get()J(string.format("error:%s",a2[1].error))elseif y==f.c.Event.Turtle.error_clear then if n~=nil then J(n)n=nil end end;h.handle(f.getComputer(),y,a2)os.cancelTimer(a1)end end;local function a4()f.initNetwork()if not f.online then return end;while l do local u=f.receive()if u~=nil then local a5=os.getComputerID()if u.name==f.c.Event.Turtle.request_halt and u.event.id==a5 then k=f.c.RunType.Halted;e.info("Halting...")elseif u.name==f.c.Event.Turtle.request_pause and u.event.id==a5 then k=f.c.RunType.Paused;e.info("Pausing...")elseif u.name==f.c.Event.Turtle.request_continue and u.event.id==a5 then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()end end end end;local function a6(a7)if a7==nil then a7=false end;m=a7;e.s.print.set(false)parallel.waitForAll(Z,a0,a4)e.s.print.set(true)end;i.harvestTrees=a6;return i
