local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.pathfind")local c=require("am.core")local d=require("am.turtle")local e=require("am.log")local f=require("am.event")local g=require("am.helpers")local h=require("am.progress")local i={}local j={}j.trees={name="tree.trees",default={},type="table"}j.status={name="tree.status",default="",type="string"}j.canResume={name="tree.canResume",default=false,type="boolean"}i.s=c.makeSettingWrapper(j)local k=f.c.RunType.Running;local l=true;local m=false;local n=nil;local o={}local p=60;local q=p*60;local r={}local s=0;local t=p*5;local u=nil;local function v()local w,x=turtle.inspect()return w and(x.tags["minecraft:saplings"]or x.tags["minecraft:logs"])end;local function y(z)a.expect(1,z,"table","nil")if z~=nil then g.requirePosition(1,z)end;if z==nil then z=b.s.position.get()end;f.TreeProgressEvent(z,i.s.trees.get(),i.s.status.get(),r):send()end;local function A(B)local C=os.clock()local D=math.max(s,C-q)local E=C-D;local F=60;if E<q then F=E/p end;local G=false;local H={[C]={}}local I={}if B~=nil then for J,K in pairs(B)do G=true;if K.count>0 then H[C][K.name]=c.copy(K)I[K.name]=c.copy(K)end end end;if not G then H={}end;for L,M in pairs(o)do if L>=D then H[L]=c.copy(M)for J,N in pairs(M)do local O=I[N.name]if O==nil then O=c.copy(N)else O.count=O.count+N.count end;I[N.name]=O end end end;r={}for J,O in pairs(I)do local P=c.copy(O)P.count=0;r[#r+1]={item=P,rate=O.count/F}end;o=H;y()end;local function Q(R)local B={}for J,P in ipairs(R.items)do if P.tags["minecraft:logs"]then local K=B[P.name]if K==nil then K=c.copy(P)else K.count=K.count+P.count end;B[P.name]=K end end;A(B)end;local function S(T)i.s.status.set(T)y()end;local function U()i.s.trees.set({})e.info("Discovering trees...")S("Discover Trees")local V={}local W=nil;e.info(".Discover left")S("Discover Left Trees")while b.forward()do b.turnLeft()if v()then if W==nil then W={width=1,start=b.s.position.get()}else W.width=W.width+1 end elseif W~=nil then V[#V+1]=W;e.info(string.format("..Found tree width %d",W.width))W=nil end;b.turnRight()end;if W~=nil then V[#V+1]=W;e.info(string.format("..Found tree width %d",W.width))W=nil end;b.turnTo(b.c.Turtle.Direction.Back)e.info(".Discover right")S("Discover Right Trees")while not b.atOrigin()and b.forward()do b.turnLeft()if v()then if W==nil then W={width=1,start=b.s.position.get()}else W.width=W.width+1 end elseif W~=nil then V[#V+1]=W;e.info(string.format("..Found tree width %d",W.width))W=nil end;b.turnRight()end;if W~=nil then V[#V+1]=W;e.info(string.format("..Found tree width %d",W.width))W=nil end;e.info(string.format("Discovered %d trees",#V))S(string.format("Discovered %d Trees",#V))i.s.trees.set(V)b.goToOrigin()end;local function X(Y,Z)local _=d.digUp;if Y then _=d.dig end;if Z==1 then _()local w,x=turtle.inspectUp()return w and x.tags["minecraft:logs"]end;local a0=0;_()local w,x=turtle.inspectUp()local a1=w and x.tags["minecraft:logs"]while a0<Z do for a2=2,Z,1 do d.dig()w,x=turtle.inspectUp()a1=a1 or w and x.tags["minecraft:logs"]end;a0=a0+1;if a0<Z then local a3=b.turnRight;if a0%2==0 then a3=b.turnLeft end;a3()d.dig()w,x=turtle.inspectUp()a1=a1 or w and x.tags["minecraft:logs"]a3()end end;b.turnRight()return a1 end;local function a4(Z)if Z==1 then d.fillDown()return end;local a0=0;while a0<Z do for a2=1,Z,1 do d.fillDown()if a2<Z then b.forward()end end;a0=a0+1;if a0<Z then local a3=b.turnRight;if a0%2==0 then a3=b.turnLeft end;a3()b.forward()a3()end end end;local function a5(a6,a7)S(string.format("Harvest %d: (%d, %d)",a6,a7.start.v.x,a7.start.v.z))e.info(string.format(".Harvest %d: (%d, %d)",a6,a7.start.v.x,a7.start.v.z))while not b.goTo(a7.start.v.x,a7.start.v.z,a7.start.v.y,a7.start.dir,true)do d.error("Cannot go to tree")sleep(5)end;local w,x=turtle.inspect()while not w or not x.tags["minecraft:logs"]do S(string.format("Wait Grow %d: (%d, %d)",a6,a7.start.v.x,a7.start.v.z))e.info(".Wait Grow %d: (%d, %d)")sleep(5)if k~=f.c.RunType.Running then return end;w,x=turtle.inspect()end;S(string.format("Harvest %d: (%d, %d)",a6,a7.start.v.x,a7.start.v.z))local Y=true;while X(Y,a7.width)do Y=false end;local z=b.s.position.get()S(string.format("Replant %d: (%d, %d)",a6,a7.start.v.x,a7.start.v.z))e.info(string.format(".Replant %d: (%d, %d)",a6,a7.start.v.x,a7.start.v.z))b.goTo(z.v.x,z.v.z,1)a4(a7.width)b.goTo(a7.start.v.x,a7.start.v.z,a7.start.v.y)end;local function a8()s=os.clock()f.TurtleStartedEvent():send()if m then b.goToOrigin()else b.resetPosition()b.resetNodes()U()end;if b.atOrigin()then d.discoverChests()d.emptyInventory()end;i.s.canResume.set(true)local V=i.s.trees.get()e.info(string.format("Harvesting %d trees...",#V))while k==f.c.RunType.Running or k==f.c.RunType.Paused do if k==f.c.RunType.Running then d.refuel(175*#V)for a6,a9 in ipairs(V)do a5(a6,a9)if k~=f.c.RunType.Running then break end end;b.goTo(0,0,0,nil,true)d.emptyInventory()if k==f.c.RunType.Paused then d.emptyInventory()f.TurtlePausedEvent():send()end else sleep(5)end end;i.s.canResume.set(false)b.goToOrigin()d.emptyInventory()f.TurtleExitEvent(true):send()sleep(5)l=false end;local function aa()u=os.startTimer(t)while l do local ab=os.startTimer(3)local R,ac=c.cleanEventArgs(os.pullEvent())if R=="timer"then if ac[1]==u then A()u=os.startTimer(t)end elseif R==f.c.Event.Pathfind.position then local z=b.TurtlePosition.deserialize(nil,ac[1].position)h.updatePosition(f.getComputer(),z)elseif R==f.c.Event.Pathfind.go_to then local ad=ac[1]if ad.gotoType==f.c.Turtle.GoTo.Return then if ad.success==nil then S("Resuming")end end elseif R==f.c.Event.Progress.tree then h.print(f.getComputer(),ac[1])elseif R==f.c.Event.Turtle.empty then S("Emptying Inventory")if ac[1].completed then Q(ac[1])end elseif R==f.c.Event.Turtle.exited then S("error:Stopped")k=f.c.RunType.Halted elseif R==f.c.Event.Turtle.request_pause then k=f.c.RunType.Paused;e.info("Pausing...")elseif R==f.c.Event.Turtle.request_halt then k=f.c.RunType.Halted;e.info("Halting...")elseif R==f.c.Event.Turtle.request_continue then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()elseif R==f.c.Event.Turtle.paused then S("warning:Paused")elseif R==f.c.Event.Turtle.fetch_fill then S("Getting Fill Block")elseif R==f.c.Event.Turtle.refuel then S("Refueling")elseif R==f.c.Event.Turtle.error then n=i.s.status.get()S(string.format("error:%s",ac[1].error))elseif R==f.c.Event.Turtle.error_clear then if n~=nil then S(n)n=nil end end;h.handle(f.getComputer(),R,ac)os.cancelTimer(ab)end end;local function ae()f.initNetwork()if not f.online then return end;while l do local x=f.receive()if x~=nil then local af=os.getComputerID()if x.name==f.c.Event.Turtle.request_halt and x.event.id==af then k=f.c.RunType.Halted;e.info("Halting...")elseif x.name==f.c.Event.Turtle.request_pause and x.event.id==af then k=f.c.RunType.Paused;e.info("Pausing...")elseif x.name==f.c.Event.Turtle.request_continue and x.event.id==af then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()end end end end;local function ag(ah)if ah==nil then ah=false end;m=ah;e.s.print.set(false)parallel.waitForAll(a8,aa,ae)e.s.print.set(true)end;i.harvestTrees=ag;return i
