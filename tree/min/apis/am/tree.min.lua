local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.pathfind")local c=require("am.core")local d=require("am.turtle")local e=require("am.log")local f=require("am.event")local g=require("am.helpers")local h=require("am.progress")local i={}local j={}j.trees={name="tree.trees",default={},type="table"}j.status={name="tree.status",default="",type="string"}j.canResume={name="tree.canResume",default=false,type="boolean"}i.s=c.makeSettingWrapper(j)local k=f.c.RunType.Running;local l=true;local m=false;local n=nil;local o={}local p=60;local q=p*60;local r={}local s=0;local t=p*5;local u=nil;local function v()local w,x=turtle.inspect()return w and(x.tags["minecraft:saplings"]or x.tags["minecraft:logs"])end;local function y(z)a.expect(1,z,"table","nil")if z~=nil then g.requirePosition(1,z)end;if z==nil then z=b.s.position.get()end;f.TreeProgressEvent(z,i.s.trees.get(),i.s.status.get(),r):send()end;local function A(B)local C=os.clock()local D=math.max(s,C-q)local E=C-D;local F=60;if E<q then F=E/p end;local G={[C]={}}local H={}if B~=nil then for I,J in pairs(B)do if J.count>0 then G[C][J.name]=J;H[J.name]=J end end end;for K,L in pairs(o)do if K>=D then G[K]=L;for I,M in pairs(L)do local N=H[M.name]if N==nil then N=c.copy(M)else N.count=N.count+M.count end;H[M.name]=N end end end;r={}for I,N in pairs(H)do local O=c.copy(N)r[#r+1]={item=O,rate=N.count/F}end;o=G;y()end;local function P(Q)local B={}for I,O in ipairs(Q.items)do if O.tags["minecraft:logs"]then local J=B[O.name]if J==nil then J=c.copy(O)else J.count=J.count+O.count end;B[O.name]=J end end;A(B)end;local function R(S)i.s.status.set(S)y()end;local function T()i.s.trees.set({})e.info("Discovering trees...")R("Discover Trees")local U={}local V=nil;e.info(".Discover left")R("Discover Left Trees")while b.forward()do b.turnLeft()if v()then if V==nil then V={width=1,start=b.s.position.get()}else V.width=V.width+1 end elseif V~=nil then U[#U+1]=V;e.info(string.format("..Found tree width %d",V.width))V=nil end;b.turnRight()end;if V~=nil then U[#U+1]=V;e.info(string.format("..Found tree width %d",V.width))V=nil end;b.turnTo(b.c.Turtle.Direction.Back)e.info(".Discover right")R("Discover Right Trees")while not b.atOrigin()and b.forward()do b.turnLeft()if v()then if V==nil then V={width=1,start=b.s.position.get()}else V.width=V.width+1 end elseif V~=nil then U[#U+1]=V;e.info(string.format("..Found tree width %d",V.width))V=nil end;b.turnRight()end;if V~=nil then U[#U+1]=V;e.info(string.format("..Found tree width %d",V.width))V=nil end;e.info(string.format("Discovered %d trees",#U))R(string.format("Discovered %d Trees",#U))i.s.trees.set(U)b.goToOrigin()end;local function W(X,Y)local Z=d.digUp;if X then Z=d.dig end;if Y==1 then Z()local w,x=turtle.inspectUp()return w and x.tags["minecraft:logs"]end;local _=0;Z()local w,x=turtle.inspectUp()local a0=w and x.tags["minecraft:logs"]while _<Y do for a1=2,Y,1 do d.dig()w,x=turtle.inspectUp()a0=a0 or w and x.tags["minecraft:logs"]end;_=_+1;if _<Y then local a2=b.turnRight;if _%2==0 then a2=b.turnLeft end;a2()d.dig()w,x=turtle.inspectUp()a0=a0 or w and x.tags["minecraft:logs"]a2()end end;b.turnRight()return a0 end;local function a3(Y)if Y==1 then d.fillDown()return end;local _=0;while _<Y do for a1=1,Y,1 do d.fillDown()if a1<Y then b.forward()end end;_=_+1;if _<Y then local a2=b.turnRight;if _%2==0 then a2=b.turnLeft end;a2()b.forward()a2()end end end;local function a4(a5,a6)R(string.format("Harvest %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))e.info(string.format(".Harvest %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))while not b.goTo(a6.start.v.x,a6.start.v.z,a6.start.v.y,a6.start.dir,true)do d.error("Cannot go to tree")sleep(5)end;local w,x=turtle.inspect()while not w or not x.tags["minecraft:logs"]do R(string.format("Wait Grow %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))e.info(".Wait Grow %d: (%d, %d)")sleep(5)if k~=f.c.RunType.Running then return end;w,x=turtle.inspect()end;R(string.format("Harvest %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))local X=true;while W(X,a6.width)do X=false end;local z=b.s.position.get()R(string.format("Replant %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))e.info(string.format(".Replant %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))b.goTo(z.v.x,z.v.z,1)a3(a6.width)b.goTo(a6.start.v.x,a6.start.v.z,a6.start.v.y)end;local function a7()s=os.clock()f.TurtleStartedEvent():send()if m then b.goToOrigin()else b.resetPosition()b.resetNodes()T()end;if b.atOrigin()then d.discoverChests()d.emptyInventory()end;i.s.canResume.set(true)local U=i.s.trees.get()e.info(string.format("Harvesting %d trees...",#U))while k==f.c.RunType.Running or k==f.c.RunType.Paused do if k==f.c.RunType.Running then d.refuel(175*#U)for a5,a8 in ipairs(U)do a4(a5,a8)if k~=f.c.RunType.Running then break end end;b.goTo(0,0,0,nil,true)d.emptyInventory()if k==f.c.RunType.Paused then d.emptyInventory()f.TurtlePausedEvent():send()end else sleep(5)end end;i.s.canResume.set(false)b.goToOrigin()d.emptyInventory()f.TurtleExitEvent(true):send()sleep(5)l=false end;local function a9()u=os.startTimer(t)while l do local aa=os.startTimer(3)local Q,ab=c.cleanEventArgs(os.pullEvent())if Q=="timer"then if ab[1]==u then A()u=os.startTimer(t)end elseif Q==f.c.Event.Pathfind.position then local z=b.TurtlePosition.deserialize(nil,ab[1].position)h.updatePosition(f.getComputer(),z)elseif Q==f.c.Event.Pathfind.go_to then local ac=ab[1]if ac.gotoType==f.c.Turtle.GoTo.Return then if ac.success==nil then R("Resuming")end end elseif Q==f.c.Event.Progress.tree then h.print(f.getComputer(),ab[1])elseif Q==f.c.Event.Turtle.empty then R("Emptying Inventory")if ab[1].completed then P(ab[1])end elseif Q==f.c.Event.Turtle.exited then R("error:Stopped")k=f.c.RunType.Halted elseif Q==f.c.Event.Turtle.request_pause then k=f.c.RunType.Paused;e.info("Pausing...")elseif Q==f.c.Event.Turtle.request_halt then k=f.c.RunType.Halted;e.info("Halting...")elseif Q==f.c.Event.Turtle.request_continue then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()elseif Q==f.c.Event.Turtle.paused then R("warning:Paused")elseif Q==f.c.Event.Turtle.fetch_fill then R("Getting Fill Block")elseif Q==f.c.Event.Turtle.refuel then R("Refueling")elseif Q==f.c.Event.Turtle.error then n=i.s.status.get()R(string.format("error:%s",ab[1].error))elseif Q==f.c.Event.Turtle.error_clear then if n~=nil then R(n)n=nil end end;h.handle(f.getComputer(),Q,ab)os.cancelTimer(aa)end end;local function ad()f.initNetwork()if not f.online then return end;while l do local x=f.receive()if x~=nil then local ae=os.getComputerID()if x.name==f.c.Event.Turtle.request_halt and x.event.id==ae then k=f.c.RunType.Halted;e.info("Halting...")elseif x.name==f.c.Event.Turtle.request_pause and x.event.id==ae then k=f.c.RunType.Paused;e.info("Pausing...")elseif x.name==f.c.Event.Turtle.request_continue and x.event.id==ae then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()end end end end;local function af(ag)if ag==nil then ag=false end;m=ag;e.s.print.set(false)parallel.waitForAll(a7,a9,ad)e.s.print.set(true)end;i.harvestTrees=af;return i
