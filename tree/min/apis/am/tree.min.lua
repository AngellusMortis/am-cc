local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.pathfind")local c=require("am.core")local d=require("am.turtle")local e=require("am.log")local f=require("am.event")local g=require("am.helpers")local h=require("am.progress")local i=require("am.peripheral")local j={}local k={}k.trees={name="trees",default={},type="table"}k.status={name="status",default="",type="string"}k.canResume={name="canResume",default=false,type="boolean"}j.d=c.makeDataWrapper(k,"tree")local l=f.c.RunType.Running;local m=true;local n=false;local o=nil;local p=300;local q=nil;local function r()local s,t=turtle.inspect()return s and(t.tags["minecraft:saplings"]or t.tags["minecraft:logs"])end;local function u(v)a.expect(1,v,"table","nil")if v~=nil then g.requirePosition(1,v)end;if v==nil then v=b.getPos()end;f.TreeProgressEvent(v,j.d.trees.get(),j.d.status.get(),i.getRates()):send()end;local function w(x)j.d.status.set(x)u()end;local function y()j.d.trees.set({})e.info("Discovering trees...")w("Discover Trees")local z={}local A=nil;e.info(".Discover left")w("Discover Left Trees")while b.forward()do b.turnLeft()if r()then if A==nil then A={width=1,start=b.getPos()}else A.width=A.width+1 end elseif A~=nil then z[#z+1]=A;e.info(string.format("..Found tree width %d",A.width))A=nil end;b.turnRight()end;if A~=nil then z[#z+1]=A;e.info(string.format("..Found tree width %d",A.width))A=nil end;b.turnTo(b.c.Turtle.Direction.Back)e.info(".Discover right")w("Discover Right Trees")while not b.atOrigin()and b.forward()do b.turnLeft()if r()then if A==nil then A={width=1,start=b.getPos()}else A.width=A.width+1 end elseif A~=nil then z[#z+1]=A;e.info(string.format("..Found tree width %d",A.width))A=nil end;b.turnRight()end;if A~=nil then z[#z+1]=A;e.info(string.format("..Found tree width %d",A.width))A=nil end;e.info(string.format("Discovered %d trees",#z))w(string.format("Discovered %d Trees",#z))j.d.trees.set(z)b.goToOrigin()end;local function B(C,D)local E=d.digUp;if C then E=d.dig end;if D==1 then E()local s,t=turtle.inspectUp()return s and t.tags["minecraft:logs"]end;local F=0;E()local s,t=turtle.inspectUp()local G=s and t.tags["minecraft:logs"]while F<D do for H=2,D,1 do d.dig()s,t=turtle.inspectUp()G=G or s and t.tags["minecraft:logs"]end;F=F+1;if F<D then local I=b.turnRight;if F%2==0 then I=b.turnLeft end;I()d.dig()s,t=turtle.inspectUp()G=G or s and t.tags["minecraft:logs"]I()end end;b.turnRight()return G end;local function J(D)if D==1 then d.fillDown()return end;local F=0;while F<D do for H=1,D,1 do d.fillDown()if H<D then b.forward()end end;F=F+1;if F<D then local I=b.turnRight;if F%2==0 then I=b.turnLeft end;I()b.forward()I()end end end;local function K(L,M)w(string.format("Harvest %d: (%d, %d)",L,M.start.v.x,M.start.v.z))e.info(string.format(".Harvest %d: (%d, %d)",L,M.start.v.x,M.start.v.z))while not b.goTo(M.start.v.x,M.start.v.z,M.start.v.y,M.start.dir,true)do d.error("Cannot go to tree")sleep(5)end;local s,t=turtle.inspect()while not s or not t.tags["minecraft:logs"]do w(string.format("Wait Grow %d: (%d, %d)",L,M.start.v.x,M.start.v.z))e.info(".Wait Grow %d: (%d, %d)")sleep(5)if l~=f.c.RunType.Running then return end;s,t=turtle.inspect()end;w(string.format("Harvest %d: (%d, %d)",L,M.start.v.x,M.start.v.z))local C=true;while B(C,M.width)do C=false end;local v=b.getPos()w(string.format("Replant %d: (%d, %d)",L,M.start.v.x,M.start.v.z))e.info(string.format(".Replant %d: (%d, %d)",L,M.start.v.x,M.start.v.z))b.goTo(v.v.x,v.v.z,1)J(M.width)b.goTo(M.start.v.x,M.start.v.z,M.start.v.y)end;local function N()START_TIME=os.clock()f.TurtleStartedEvent():send()if n then b.goToOrigin()else b.resetPosition()b.resetNodes()y()end;if b.atOrigin()then d.discoverChests()d.emptyInventory()end;j.d.canResume.set(true)local z=j.d.trees.get()e.info(string.format("Harvesting %d trees...",#z))while l==f.c.RunType.Running or l==f.c.RunType.Paused do if l==f.c.RunType.Running then d.refuel(175*#z)for L,O in ipairs(z)do K(L,O)if l~=f.c.RunType.Running then break end end;b.goTo(0,0,0,nil,true)d.emptyInventory()if l==f.c.RunType.Paused then d.emptyInventory()f.TurtlePausedEvent():send()end else sleep(5)end end;j.d.canResume.set(false)b.goToOrigin()d.emptyInventory()f.TurtleExitEvent(true):send()sleep(5)m=false end;local function P()q=os.startTimer(p)while m do local Q=os.startTimer(3)local R,S=c.cleanEventArgs(os.pullEvent())if R=="timer"then if S[1]==q then i.calculateRates()u()q=os.startTimer(p)end elseif R==f.c.Event.Pathfind.position then local v=b.TurtlePosition.deserialize(nil,S[1].position)h.updatePosition(f.getComputer(),v)elseif R==f.c.Event.Pathfind.go_to then local T=S[1]if T.gotoType==f.c.Turtle.GoTo.Return then if T.success==nil then w("Resuming")end end elseif R==f.c.Event.Progress.tree then h.print(f.getComputer(),S[1])elseif R==f.c.Event.Turtle.empty then w("Emptying Inventory")if S[1].completed then i.addItems(S[1].items)u()end elseif R==f.c.Event.Turtle.exited then w("error:Stopped")l=f.c.RunType.Halted elseif R==f.c.Event.Turtle.request_pause then l=f.c.RunType.Paused;e.info("Pausing...")elseif R==f.c.Event.Turtle.request_halt then l=f.c.RunType.Halted;e.info("Halting...")elseif R==f.c.Event.Turtle.request_continue then l=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()elseif R==f.c.Event.Turtle.paused then w("warning:Paused")elseif R==f.c.Event.Turtle.fetch_fill then w("Getting Fill Block")elseif R==f.c.Event.Turtle.refuel then w("Refueling")elseif R==f.c.Event.Turtle.error then o=j.d.status.get()w(string.format("error:%s",S[1].error))elseif R==f.c.Event.Turtle.error_clear then if o~=nil then w(o)o=nil end end;h.handle(f.getComputer(),R,S)os.cancelTimer(Q)end end;local function U()f.initNetwork()if not f.online then return end;while m do local t=f.receive()if t~=nil then local V=os.getComputerID()if t.name==f.c.Event.Turtle.request_halt and t.event.id==V then l=f.c.RunType.Halted;e.info("Halting...")elseif t.name==f.c.Event.Turtle.request_pause and t.event.id==V then l=f.c.RunType.Paused;e.info("Pausing...")elseif t.name==f.c.Event.Turtle.request_continue and t.event.id==V then l=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()end end end end;local function W(X)if X==nil then X=false end;n=X;e.s.print.set(false)parallel.waitForAll(N,P,U)e.s.print.set(true)term.clear()end;j.harvestTrees=W;return j
