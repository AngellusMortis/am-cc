local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.pathfind")local c=require("am.core")local d=require("am.turtle")local e=require("am.log")local f=require("am.event")local g=require("am.helpers")local h=require("am.progress")local i={}local j={}j.trees={name="tree.trees",default={},type="table"}j.status={name="tree.status",default="",type="string"}j.canResume={name="tree.canResume",default=false,type="boolean"}i.s=c.makeSettingWrapper(j)local k=f.c.RunType.Running;local l=true;local m=false;local n=nil;local o={}local p=60;local q=p*60;local r=0;local s=0;local t=p*5;local u=nil;local function v()local w,x=turtle.inspect()return w and(x.tags["minecraft:saplings"]or x.tags["minecraft:logs"])end;local function y(z)a.expect(1,z,"table","nil")if z~=nil then g.requirePosition(1,z)end;if z==nil then z=b.s.position.get()end;f.TreeProgressEvent(z,i.s.trees.get(),i.s.status.get(),r):send()end;local function A(B)local C=os.clock()local D=math.max(s,C-q)local E=C-D;local F=60;if E<q then F=E/p end;local G={}if B~=nil and B>0 then G={[C]=B}end;local H=B or 0;for I,J in pairs(o)do if I>=D then G[I]=J;H=H+J end end;r=H/F;o=G;y()end;local function K(L)local M=0;for N,O in ipairs(L.items)do if O.tags["minecraft:logs"]then M=M+O.count end end;A(M)end;local function P(Q)i.s.status.set(Q)y()end;local function R()i.s.trees.set({})e.info("Discovering trees...")P("Discover Trees")local S={}local T=nil;e.info(".Discover left")P("Discover Left Trees")while b.forward()do b.turnLeft()if v()then if T==nil then T={width=1,start=b.s.position.get()}else T.width=T.width+1 end elseif T~=nil then S[#S+1]=T;e.info(string.format("..Found tree width %d",T.width))T=nil end;b.turnRight()end;if T~=nil then S[#S+1]=T;e.info(string.format("..Found tree width %d",T.width))T=nil end;b.turnTo(b.c.Turtle.Direction.Back)e.info(".Discover right")P("Discover Right Trees")while not b.atOrigin()and b.forward()do b.turnLeft()if v()then if T==nil then T={width=1,start=b.s.position.get()}else T.width=T.width+1 end elseif T~=nil then S[#S+1]=T;e.info(string.format("..Found tree width %d",T.width))T=nil end;b.turnRight()end;if T~=nil then S[#S+1]=T;e.info(string.format("..Found tree width %d",T.width))T=nil end;e.info(string.format("Discovered %d trees",#S))P(string.format("Discovered %d Trees",#S))i.s.trees.set(S)b.goToOrigin()end;local function U(V,W)local X=d.digUp;if V then X=d.dig end;if W==1 then X()local w,x=turtle.inspectUp()return w and x.tags["minecraft:logs"]end;local Y=0;X()local w,x=turtle.inspectUp()local Z=w and x.tags["minecraft:logs"]while Y<W do for _=2,W,1 do d.dig()w,x=turtle.inspectUp()Z=Z or w and x.tags["minecraft:logs"]end;Y=Y+1;if Y<W then local a0=b.turnRight;if Y%2==0 then a0=b.turnLeft end;a0()d.dig()w,x=turtle.inspectUp()Z=Z or w and x.tags["minecraft:logs"]a0()end end;b.turnRight()return Z end;local function a1(W)if W==1 then d.fillDown()return end;local Y=0;while Y<W do for _=1,W,1 do d.fillDown()if _<W then b.forward()end end;Y=Y+1;if Y<W then local a0=b.turnRight;if Y%2==0 then a0=b.turnLeft end;a0()b.forward()a0()end end end;local function a2(a3,a4)P(string.format("Harvest %d: (%d, %d)",a3,a4.start.v.x,a4.start.v.z))e.info(string.format(".Harvest %d: (%d, %d)",a3,a4.start.v.x,a4.start.v.z))while not b.goTo(a4.start.v.x,a4.start.v.z,a4.start.v.y,a4.start.dir,true)do d.error("Cannot go to tree")sleep(5)end;local w,x=turtle.inspect()while not w or not x.tags["minecraft:logs"]do P(string.format("Wait Grow %d: (%d, %d)",a3,a4.start.v.x,a4.start.v.z))e.info(".Wait Grow %d: (%d, %d)")sleep(5)if k~=f.c.RunType.Running then return end;w,x=turtle.inspect()end;P(string.format("Harvest %d: (%d, %d)",a3,a4.start.v.x,a4.start.v.z))local V=true;while U(V,a4.width)do V=false end;local z=b.s.position.get()P(string.format("Replant %d: (%d, %d)",a3,a4.start.v.x,a4.start.v.z))e.info(string.format(".Replant %d: (%d, %d)",a3,a4.start.v.x,a4.start.v.z))b.goTo(z.v.x,z.v.z,1)a1(a4.width)b.goTo(a4.start.v.x,a4.start.v.z,a4.start.v.y)end;local function a5()s=os.clock()f.TurtleStartedEvent():send()if m then b.goToOrigin()else b.resetPosition()b.resetNodes()R()end;if b.atOrigin()then d.discoverChests()d.emptyInventory()end;i.s.canResume.set(true)local S=i.s.trees.get()e.info(string.format("Harvesting %d trees...",#S))while k==f.c.RunType.Running or k==f.c.RunType.Paused do if k==f.c.RunType.Running then d.refuel(175*#S)for a3,a6 in ipairs(S)do a2(a3,a6)if k~=f.c.RunType.Running then break end end;b.goTo(0,0,0,nil,true)d.emptyInventory()if k==f.c.RunType.Paused then d.emptyInventory()f.TurtlePausedEvent():send()end else sleep(5)end end;i.s.canResume.set(false)b.goToOrigin()d.emptyInventory()f.TurtleExitEvent(true):send()sleep(5)l=false end;local function a7()u=os.startTimer(t)while l do local a8=os.startTimer(3)local L,a9=c.cleanEventArgs(os.pullEvent())if L=="timer"then if a9[1]==u then A()u=os.startTimer(t)end elseif L==f.c.Event.Pathfind.position then local z=b.TurtlePosition.deserialize(nil,a9[1].position)h.updatePosition(f.getComputer(),z)elseif L==f.c.Event.Pathfind.go_to then local aa=a9[1]if aa.gotoType==f.c.Turtle.GoTo.Return then if aa.success==nil then P("Resuming")end end elseif L==f.c.Event.Progress.tree then h.print(f.getComputer(),a9[1])elseif L==f.c.Event.Turtle.empty then P("Emptying Inventory")if a9[1].completed then K(a9[1])end elseif L==f.c.Event.Turtle.exited then P("error:Stopped")k=f.c.RunType.Halted elseif L==f.c.Event.Turtle.request_pause then k=f.c.RunType.Paused;e.info("Pausing...")elseif L==f.c.Event.Turtle.request_halt then k=f.c.RunType.Halted;e.info("Halting...")elseif L==f.c.Event.Turtle.request_continue then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()elseif L==f.c.Event.Turtle.paused then P("warning:Paused")elseif L==f.c.Event.Turtle.fetch_fill then P("Getting Fill Block")elseif L==f.c.Event.Turtle.refuel then P("Refueling")elseif L==f.c.Event.Turtle.error then n=i.s.status.get()P(string.format("error:%s",a9[1].error))elseif L==f.c.Event.Turtle.error_clear then if n~=nil then P(n)n=nil end end;h.handle(f.getComputer(),L,a9)os.cancelTimer(a8)end end;local function ab()f.initNetwork()if not f.online then return end;while l do local x=f.receive()if x~=nil then local ac=os.getComputerID()if x.name==f.c.Event.Turtle.request_halt and x.event.id==ac then k=f.c.RunType.Halted;e.info("Halting...")elseif x.name==f.c.Event.Turtle.request_pause and x.event.id==ac then k=f.c.RunType.Paused;e.info("Pausing...")elseif x.name==f.c.Event.Turtle.request_continue and x.event.id==ac then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()end end end end;local function ad(ae)if ae==nil then ae=false end;m=ae;e.s.print.set(false)parallel.waitForAll(a5,a7,ab)e.s.print.set(true)end;i.harvestTrees=ad;return i
