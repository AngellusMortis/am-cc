local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.pathfind")local c=require("am.core")local d=require("am.turtle")local e=require("am.log")local f=require("am.event")local g=require("am.helpers")local h=require("am.progress")local i={}local j={}j.trees={name="tree.trees",default={},type="table"}j.status={name="tree.status",default="",type="string"}j.canResume={name="tree.canResume",default=false,type="boolean"}i.s=c.makeSettingWrapper(j)local k=f.c.RunType.Running;local l=true;local m=false;local n=nil;local o={}local p=60;local q=p*60;local r=0;local s={name="minecraft:oak_log",count=0,displayName="Oak Log",maxCount=64,tags={["minecraft:logs"]=true}}local t=0;local u=p*5;local v=nil;local function w()local x,y=turtle.inspect()return x and(y.tags["minecraft:saplings"]or y.tags["minecraft:logs"])end;local function z(A)a.expect(1,A,"table","nil")if A~=nil then g.requirePosition(1,A)end;if A==nil then A=b.s.position.get()end;local B={{item=s,rate=r}}f.TreeProgressEvent(A,i.s.trees.get(),i.s.status.get(),B):send()end;local function C(D)local E=os.clock()local F=math.max(t,E-q)local G=E-F;local H=60;if G<q then H=G/p end;local I={}if D~=nil and D>0 then I={[E]=D}end;local J=D or 0;for K,L in pairs(o)do if K>=F then I[K]=L;J=J+L end end;r=J/H;o=I;z()end;local function M(N)local O=0;for P,Q in ipairs(N.items)do if s==nil then s=c.copy(Q)s.count=0 end;if Q.tags["minecraft:logs"]then O=O+Q.count end end;C(O)end;local function R(S)i.s.status.set(S)z()end;local function T()i.s.trees.set({})e.info("Discovering trees...")R("Discover Trees")local U={}local V=nil;e.info(".Discover left")R("Discover Left Trees")while b.forward()do b.turnLeft()if w()then if V==nil then V={width=1,start=b.s.position.get()}else V.width=V.width+1 end elseif V~=nil then U[#U+1]=V;e.info(string.format("..Found tree width %d",V.width))V=nil end;b.turnRight()end;if V~=nil then U[#U+1]=V;e.info(string.format("..Found tree width %d",V.width))V=nil end;b.turnTo(b.c.Turtle.Direction.Back)e.info(".Discover right")R("Discover Right Trees")while not b.atOrigin()and b.forward()do b.turnLeft()if w()then if V==nil then V={width=1,start=b.s.position.get()}else V.width=V.width+1 end elseif V~=nil then U[#U+1]=V;e.info(string.format("..Found tree width %d",V.width))V=nil end;b.turnRight()end;if V~=nil then U[#U+1]=V;e.info(string.format("..Found tree width %d",V.width))V=nil end;e.info(string.format("Discovered %d trees",#U))R(string.format("Discovered %d Trees",#U))i.s.trees.set(U)b.goToOrigin()end;local function W(X,Y)local Z=d.digUp;if X then Z=d.dig end;if Y==1 then Z()local x,y=turtle.inspectUp()return x and y.tags["minecraft:logs"]end;local _=0;Z()local x,y=turtle.inspectUp()local a0=x and y.tags["minecraft:logs"]while _<Y do for a1=2,Y,1 do d.dig()x,y=turtle.inspectUp()a0=a0 or x and y.tags["minecraft:logs"]end;_=_+1;if _<Y then local a2=b.turnRight;if _%2==0 then a2=b.turnLeft end;a2()d.dig()x,y=turtle.inspectUp()a0=a0 or x and y.tags["minecraft:logs"]a2()end end;b.turnRight()return a0 end;local function a3(Y)if Y==1 then d.fillDown()return end;local _=0;while _<Y do for a1=1,Y,1 do d.fillDown()if a1<Y then b.forward()end end;_=_+1;if _<Y then local a2=b.turnRight;if _%2==0 then a2=b.turnLeft end;a2()b.forward()a2()end end end;local function a4(a5,a6)R(string.format("Harvest %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))e.info(string.format(".Harvest %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))while not b.goTo(a6.start.v.x,a6.start.v.z,a6.start.v.y,a6.start.dir,true)do d.error("Cannot go to tree")sleep(5)end;local x,y=turtle.inspect()while not x or not y.tags["minecraft:logs"]do R(string.format("Wait Grow %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))e.info(".Wait Grow %d: (%d, %d)")sleep(5)if k~=f.c.RunType.Running then return end;x,y=turtle.inspect()end;R(string.format("Harvest %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))local X=true;while W(X,a6.width)do X=false end;local A=b.s.position.get()R(string.format("Replant %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))e.info(string.format(".Replant %d: (%d, %d)",a5,a6.start.v.x,a6.start.v.z))b.goTo(A.v.x,A.v.z,1)a3(a6.width)b.goTo(a6.start.v.x,a6.start.v.z,a6.start.v.y)end;local function a7()t=os.clock()f.TurtleStartedEvent():send()if m then b.goToOrigin()else b.resetPosition()b.resetNodes()T()end;if b.atOrigin()then d.discoverChests()d.emptyInventory()end;i.s.canResume.set(true)local U=i.s.trees.get()e.info(string.format("Harvesting %d trees...",#U))while k==f.c.RunType.Running or k==f.c.RunType.Paused do if k==f.c.RunType.Running then d.refuel(175*#U)for a5,a8 in ipairs(U)do a4(a5,a8)if k~=f.c.RunType.Running then break end end;b.goTo(0,0,0,nil,true)d.emptyInventory()if k==f.c.RunType.Paused then d.emptyInventory()f.TurtlePausedEvent():send()end else sleep(5)end end;i.s.canResume.set(false)b.goToOrigin()d.emptyInventory()f.TurtleExitEvent(true):send()sleep(5)l=false end;local function a9()v=os.startTimer(u)while l do local aa=os.startTimer(3)local N,ab=c.cleanEventArgs(os.pullEvent())if N=="timer"then if ab[1]==v then C()v=os.startTimer(u)end elseif N==f.c.Event.Pathfind.position then local A=b.TurtlePosition.deserialize(nil,ab[1].position)h.updatePosition(f.getComputer(),A)elseif N==f.c.Event.Pathfind.go_to then local ac=ab[1]if ac.gotoType==f.c.Turtle.GoTo.Return then if ac.success==nil then R("Resuming")end end elseif N==f.c.Event.Progress.tree then h.print(f.getComputer(),ab[1])elseif N==f.c.Event.Turtle.empty then R("Emptying Inventory")if ab[1].completed then M(ab[1])end elseif N==f.c.Event.Turtle.exited then R("error:Stopped")k=f.c.RunType.Halted elseif N==f.c.Event.Turtle.request_pause then k=f.c.RunType.Paused;e.info("Pausing...")elseif N==f.c.Event.Turtle.request_halt then k=f.c.RunType.Halted;e.info("Halting...")elseif N==f.c.Event.Turtle.request_continue then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()elseif N==f.c.Event.Turtle.paused then R("warning:Paused")elseif N==f.c.Event.Turtle.fetch_fill then R("Getting Fill Block")elseif N==f.c.Event.Turtle.refuel then R("Refueling")elseif N==f.c.Event.Turtle.error then n=i.s.status.get()R(string.format("error:%s",ab[1].error))elseif N==f.c.Event.Turtle.error_clear then if n~=nil then R(n)n=nil end end;h.handle(f.getComputer(),N,ab)os.cancelTimer(aa)end end;local function ad()f.initNetwork()if not f.online then return end;while l do local y=f.receive()if y~=nil then local ae=os.getComputerID()if y.name==f.c.Event.Turtle.request_halt and y.event.id==ae then k=f.c.RunType.Halted;e.info("Halting...")elseif y.name==f.c.Event.Turtle.request_pause and y.event.id==ae then k=f.c.RunType.Paused;e.info("Pausing...")elseif y.name==f.c.Event.Turtle.request_continue and y.event.id==ae then k=f.c.RunType.Running;e.info("Unpausing...")f.TurtleStartedEvent():send()end end end end;local function af(ag)if ag==nil then ag=false end;m=ag;e.s.print.set(false)parallel.waitForAll(a7,a9,ad)e.s.print.set(true)end;i.harvestTrees=af;return i
