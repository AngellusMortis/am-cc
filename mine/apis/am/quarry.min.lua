local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.log")local e=require("am.event")local f=require("am.helpers")local g=require("am.progress")local h=require("am.pathfind")local i=require("am.turtle")local j={}local k=b:extend("am.q.QuarryJob")j.QuarryJob=k;function k:init(l,m,n,o,p)a.expect(1,l,"number")a.expect(2,m,"number")a.expect(3,n,"number")a.expect(4,o,"boolean")a.expect(5,p,"boolean","nil")a.range(l,1)a.range(m,1)k.super.init(self)if p==nil then p=false end;self.left=l;self.forward=m;self.levels=n;self.walls=o;self.refuelTarget=320;self.refuelLevel=1;self.percentPerLevel=1;if not p then self:calculateExtra()end;return self end;function k:calculateExtra()local q=self.left*self.forward+self.left*2+self.forward*2;local r=q;local s=self.levels;if turtle.getFuelLimit()=="unlimited"then r=q*self.levels else s=1;while s<self.levels and r+q<turtle.getFuelLimit()do r=r+q;s=s+1 end end;self.refuelTarget=r;self.refuelLevel=s;self.percentPerLevel=1/self.levels end;function k:deserialize(t)local u=k(t.left,t.forward,t.levels,t.walls,true)u.refuelTarget=t.refuelTarget;u.refuelLevel=t.refuelLevel;u.percentPerLevel=t.percentPerLevel;return u end;local v=b:extend("am.q.QuarryProgress")j.QuarryProgress=v;function v:init(w,x,y,z,A,B)a.expect(1,w,"number")a.expect(2,x,"number")a.expect(3,y,"number")a.expect(4,z,"number")a.expect(5,A,"boolean")a.expect(6,B,"string")a.range(w,0)a.range(x,0)a.range(y,0)a.range(z,0)k.super.init(self)self.current=w;self.levelCurrent=x;self.completedLevels=y;self.completedRows=z;self.finished=A;self.status=B;return self end;function v:deserialize(t)return v(t.current,t.levelCurrent,t.completedLevels,t.completedRows,t.finished,t.status)end;local C={}C.job={name="quarry.job",default=k(16,16,1,true),type="table"}C.progress={name="quarry.progress",default=v(0,0,0,0,true,""),type="table"}C.autoResume={name="quarry.autoResume",default=true,type="boolean"}C.offsetPos={name="quarry.offsetPos",default=false}j.s=c.makeSettingWrapper(C)j.s.job.get=function()return k.deserialize(nil,settings.get(j.s.job.name))end;j.s.progress.get=function()return v.deserialize(nil,settings.get(j.s.progress.name))end;j.s.offsetPos.get=function()local t=settings.get(j.s.offsetPos.name)if t then t=h.TurtlePosition.deserialize(nil,settings.get(j.s.offsetPos.name))end;return t end;local D=h.TurtlePosition(vector.new(0,1,0),e.c.Turtle.Direction.Front)local E={Running=1,Completed=2,Paused=3,Halted=4}local F=E.Running;local function G(H,I)a.expect(1,H,"table","nil")a.expect(2,I,"table","nil")if H~=nil then f.requirePosition(1,H)end;if H==nil then H=h.s.position.get()end;if I==nil then I=j.s.progress.get()end;e.QuarryProgressEvent(H,j.s.job.get(),I):send()end;local function J(I)a.expect(1,I,"table")if not b.has(I,"am.q.QuarryProgress")then error("Not progress obj")end;j.s.progress.set(I)G(nil,I)end;local function K(B)a.expect(1,B,"string")local I=j.s.progress.get()I.status=B;J(I)end;local function L(M)a.expect(1,M,"number")a.range(M,1)local I=j.s.progress.get()local u=j.s.job.get()I.completedRows=M-1;I.levelPercent=I.completedRows/u.left;I.totalPercent=I.completedLevels/u.levels+u.percentPerLevel*I.levelPercent;I.status=string.format("Digging Row %d",M)J(I)d.info(string.format("..Start row %d of %d (%d%%, %d%%)",M,u.left,I.levelPercent*100,I.totalPercent*100))end;local function N()local I=j.s.progress.get()local u=j.s.job.get()I.completedRows=I.completedRows+1;I.levelPercent=I.completedRows/u.left;I.totalPercent=I.completedLevels/u.levels+u.percentPerLevel*I.levelPercent;I.status=string.format("Completed Row %d",I.completedRows)J(I)end;local function O()local I=j.s.progress.get()local u=j.s.job.get()I.levelPercent=0;I.status=string.format("Starting Level %d",I.completedLevels+1)J(I)d.info(string.format(".Start level %d of %d (%d%%, %d%%)",I.completedLevels+1,u.levels,I.levelPercent*100,I.current*100))end;local function P()local I=j.s.progress.get()local u=j.s.job.get()I.completedLevels=I.completedLevels+1;I.completedRows=0;I.levelPercent=1;I.totalPercent=I.completedLevels/u.levels;I.status=string.format("Completing Level %d",I.completedLevels-1)J(I)end;local function Q()local I=j.s.progress.get()I.finished=true;I.status="Finishing Job"J(I)end;local function R()local S=j.s.offsetPos.get()if S then K("Going to Offset")while not h.goTo(S.x,S.z,S.y,S.dir)do i.error("Cannot Goto Offset")sleep(3)end;h.addNode()end end;local function T(U,o,V,W,X)a.expect(1,U,"number","nil")a.expect(2,o,"boolean","nil")a.expect(3,V,"boolean","nil")a.expect(4,W,"boolean","nil")a.expect(5,X,"boolean","nil")if U==nil then U=1 end;if o==nil then o=true end;if V==nil then V=false end;if W==nil then W=false end;if X==nil then X=false end;for Y=1,U,1 do i.dig()if o then if not turtle.detectDown()and(X or i.isSourceBlockDown())then i.fillDown(true)end;if V then h.turnLeft()i.fill(true)h.turnRight()end;if W then h.turnRight()i.fill(true)h.turnLeft()end end;if F~=E.Running then return end end end;local function Z()local S=j.s.offsetPos.get()h.resetNodes()if S then h.addNode(S)end;h.addNode(D)end;local function _(M,X)K(string.format("Returning to Row %d",M))d.info(string.format("..Resume start: %s",d.format(D)))local u=j.s.job.get()local a0=false;local a1=-1;local a2=1;if D.dir==e.c.Turtle.Direction.Right then a0=true;a1=1;a2=1 elseif D.dir==e.c.Turtle.Direction.Back then a1=1;a2=-1 elseif D.dir==e.c.Turtle.Direction.Left then a0=true;a1=-1;a2=-1 end;local a3=D.v.x;local a4=D.v.z;local a5=M%2==0;if not a5 then local a6=a2*(u.forward-1)d.info(string.format("..Resume: forward %d",u.forward-1))if a0 then a3=D.v.x+a6 else a4=D.v.z+a6 end;h.goTo(a3,a4)end;local a7=a1*(M-1)d.info(string.format("..Resume: left %d",M-1))if a0 then h.goTo(a3,a4+a7,nil,D.dir)else h.goTo(a3+a7,a4,nil,D.dir)end;h.turnLeft()d.info(string.format("..Resume: dig",M-1))T(1,u.walls,a5,not a5,X)if a5 then d.info("..Resume: turn right")h.turnRight()else d.info("..Resume: turn left")h.turnLeft()end end;local function a8(a9,aa)local u=j.s.job.get()local ab=1/u.levels;h.turnTo(D.dir)O()local H=h.s.position.get()if H.v.x==0 and H.v.z==0 and H.v.y==0 then R()T(1,u.walls,u.left==1,true)if F~=E.Running then return end;H=h.s.position.get()D=c.copy(H)end;Z()local I=j.s.progress.get()local ac=H.v.y-D.v.y;if I.completedLevels>0 then i.digDown(I.completedLevels+ac)end;h.turnRight()if u.walls then i.fill(true)if not a9 then h.turnRight()i.fill(true)h.turnLeft()end;h.turnLeft()if aa then i.fillDown(true)end end;if I.completedRows>0 then _(I.completedRows,aa)end;for ad=I.completedRows+1,u.left,1 do local ae=ad%2==0;local af=ad==u.left;L(ad)local V=af and not ae;local W=ad==1 or af and ae;T(u.forward-1,u.walls,V,W,aa)if F~=E.Running then return end;if u.walls then i.fill(true)end;if ad<u.left then if ae then h.turnRight()else h.turnLeft()end;T(1,u.walls,ae,not ae)if F~=E.Running then return end;if ad+1==u.left then i.fill(true)end;if ae then h.turnRight()else h.turnLeft()end;if aa then i.fillDown(true)end end;N()if F~=E.Running then return end end;I=j.s.progress.get()d.info(string.format("..Return to start (%d%%, %d%%)",u.percentPerLevel*100,I.current*100))while not h.goTo(D.v.x,D.v.z,nil,D.dir)do i.error("Cannot Return to Start")sleep(3)end;P()end;local function ag(ah,ai,aj,ak)a.expect(1,ah,"number")a.expect(2,aj,"number")a.expect(3,ai,"number")a.expect(4,ak,"number")a.range(ak,1,4)j.s.offsetPos.set(h.TurtlePosition(vector.new(ah,ai,aj),ak))end;local function al()C.offsetPos.set(false)end;local function am()return j.s.autoResume.get()and not j.s.progress.get().finished end;local function an(l,m,n,o)a.expect(1,l,"number")a.expect(2,m,"number")a.expect(3,n,"number")a.range(l,1)a.range(m,1)a.range(n,1)local u=k(l,m,n,o)j.s.job.set(u)local I=c.copy(j.s.progress.default)I.finished=false;J(I)end;local function ao()local u=j.s.job.get()e.TurtleStartedEvent():send()i.emptyInventory()local I=j.s.progress.get()while I.completedLevels<u.levels and(F==E.Running or F==E.Paused)do if F==E.Running then if I.completedLevels%u.refuelLevel==0 then i.refuel(u.refuelTarget,I.completedLevels~=0)end;a8(I.completedLevels==0,I.completedLevels+1==u.levels)I=j.s.progress.get()if F==E.Paused then i.emptyInventory()e.TurtlePausedEvent():send()end else sleep(5)end end;Q()i.emptyInventory()if F==E.Halted then e.TurtleExitEvent(false):send()sleep(3)F=E.Completed else e.TurtleExitEvent(true):send()end end;local function ap()while F~=E.Completed do local aq=os.startTimer(3)local ar,as=c.cleanEventArgs(os.pullEvent())if ar==e.c.Event.Pathfind.position then local H=h.TurtlePosition.deserialize(nil,as[1].position)G(H)elseif ar==e.c.Event.Pathfind.go_to then local at=as[1]if at.gotoType==e.c.Turtle.GoTo.Return then if at.success==nil then K("Resuming")else local I=j.s.progress.get()local u=j.s.job.get()if I.completedRows==u.left then K(string.format("Completed Row %d",I.completedRows))else K(string.format("Digging Row %d",I.completedRows+1))end end end elseif ar==e.c.Event.Progress then g.print(e.getComputer(),as[1])elseif ar==e.c.Event.Turtle.empty then K("Emptying Inventory")elseif ar==e.c.Event.Turtle.exited then if as[1].completed then K("success:Completed")F=E.Completed else K("error:Stopped")F=E.Halted end elseif ar==e.c.Event.Turtle.request_pause then F=E.Paused;d.info("Pausing...")elseif ar==e.c.Event.Turtle.request_halt then F=E.Halted;d.info("Halting...")elseif ar==e.c.Event.Turtle.request_continue then F=E.Running;d.info("Unpausing...")e.TurtleStartedEvent():send()elseif ar==e.c.Event.Turtle.paused then K("warning:Paused")elseif ar==e.c.Event.Turtle.fetch_fill then K("Getting Fill Block")elseif ar==e.c.Event.Turtle.refuel then K("Refueling")elseif ar==e.c.Event.Turtle.error then K(string.format("error:%s",as[1].error))end;g.handle(e.getComputer(),ar,as)os.cancelTimer(aq)end end;local function au()e.initNetwork()if not e.online then return end;while F~=E.Completed do local av,aw=rednet.receive(nil,3)if aw~=nil and aw.type==e.type and aw.src.id==os.getComputerID()then if aw.name==e.c.Event.Turtle.request_halt then F=E.Halted;d.info("Halting...")elseif aw.name==e.c.Event.Turtle.request_pause then F=E.Paused;d.info("Pausing...")elseif aw.name==e.c.Event.Turtle.request_continue then F=E.Halted;d.info("Unpausing...")e.TurtleStartedEvent():send()end end end end;local function ax(ay)a.expect(1,ay,"boolean","nil")if ay==nil then ay=false end;e.initNetwork()local u=j.s.job.get()term.clear()term.setCursorPos(1,1)if not d.s.print.get()then g.print(e.getComputer(),e.QuarryProgressEvent(h.s.position.get(),u,j.s.progress.get()))end;if ay then d.info(string.format("Resume Quarry: %d x %d (%d)",u.left,u.forward,u.levels))K("Resuming")else d.info(string.format("Quarry: %d x %d (%d)",u.left,u.forward,u.levels))end;parallel.waitForAll(ao,ap,au)term.setCursorBlink(true)if not d.s.print.get()then term.clear()term.setCursorPos(1,1)end;d.s.print.set(true)end;j.setOffset=ag;j.clearOffset=al;j.canResume=am;j.setJob=an;j.runJob=ax;return j
