local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.log")local e=require("am.event")local f=require("am.helpers")local g=require("am.pathfind")local h=require("am.turtle")local i={}local j=b:extend("am.q.QuarryJob")i.QuarryJob=j;function j:init(k,l,m,n,o)a.expect(1,k,"number")a.expect(2,l,"number")a.expect(3,m,"number")a.expect(4,n,"boolean")a.expect(5,o,"boolean","nil")a.range(k,1)a.range(l,1)j.super.init(self)if o==nil then o=false end;self.left=k;self.forward=l;self.levels=m;self.walls=n;self.refuelTarget=320;self.refuelLevel=1;self.percentPerLevel=1;if not o then self:calculateExtra()end;return self end;function j:calculateExtra()local p=self.left*self.forward+self.left*2+self.forward*2;local q=p;local r=self.levels;if turtle.getFuelLimit()=="unlimited"then q=p*self.levels else r=1;while r<self.levels and q+p<turtle.getFuelLimit()do q=q+p;r=r+1 end end;self.refuelTarget=q;self.refuelLevel=r;self.percentPerLevel=1/self.levels end;function j:deserialize(s)local t=j(s.left,s.forward,s.levels,s.walls,true)t.refuelTarget=s.refuelTarget;t.refuelLevel=s.refuelLevel;t.percentPerLevel=s.percentPerLevel;return t end;local u=b:extend("am.q.QuarryProgress")i.QuarryProgress=u;function u:init(v,w,x,y,z,A)a.expect(1,v,"number")a.expect(2,w,"number")a.expect(3,x,"number")a.expect(4,y,"number")a.expect(5,z,"boolean")a.expect(6,A,"string")a.range(v,0)a.range(w,0)a.range(x,0)a.range(y,0)j.super.init(self)self.current=v;self.levelCurrent=w;self.completedLevels=x;self.completedRows=y;self.finished=z;self.status=A;return self end;function u:deserialize(s)return u(s.current,s.levelCurrent,s.completedLevels,s.completedRows,s.finished,s.status)end;local B={}B.job={name="quarry.job",default=j(16,16,1,true),type="table"}B.progress={name="quarry.progress",default=u(0,0,0,0,true,""),type="table"}B.autoResume={name="quarry.autoResume",default=true,type="boolean"}B.offsetPos={name="quarry.offsetPos",default=false}i.s=c.makeSettingWrapper(B)i.s.job.get=function()return j.deserialize(nil,settings.get(i.s.job.name))end;i.s.progress.get=function()return u.deserialize(nil,settings.get(i.s.progress.name))end;i.s.offsetPos.get=function()local s=settings.get(i.s.offsetPos.name)if s then s=g.TurtlePosition.deserialize(nil,settings.get(i.s.offsetPos.name))end;return s end;local C=g.TurtlePosition(0,1,0,e.c.Turtle.Direction.Front)local D={Running=1,Completed=2,Paused=3,Halted=4}local E=D.Running;local function F(G,H)a.expect(1,G,"table","nil")a.expect(2,H,"table","nil")if G~=nil then f.requirePosition(G)end;if G==nil then G=g.s.position.get()end;if H==nil then H=i.s.progress.get()end;e.QuarryProgressEvent(G,i.s.job.get(),H):send()end;local function I(H)a.expect(1,H,"table")if not b:has(H,"am.q.QuarryProgress")then error("Not progress obj")end;i.s.progress.set(H)F(nil,H)end;local function J(A)a.expect(1,A,"string")local H=i.s.progress.get()H.status=A;I(H)end;local function K(L)a.expect(1,L,"number")a.range(L,1)local H=i.s.progress.get()local t=i.s.job.get()H.completedRows=L-1;H.levelPercent=H.completedRows/t.left;H.totalPercent=H.completedLevels/t.levels+t.percentPerLevel*H.levelPercent;H.status=string.format("Digging Row %d",L)I(H)d.log(string.format("..Start row %d of %d (%d%%, %d%%)",L,t.left,H.levelPercent*100,H.totalPercent*100))end;local function M()local H=i.s.progress.get()local t=i.s.job.get()H.completedRows=H.completedRows+1;H.levelPercent=H.completedRows/t.left;H.totalPercent=H.completedLevels/t.levels+t.percentPerLevel*H.levelPercent;H.status=string.format("Completed Row %d",H.completedRows)I(H)end;local function N()local H=i.s.progress.get()local t=i.s.job.get()H.levelPercent=0;H.status=string.format("Starting Level %d",H.completedLevels+1)I(H)d.log(string.format(".Start level %d of %d (%d%%, %d%%)",H.completedLevels+1,t.levels,H.levelPercent*100,H.current*100))end;local function O()local H=i.s.progress.get()local t=i.s.job.get()H.completedLevels=H.completedLevels+1;H.completedRows=0;H.levelPercent=1;H.totalPercent=H.completedLevels/t.levels;H.status=string.format("Completing Level %d",H.completedLevels-1)I(H)end;local function P()local H=i.s.progress.get()H.finished=true;H.status="Finishing Job"I(H)end;local function Q()local R=i.s.offsetPos.get()if R then J("Going to Offset")while not g.goTo(R.x,R.z,R.y,R.dir)do h.error("Cannot Goto Offset")sleep(3)end;g.addNode()end end;local function S(T,n,U,V,W)a.expect(1,T,"number","nil")a.expect(2,n,"boolean","nil")a.expect(3,U,"boolean","nil")a.expect(4,V,"boolean","nil")a.expect(5,W,"boolean","nil")if T==nil then T=1 end;if n==nil then n=true end;if U==nil then U=false end;if V==nil then V=false end;if W==nil then W=false end;for X=1,T,1 do h.digForward()if n then if not turtle.detectDown()and(W or h.isSourceBlockDown())then h.fillDown(true)end;if U then g.turnLeft()h.fillForward(true)g.turnRight()end;if V then g.turnRight()h.fillForward(true)g.turnLeft()end end;if E~=D.Running then return end end end;local function Y()local R=i.s.offsetPos.get()g.resetNodes()if R then g.addNode(R)end;g.addNode(C)end;local function Z(L,W)J(string.format("Returning to Row %d",L))d.log(string.format("..Resume start: %s",d.format(C)))local t=i.s.job.get()local _=false;local a0=-1;local a1=1;if C.dir==e.c.Turtle.Direction.Right then _=true;a0=1;a1=1 elseif C.dir==e.c.Turtle.Direction.Back then a0=1;a1=-1 elseif C.dir==e.c.Turtle.Direction.Left then _=true;a0=-1;a1=-1 end;local a2=C.x;local a3=C.z;local a4=L%2==0;if not a4 then local a5=a1*(t.forward-1)d.log(string.format("..Resume: forward %d",t.forward-1))if _ then a2=C.x+a5 else a3=C.z+a5 end;g.goTo(a2,a3)end;local a6=a0*(L-1)d.log(string.format("..Resume: left %d",L-1))if _ then g.goTo(a2,a3+a6,nil,C.dir)else g.goTo(a2+a6,a3,nil,C.dir)end;g.turnLeft()d.log(string.format("..Resume: dig",L-1))S(1,t.walls,a4,not a4,W)if a4 then d.log("..Resume: turn right")g.turnRight()else d.log("..Resume: turn left")g.turnLeft()end end;local function a7(a8,a9)local t=i.s.job.get()local aa=1/t.levels;g.turnTo(C.dir)N()local G=g.getPosition()if G.x==0 and G.z==0 and G.y==0 then Q()S(1,t.walls,t.left==1,true)if E~=D.Running then return end;G=g.getPosition()C=c.copy(G)end;Y()local H=i.s.progress.get()local ab=G.y-C.y;if H.completedLevels>0 then h.digDown(H.completedLevels+ab)end;g.turnRight()if t.walls then h.fillForward(true)if not a8 then g.turnRight()h.fillForward(true)g.turnLeft()end;g.turnLeft()if a9 then h.fillDown(true)end end;if H.completedRows>0 then Z(H.completedRows,a9)end;for ac=H.completedRows+1,t.left,1 do local ad=ac%2==0;local ae=ac==t.left;K(ac)local U=ae and not ad;local V=ac==1 or ae and ad;S(t.forward-1,t.walls,U,V,a9)if E~=D.Running then return end;if t.walls then h.fillForward(true)end;if ac<t.left then if ad then g.turnRight()else g.turnLeft()end;S(1,t.walls,ad,not ad)if E~=D.Running then return end;if ac+1==t.left then h.fillForward(true)end;if ad then g.turnRight()else g.turnLeft()end;if a9 then h.fillDown(true)end end;M()if E~=D.Running then return end end;H=i.s.progress.get()d.log(string.format("..Return to start (%d%%, %d%%)",t.percentPerLevel*100,H.current*100))while not g.goTo(C.x,C.z,nil,C.dir)do h.error("Cannot Return to Start")sleep(3)end;O()end;local function af(ag,ah,ai,aj)a.expect(1,ag,"number")a.expect(2,ai,"number")a.expect(3,ah,"number")a.expect(4,aj,"number")a.range(aj,1,4)i.s.offsetPos.set(g.TurtlePosition(ag,ah,ai,aj))end;local function ak()B.offsetPos.set(false)end;local function al()return i.s.autoResume.get()and not i.s.progress.get().finished end;local function am(k,l,m,n)a.expect(1,k,"number")a.expect(2,l,"number")a.expect(3,m,"number")a.range(k,1)a.range(l,1)a.range(m,1)local t=j(k,l,m,n)i.s.job.set(t)local H=c.copy(i.s.progress.default)H.finished=false;I(H)end;local function an()local t=i.s.job.get()e.TurtleStartedEvent():send()h.emptyInventory()local H=i.s.progress.get()while H.completedLevels<t.levels and(E==D.Running or E==D.Paused)do if E==D.Running then if H.completedLevels%t.refuelLevel==0 then h.goRefuel(t.refuelTarget,H.completedLevels~=0)end;a7(H.completedLevels==0,H.completedLevels+1==t.levels)H=i.s.progress.get()if E==D.Paused then h.emptyInventory()e.TurtlePausedEvent():send()end else sleep(5)end end;P()h.emptyInventory()if E==D.Halted then e.TurtleExitEvent(false):send()sleep(3)E=D.Completed else e.TurtleExitEvent(true):send()end end;local ao=function()while runType~=D.Completed do local ap=os.startTimer(3)local aq,ar=c.cleanEventArgs(os.pullEvent())if aq==e.c.Event.Pathfind.position then F(ar[1].position)elseif aq==e.c.Event.Pathfind.go_to then local as=ar[1]if as.gotoType==e.c.Turtle.GoTo.Return then if as.success==nil then J("Resuming")else local H=i.s.progress.get()local t=i.s.job.get()if H.completedRows==t.left then J(string.format("Completed Row %d",H.completedRows))else J(string.format("Digging Row %d",H.completedRows+1))end end end elseif aq==e.c.Event.Progress then elseif aq==e.c.Event.Turtle.empty then J("Emptying Inventory")elseif aq==e.c.Event.Turtle.exited then if ar[1].completed then J("success:Completed")runType=D.Completed else J("error:Stopped")runType=D.Halted end elseif aq==e.c.Event.Turtle.request_pause then runType=D.Paused;d.log("Pausing...")elseif aq==e.c.Event.Turtle.request_halt then runType=D.Halted;d.log("Halting...")elseif aq==e.c.Event.Turtle.request_continue then runType=D.Running;d.log("Unpausing...")e.TurtleStartedEvent():send()elseif aq==e.c.Event.Turtle.paused then J("warning:Paused")elseif aq==e.c.Event.Turtle.fetch_fill then J("Getting Fill Block")elseif aq==e.c.Event.Turtle.refuel then J("Refueling")elseif aq==e.c.Event.Turtle.error then J(string.format("error:%s",ar[1].error))end;os.cancelTimer(ap)end end;local at=function()e.initNetwork()if not e.online then return end;while runType~=D.Completed do local au,av=rednet.receive(nil,3)if av~=nil and av.type==e.type and av.src.id==os.getComputerID()then if av.name==e.c.Event.Turtle.request_halt then runType=D.Halted;d.log("Halting...")elseif av.name==e.c.Event.Turtle.request_pause then runType=D.Paused;d.log("Pausing...")elseif av.name==e.c.Event.Turtle.request_continue then runType=D.Halted;d.log("Unpausing...")e.TurtleStartedEvent():send()end end end end;local function aw(ax)a.expect(1,ax,"boolean","nil")if ax==nil then ax=false end;e.initNetwork()local t=i.s.job.get()term.clear()term.setCursorPos(1,1)if ax then d.log(string.format("Resume Quarry: %d x %d (%d)",t.left,t.forward,t.levels))J("Resuming")if not settings.get(d.s.print.name)then end else d.log(string.format("Quarry: %d x %d (%d)",t.left,t.forward,t.levels))end;parallel.waitForAll(an,ao,at)term.setCursorBlink(true)d.setPrint(true)end;i.setOffset=af;i.clearOffset=ak;i.canResume=al;i.setJob=am;i.runJob=aw;return i
