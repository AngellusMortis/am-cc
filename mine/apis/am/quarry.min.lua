local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.log")local e=require("am.event")local f=require("am.helpers")local g=require("am.progress")local h=require("am.pathfind")local i=require("am.turtle")local j={}local k=b:extend("am.q.QuarryJob")j.QuarryJob=k;function k:init(l,m,n,o,p)a.expect(1,l,"number","nil")a.expect(2,m,"number","nil")a.expect(3,n,"number")a.expect(4,o,"boolean")a.expect(5,p,"boolean","nil")if l~=nil then a.range(l,1)end;if m~=nil then a.range(m,1)end;k.super.init(self)if l==nil or m==nil then p=true end;if p==nil then p=false end;self.left=l;self.forward=m;self.levels=n;self.walls=o;self.refuelTarget=320;self.refuelLevel=1;self.percentPerLevel=1;if not p then self:calculateExtra()end;return self end;local q=k:extend("am.q.ReadyQuarryJob")j.ReadyQuarryJob=q;function k:calculateExtra()local r=self.left*self.forward+self.left*2+self.forward*2;local s=r;local t=self.levels;if turtle.getFuelLimit()=="unlimited"then s=r*self.levels else t=1;while t<self.levels and s+r<turtle.getFuelLimit()do s=s+r;t=t+1 end end;self.refuelTarget=s;self.refuelLevel=t;self.percentPerLevel=1/self.levels end;function k:deserialize(u)local v=k(u.left,u.forward,u.levels,u.walls,true)v.refuelTarget=u.refuelTarget;v.refuelLevel=u.refuelLevel;v.percentPerLevel=u.percentPerLevel;return v end;local w=b:extend("am.q.QuarryProgress")j.QuarryProgress=w;function w:init(x,y,z,A,B,C)a.expect(1,x,"number")a.expect(2,y,"number")a.expect(3,z,"number")a.expect(4,A,"number")a.expect(5,B,"boolean")a.expect(6,C,"string")a.range(x,0)a.range(y,0)a.range(z,0)a.range(A,0)k.super.init(self)self.current=x;self.levelCurrent=y;self.completedLevels=z;self.completedRows=A;self.finished=B;self.status=C;self.hitBedrock=false;return self end;function w:deserialize(u)return w(u.current,u.levelCurrent,u.completedLevels,u.completedRows,u.finished,u.status)end;local D={}D.job={name="quarry.job",default=k(16,16,1,true),type="table"}D.progress={name="quarry.progress",default=w(0,0,0,0,true,""),type="table"}D.autoResume={name="quarry.autoResume",default=true,type="boolean"}D.offsetPos={name="quarry.offsetPos",default=false}j.s=c.makeSettingWrapper(D)j.s.job.get=function()return k.deserialize(nil,settings.get(j.s.job.name))end;j.s.progress.get=function()return w.deserialize(nil,settings.get(j.s.progress.name))end;j.s.offsetPos.get=function()local u=settings.get(j.s.offsetPos.name)if u then u=h.TurtlePosition.deserialize(nil,settings.get(j.s.offsetPos.name))end;return u end;local E=h.TurtlePosition(vector.new(0,0,1),e.c.Turtle.Direction.Front)local F={Running=1,Completed=2,Paused=3,Halted=4}local G=F.Running;local function H(I,J)a.expect(1,I,"table","nil")a.expect(2,J,"table","nil")if I~=nil then f.requirePosition(1,I)end;if I==nil then I=h.s.position.get()end;if J==nil then J=j.s.progress.get()end;e.QuarryProgressEvent(I,j.s.job.get(),J):send()end;local function K(J)a.expect(1,J,"table")if not b.has(J,"am.q.QuarryProgress")then error("Not progress obj")end;j.s.progress.set(J)H(nil,J)end;local function L(C)a.expect(1,C,"string")local J=j.s.progress.get()J.status=C;K(J)end;local function M(N)a.expect(1,N,"number")a.range(N,1)local J=j.s.progress.get()local v=j.s.job.get()J.completedRows=N-1;J.levelCurrent=J.completedRows/v.left;J.current=J.completedLevels/v.levels+v.percentPerLevel*J.levelCurrent;J.status=string.format("Digging Row %d",N)K(J)d.info(string.format("..Start row %d of %d (%d%%, %d%%)",N,v.left,J.levelCurrent*100,J.current*100))end;local function O()local J=j.s.progress.get()local v=j.s.job.get()J.completedRows=J.completedRows+1;J.levelCurrent=J.completedRows/v.left;J.current=J.completedLevels/v.levels+v.percentPerLevel*J.levelCurrent;J.status=string.format("Completed Row %d",J.completedRows)K(J)end;local function P()local J=j.s.progress.get()local v=j.s.job.get()J.levelCurrent=0;J.status=string.format("Starting Level %d",J.completedLevels+1)K(J)d.info(string.format(".Start level %d of %d (%d%%, %d%%)",J.completedLevels+1,v.levels,J.levelCurrent*100,J.current*100))end;local function Q()local J=j.s.progress.get()local v=j.s.job.get()J.completedLevels=J.completedLevels+1;J.completedRows=0;J.levelCurrent=1;J.current=J.completedLevels/v.levels;J.status=string.format("Completing Level %d",J.completedLevels-1)K(J)end;local function R()local J=j.s.progress.get()J.finished=true;J.status="Finishing Job"K(J)end;local function S()local T=j.s.offsetPos.get()if T then L("Going to Offset")while not h.goTo(T.v.x,T.v.z,T.v.y,T.dir)do i.error("Cannot Goto Offset")sleep(3)end;h.addNode()end end;local function U(V,o,W,X,Y)a.expect(1,V,"number","nil")a.expect(2,o,"boolean","nil")a.expect(3,W,"boolean","nil")a.expect(4,X,"boolean","nil")a.expect(5,Y,"boolean","nil")if V==nil then V=1 end;if o==nil then o=true end;if W==nil then W=false end;if X==nil then X=false end;if Y==nil then Y=false end;for Z=1,V,1 do if not i.dig()then return false end;if not turtle.detectDown()and(Y and o or i.isSourceBlockDown())then i.fillDown(true)end;if o then if W then h.turnLeft()i.fill(true)h.turnRight()end;if X then h.turnRight()i.fill(true)h.turnLeft()end end;if G~=F.Running then return true end end;return true end;local function _()local T=j.s.offsetPos.get()h.resetNodes()if T then h.addNode(T)end;h.addNode(E)end;local function a0(N,Y)L(string.format("Returning to Row %d",N))d.info(string.format("..Resume start: %s",d.format(E)))local v=j.s.job.get()local a1=false;local a2=-1;local a3=1;if E.dir==e.c.Turtle.Direction.Right then a1=true;a2=1;a3=1 elseif E.dir==e.c.Turtle.Direction.Back then a2=1;a3=-1 elseif E.dir==e.c.Turtle.Direction.Left then a1=true;a2=-1;a3=-1 end;local a4=E.v.x;local a5=E.v.z;local a6=N%2==0;if not a6 then local a7=a3*(v.forward-1)d.info(string.format("..Resume: forward %d",v.forward-1))if a1 then a4=E.v.x+a7 else a5=E.v.z+a7 end;h.goTo(a4,a5)end;local a8=a2*(N-1)d.info(string.format("..Resume: left %d",N-1))if a1 then h.goTo(a4,a5+a8,nil,E.dir)else h.goTo(a4+a8,a5,nil,E.dir)end;h.turnLeft()d.info(string.format("..Resume: dig",N-1))if not U(1,v.walls,a6,not a6,Y)then return false end;if a6 then d.info("..Resume: turn right")h.turnRight()else d.info("..Resume: turn left")h.turnLeft()end;return true end;local function a9(aa,ab)local v=j.s.job.get()local ac=1/v.levels;local o=not aa and v.walls;h.turnTo(E.dir)P()local I=h.s.position.get()if I.v.x==0 and I.v.z==0 and I.v.y==0 then S()if not U(1,o,v.left==1,true)then return false end;if G~=F.Running then return true end;I=h.s.position.get()E=c.copy(I)end;_()local J=j.s.progress.get()local ad=I.v.y-E.v.y;if J.completedLevels>0 then for Z=1,J.completedLevels+ad,1 do if not i.digDown()then return false end end end;if o then h.turnRight()i.fill(true)if not aa then h.turnRight()i.fill(true)h.turnLeft()end;h.turnLeft()if ab then i.fillDown(true)end end;if J.completedRows>0 then if not a0(J.completedRows,ab)then return false end end;for ae=J.completedRows+1,v.left,1 do local af=ae%2==0;local ag=ae==v.left;M(ae)local W=ag and not af;local X=ae==1 or ag and af;if not U(v.forward-1,o,W,X,ab)then return false end;if G~=F.Running then return true end;if o then i.fill(true)end;if ae<v.left then if af then h.turnRight()else h.turnLeft()end;if not U(1,o,af,not af)then return false end;if G~=F.Running then return true end;if ae+1==v.left and o then i.fill(true)end;if af then h.turnRight()else h.turnLeft()end;if ab and o then i.fillDown(true)end end;O()if G~=F.Running then return true end end;J=j.s.progress.get()d.info(string.format("..Return to start (%d%%, %d%%)",v.percentPerLevel*100,J.current*100))while not h.goTo(E.v.x,E.v.z,nil,E.dir)do i.error("Cannot Return to Start")sleep(3)end;Q()return true end;local function ah(ai,aj,ak,al)a.expect(1,ai,"number")a.expect(2,ak,"number")a.expect(3,aj,"number")a.expect(4,al,"number")a.range(al,1,4)j.s.offsetPos.set(h.TurtlePosition(vector.new(ai,ak,aj),al))end;local function am()D.offsetPos.set(false)end;local function an()return j.s.autoResume.get()and not j.s.progress.get().finished end;local function ao(l,m,n,o)a.expect(1,l,"number","nil")a.expect(2,m,"number","nil")a.expect(3,n,"number")if l~=nil then a.range(l,1)end;if m~=nil then a.range(m,1)end;a.range(n,1)local v=k(l,m,n,o)j.s.job.set(v)local J=c.copy(j.s.progress.default)J.finished=false;K(J)end;local function ap()d.info("Discovering Boundary")L("Discovering Boundary")i.refuel(500)S()i.dig()h.turnRight()if not turtle.detect()then while h.forward()do end;h.turnLeft()while h.forward()do end;h.turnRight()i.dig()h.turnRight()h.turnRight()local I=h.s.position.get()j.setOffset(I.v.x,I.v.z,I.v.y,I.dir)d.info(string.format("Setting new offset: %s",d.format(I)))L(string.format("Set Offset: (%d, %d)",I.v.x,I.v.z))h.forward()h.turnRight()end;local m=1;local l=1;h.turnLeft()while h.forward()do m=m+1 end;h.turnLeft()while h.forward()do l=l+1;local I=h.s.position.get()if I.v.x==0 and I.v.z==1 then break end end;d.info(string.format("Discovered Boundary: %d %d",l,m))L(string.format("Discovered: %dx%d",l,m))h.resetNodes()h.goToOrigin()h.resetNodes()return l,m end;local function aq()local v=j.s.job.get()if v.left==nil or v.forward==nil then local l,m=ap()ao(l,m,v.levels,v.walls)v=j.s.job.get()end;e.TurtleStartedEvent():send()i.emptyInventory()local J=j.s.progress.get()local ar=false;while J.completedLevels<v.levels and(G==F.Running or G==F.Paused)do if G==F.Running then if J.completedLevels%v.refuelLevel==0 then i.refuel(v.refuelTarget,J.completedLevels~=0)end;if not a9(J.completedLevels==0,J.completedLevels+1==v.levels)then ar=true;break end;J=j.s.progress.get()if G==F.Paused then i.emptyInventory()e.TurtlePausedEvent():send()end else sleep(5)end end;if ar then J=j.s.progress.get()j.s.job.set(k(v.left,v.forward,J.completedLevels+1,v.walls))Q()J=j.s.progress.get()J.hitBedrock=true;J.status="Hit Bedrock"K(J)end;R()i.emptyInventory()if G==F.Halted then e.TurtleExitEvent(false):send()sleep(3)G=F.Completed else e.TurtleExitEvent(true):send()end end;local function as()while G~=F.Completed do local at=os.startTimer(3)local au,av=c.cleanEventArgs(os.pullEvent())if au==e.c.Event.Pathfind.position then local I=h.TurtlePosition.deserialize(nil,av[1].position)H(I)elseif au==e.c.Event.Pathfind.go_to then local aw=av[1]if aw.gotoType==e.c.Turtle.GoTo.Return then if aw.success==nil then L("Resuming")else local J=j.s.progress.get()local v=j.s.job.get()if J.completedRows==v.left then L(string.format("Completed Row %d",J.completedRows))else L(string.format("Digging Row %d",J.completedRows+1))end end end elseif au==e.c.Event.Progress then g.print(e.getComputer(),av[1])elseif au==e.c.Event.Turtle.empty then L("Emptying Inventory")elseif au==e.c.Event.Turtle.exited then if av[1].completed then L("success:Completed")G=F.Completed else L("error:Stopped")G=F.Halted end elseif au==e.c.Event.Turtle.request_pause then G=F.Paused;d.info("Pausing...")elseif au==e.c.Event.Turtle.request_halt then G=F.Halted;d.info("Halting...")elseif au==e.c.Event.Turtle.request_continue then G=F.Running;d.info("Unpausing...")e.TurtleStartedEvent():send()elseif au==e.c.Event.Turtle.paused then L("warning:Paused")elseif au==e.c.Event.Turtle.fetch_fill then L("Getting Fill Block")elseif au==e.c.Event.Turtle.refuel then L("Refueling")elseif au==e.c.Event.Turtle.error then L(string.format("error:%s",av[1].error))end;g.handle(e.getComputer(),au,av)os.cancelTimer(at)end end;local function ax()e.initNetwork()if not e.online then return end;while G~=F.Completed do local ay=e.receive()if ay~=nil then id=os.getComputerID()if ay.name==e.c.Event.Turtle.request_halt and ay.event.id==id then G=F.Halted;d.info("Halting...")elseif ay.name==e.c.Event.Turtle.request_pause and ay.event.id==id then G=F.Paused;d.info("Pausing...")elseif ay.name==e.c.Event.Turtle.request_continue and ay.event.id==id then G=F.Halted;d.info("Unpausing...")e.TurtleStartedEvent():send()end end end end;local function az(aA)a.expect(1,aA,"boolean","nil")if aA==nil then aA=false end;e.initNetwork()local v=j.s.job.get()term.clear()term.setCursorPos(1,1)if not d.s.print.get()then g.print(e.getComputer(),e.QuarryProgressEvent(h.s.position.get(),v,j.s.progress.get()))end;local aB=""if v.left~=nil and v.forward~=nil then aB=string.format(": %d x %d (%d)",v.left,v.forward,v.levels)end;if aA then d.info(string.format("Resume Quarry%s",aB))L("Resuming")else d.info(string.format("Quarry%s",aB))end;parallel.waitForAll(aq,as,ax)term.setCursorBlink(true)if not d.s.print.get()then term.clear()term.setCursorPos(1,1)end;d.s.print.set(true)end;j.setOffset=ah;j.clearOffset=am;j.canResume=an;j.setJob=ao;j.runJob=az;return j
