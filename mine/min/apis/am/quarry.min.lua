local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.log")local e=require("am.event")local f=require("am.helpers")local g=require("am.progress")local h=require("am.pathfind")local i=require("am.turtle")local j={}local k=b:extend("am.q.QuarryJob")j.QuarryJob=k;function k:init(l,m,n,o,p)a.expect(1,l,"number","nil")a.expect(2,m,"number","nil")a.expect(3,n,"number")a.expect(4,o,"boolean")a.expect(5,p,"boolean","nil")if l~=nil then a.range(l,1)end;if m~=nil then a.range(m,1)end;k.super.init(self)if l==nil or m==nil then p=true end;if p==nil then p=false end;self.left=l;self.forward=m;self.levels=n;self.walls=o;self.refuelTarget=320;self.refuelLevel=1;self.percentPerLevel=1;if not p then self:calculateExtra()end;return self end;local q=k:extend("am.q.ReadyQuarryJob")j.ReadyQuarryJob=q;function k:calculateExtra()local r=self.left*self.forward+self.left*2+self.forward*2;local s=r;local t=self.levels;if turtle.getFuelLimit()=="unlimited"then s=r*self.levels else t=1;while t<self.levels and s+r<turtle.getFuelLimit()do s=s+r;t=t+1 end end;self.fuelPerLevel=r;self.refuelTarget=s;self.refuelLevel=t;self.percentPerLevel=1/self.levels end;function k:deserialize(u)local v=k(u.left,u.forward,u.levels,u.walls,true)v.refuelTarget=u.refuelTarget;v.refuelLevel=u.refuelLevel;v.percentPerLevel=u.percentPerLevel;v.fuelPerLevel=u.fuelPerLevel;return v end;local w=b:extend("am.q.QuarryProgress")j.QuarryProgress=w;function w:init(x,y,z,A,B,C)a.expect(1,x,"number")a.expect(2,y,"number")a.expect(3,z,"number")a.expect(4,A,"number")a.expect(5,B,"boolean")a.expect(6,C,"string")a.range(x,0)a.range(y,0)a.range(z,0)a.range(A,0)k.super.init(self)self.current=x;self.levelCurrent=y;self.completedLevels=z;self.completedRows=A;self.finished=B;self.status=C;self.hitBedrock=false;self.items={}return self end;function w:deserialize(u)local D=w(u.current,u.levelCurrent,u.completedLevels,u.completedRows,u.finished,u.status)if u.hitBedrock~=nil then D.hitBedrock=u.hitBedrock end;if u.items~=nil then D.items=u.items end;return D end;local E={}E.autoResume={name="quarry.autoResume",default=true,type="boolean"}E.offsetPos={name="quarry.offsetPos",default=false}j.s=c.makeSettingWrapper(E)local F={}F.job={name="job",default=k(16,16,1,true),type="table"}F.progress={name="progress",default=w(0,0,0,0,true,""),type="table"}j.d=c.makeDataWrapper(F,"quarry")local G=h.TurtlePosition(vector.new(0,0,1),e.c.Turtle.Direction.Front)local H={Running=1,Completed=2,Paused=3,Halted=4}local I=H.Running;local J=true;local K=nil;local function L()return k.deserialize(nil,j.d.job.get())end;local function M()return w.deserialize(nil,j.d.progress.get())end;local function N()local u=j.s.offsetPos.get()if u then u=h.TurtlePosition.deserialize(nil,u)end;return u end;local function O(P,D)a.expect(1,P,"table","nil")a.expect(2,D,"table","nil")if P~=nil then f.requirePosition(1,P)end;if P==nil then P=h.getPos()end;if D==nil then D=M()end;e.QuarryProgressEvent(P,L(),D):send()end;local function Q(D)a.expect(1,D,"table")if not b.has(D,"am.q.QuarryProgress")then error("Not progress obj")end;j.d.progress.set(D)O(nil,D)end;local function R(C)a.expect(1,C,"string")local D=M()D.status=C;Q(D)end;local function S(T)local D=M()for U,V in ipairs(T.items)do if D.items[V.name]==nil then V.tags=nil;D.items[V.name]=V else local W=D.items[V.name]W.count=W.count+V.count;D.items[V.name]=W end end;Q(D)end;local function X(Y)a.expect(1,Y,"number")a.range(Y,1)local D=M()local v=L()D.completedRows=Y-1;D.levelCurrent=D.completedRows/v.left;D.current=D.completedLevels/v.levels+v.percentPerLevel*D.levelCurrent;D.status=string.format("Digging Row %d",Y)Q(D)d.info(string.format("..Start row %d of %d (%d%%, %d%%)",Y,v.left,D.levelCurrent*100,D.current*100))end;local function Z()local D=M()local v=L()D.completedRows=D.completedRows+1;D.levelCurrent=D.completedRows/v.left;D.current=D.completedLevels/v.levels+v.percentPerLevel*D.levelCurrent;D.status=string.format("Completed Row %d",D.completedRows)Q(D)end;local function _()local D=M()local v=L()D.levelCurrent=0;D.status=string.format("Starting Level %d",D.completedLevels+1)Q(D)d.info(string.format(".Start level %d of %d (%d%%, %d%%)",D.completedLevels+1,v.levels,D.levelCurrent*100,D.current*100))end;local function a0()local D=M()local v=L()D.completedLevels=D.completedLevels+1;D.completedRows=0;D.levelCurrent=1;D.current=D.completedLevels/v.levels;D.status=string.format("Completing Level %d",D.completedLevels-1)Q(D)end;local function a1()local D=M()D.finished=true;D.status="Finishing Job"Q(D)d.info("Finishing Quarry...")sleep(5)J=false;d.info("Items Mined:")local a2=g.itemStrings(D.items)for U,V in ipairs(a2)do d.info(V)end end;local function a3()local a4=N()if a4 then R("Going to Offset")while not h.goTo(a4.v.x,a4.v.z,a4.v.y,a4.dir)do i.error("Cannot Goto Offset")sleep(3)end;h.addNode()end end;local function a5(a6,o,a7,a8,a9)a.expect(1,a6,"number","nil")a.expect(2,o,"boolean","nil")a.expect(3,a7,"boolean","nil")a.expect(4,a8,"boolean","nil")a.expect(5,a9,"boolean","nil")if a6==nil then a6=1 end;if o==nil then o=true end;if a7==nil then a7=false end;if a8==nil then a8=false end;if a9==nil then a9=false end;for aa=1,a6,1 do local ab=turtle.detect()if not i.dig()then return false end;if not turtle.detectDown()and(a9 and o or i.isSourceBlockDown())then i.fillDown(true)end;if o then if a7 then h.turnLeft()i.fill(true)h.turnRight()end;if a8 then h.turnRight()i.fill(true)h.turnLeft()end end;if I~=H.Running then return true end end;return true end;local function ac()local a4=N()h.resetNodes()if a4 then h.addNode(a4)end;h.addNode(G)end;local function ad(Y,a9)R(string.format("Returning to Row %d",Y))d.info(string.format("..Resume start: %s",d.format(G)))local v=L()local ae=false;local af=-1;local ag=1;if G.dir==e.c.Turtle.Direction.Right then ae=true;af=1;ag=1 elseif G.dir==e.c.Turtle.Direction.Back then af=1;ag=-1 elseif G.dir==e.c.Turtle.Direction.Left then ae=true;af=-1;ag=-1 end;local ah=G.v.x;local ai=G.v.z;local aj=Y%2==0;if not aj then local ak=ag*(v.forward-1)d.info(string.format("..Resume: forward %d",v.forward-1))if ae then ah=G.v.x+ak else ai=G.v.z+ak end;while not h.goTo(ah,ai)do i.error("Cannot Resume Level")sleep(3)end end;local al=af*(Y-1)d.info(string.format("..Resume: left %d",Y-1))if ae then while not h.goTo(ah,ai+al,nil,G.dir)do i.error("Cannot Resume Level")sleep(3)end else while not h.goTo(ah+al,ai,nil,G.dir)do i.error("Cannot Resume Level")sleep(3)end end;h.turnLeft()d.info(string.format("..Resume: dig",Y-1))if not a5(1,v.walls,aj,not aj,a9)then return false end;if aj then d.info("..Resume: turn right")h.turnRight()else d.info("..Resume: turn left")h.turnLeft()end;return true end;local function am(an,ao)local v=L()local o=not an and v.walls;h.turnTo(G.dir)_()local P=h.getPos()if P.v.x==0 and P.v.z==0 and P.v.y==0 then a3()if not a5(1,o,v.left==1,true)then return false end;if I~=H.Running then return true end;P=h.getPos()G=c.copy(P)end;local D=M()local ap=P.v.y-G.v.y;if D.completedLevels>0 then for aa=1,D.completedLevels+ap,1 do if not i.digDown()then return false end end end;if o then h.turnRight()i.fill(true)if not an then h.turnRight()i.fill(true)h.turnLeft()end;h.turnLeft()if ao then i.fillDown(true)end end;if D.completedRows>0 then if not ad(D.completedRows,ao)then return false end end;for aq=D.completedRows+1,v.left,1 do ac()local ar=aq%2==0;local as=aq==v.left;local at=v.forward*4+v.forward*3;if not i.hasRequiredFuel(at)then i.refuel(v.fuelPerLevel,false)i.emptyInventory(true)end;X(aq)local a7=as and not ar;local a8=aq==1 or as and ar;if not a5(v.forward-1,o,a7,a8,ao)then return false end;if I~=H.Running then return true end;if o then i.fill(true)end;if aq<v.left then if ar then h.turnRight()else h.turnLeft()end;if not a5(1,o,ar,not ar)then return false end;if I~=H.Running then return true end;if aq+1==v.left and o then i.fill(true)end;if ar then h.turnRight()else h.turnLeft()end;if ao and o then i.fillDown(true)end end;Z()if I~=H.Running then return true end end;D=M()d.info(string.format("..Return to start (%d%%, %d%%)",v.percentPerLevel*100,D.current*100))while not h.goTo(G.v.x,G.v.z,nil,G.dir)do i.error("Cannot Return to Start")sleep(3)end;a0()return true end;local function au(av,aw,ax,ay)a.expect(1,av,"number")a.expect(2,ax,"number")a.expect(3,aw,"number")a.expect(4,ay,"number")a.range(ay,1,4)j.s.offsetPos.set(h.TurtlePosition(vector.new(av,ax,aw),ay))end;local function az()E.offsetPos.set(false)end;local function aA()return j.s.autoResume.get()and not M().finished end;local function aB(l,m,n,o)a.expect(1,l,"number","nil")a.expect(2,m,"number","nil")a.expect(3,n,"number")if l~=nil then a.range(l,1)end;if m~=nil then a.range(m,1)end;a.range(n,1)local v=k(l,m,n,o)j.d.job.set(v)local D=c.copy(j.d.progress.default)D.finished=false;Q(D)end;local function aC()d.info("Discovering Boundary")R("Discovering Boundary")i.refuel(500)local aD=N()a3()R("Discovering Boundary")i.dig()h.turnRight()if not turtle.detect()then while h.forward()do end;h.turnLeft()while h.forward()do end;h.turnRight()i.dig()h.turnRight()h.turnRight()local P=h.getPos()j.setOffset(P.v.x,P.v.z,P.v.y,P.dir)d.info(string.format("Setting new offset: %s",d.format(P)))R(string.format("Set Offset: (%d, %d)",P.v.x,P.v.z))h.forward()h.turnRight()end;local m=1;local l=1;h.turnLeft()while h.forward()do m=m+1 end;h.turnLeft()while h.forward()do l=l+1;local P=h.getPos()if P.v.x==0 and P.v.z==1 then break end end;d.info(string.format("Discovered Boundary: %d %d",l,m))R(string.format("Discovered: %dx%d",l,m))h.resetNodes()if aD then h.addNode(aD)end;h.goToOrigin()h.resetNodes()return l,m end;local function aE()local v=L()if v.left==nil or v.forward==nil then local l,m=aC()aB(l,m,v.levels,v.walls)v=L()a0()h.resetNodes()h.resetNodes(true)end;e.TurtleStartedEvent():send()local P=h.getPos()if P.v.x==0 and P.v.y==0 and P.v.z==0 and P.dir==e.c.Turtle.Direction.Front then i.discoverChests()end;i.emptyInventory()local D=M()local aF=false;while D.completedLevels<v.levels and(I==H.Running or I==H.Paused)do if I==H.Running then if D.completedLevels%v.refuelLevel==0 or not i.hasRequiredFuel(v.fuelPerLevel)then i.refuel(v.refuelTarget,D.completedLevels~=0)end;if not am(D.completedLevels==0,D.completedLevels+1==v.levels)then aF=true;break end;D=M()if I==H.Paused then i.emptyInventory()e.TurtlePausedEvent():send()end else sleep(5)end end;if aF then D=M()j.d.job.set(k(v.left,v.forward,D.completedLevels+1,v.walls))a0()D=M()D.hitBedrock=true;D.status="Hit Bedrock"Q(D)end;i.emptyInventory()if I==H.Halted then e.TurtleExitEvent(false):send()sleep(3)I=H.Completed else e.TurtleExitEvent(true):send()end;a1()end;local function aG()while J do local aH=os.startTimer(3)local T,aI=c.cleanEventArgs(os.pullEvent())if T==e.c.Event.Pathfind.position then local P=h.TurtlePosition.deserialize(nil,aI[1].position)g.updatePosition(e.getComputer(),P)elseif T==e.c.Event.Pathfind.go_to then local aJ=aI[1]if aJ.gotoType==e.c.Turtle.GoTo.Return then if aJ.success==nil then R("Resuming")else local D=M()local v=L()if D.completedRows==v.left then R(string.format("Completed Row %d",D.completedRows))else R(string.format("Digging Row %d",D.completedRows+1))end end end elseif T==e.c.Event.Progress.quarry then g.print(e.getComputer(),aI[1])elseif T==e.c.Event.Turtle.empty then R("Emptying Inventory")if aI[1].completed then S(aI[1])end elseif T==e.c.Event.Turtle.exited then if aI[1].completed then R("success:Completed")I=H.Completed else R("error:Stopped")I=H.Halted end elseif T==e.c.Event.Turtle.request_pause then I=H.Paused;d.info("Pausing...")elseif T==e.c.Event.Turtle.request_halt then I=H.Halted;d.info("Halting...")elseif T==e.c.Event.Turtle.request_continue then I=H.Running;d.info("Unpausing...")e.TurtleStartedEvent():send()elseif T==e.c.Event.Turtle.paused then R("warning:Paused")elseif T==e.c.Event.Turtle.fetch_fill then R("Getting Fill Block")elseif T==e.c.Event.Turtle.refuel then R("Refueling")elseif T==e.c.Event.Turtle.error then local D=M()K=D.status;R(string.format("error:%s",aI[1].error))elseif T==e.c.Event.Turtle.error_clear then if K~=nil then R(K)K=nil end end;g.handle(e.getComputer(),T,aI)os.cancelTimer(aH)end end;local function aK()e.initNetwork()if not e.online then return end;while J do local aL=e.receive()if aL~=nil then local aM=os.getComputerID()if aL.name==e.c.Event.Turtle.request_halt and aL.event.id==aM then I=H.Halted;d.info("Halting...")elseif aL.name==e.c.Event.Turtle.request_pause and aL.event.id==aM then I=H.Paused;d.info("Pausing...")elseif aL.name==e.c.Event.Turtle.request_continue and aL.event.id==aM then I=H.Running;d.info("Unpausing...")e.TurtleStartedEvent():send()end end end end;local function aN(aO)a.expect(1,aO,"boolean","nil")if aO==nil then aO=false end;d.s.print.set(false)e.initNetwork()local v=L()term.clear()term.setCursorPos(1,1)if not d.s.print.get()then g.print(e.getComputer(),e.QuarryProgressEvent(h.getPos(),v,M()))end;local aP=""if v.left~=nil and v.forward~=nil then aP=string.format(": %d x %d (%d)",v.left,v.forward,v.levels)end;if aO then d.info(string.format("Resume Quarry%s",aP))R("Resuming")else d.info(string.format("Quarry%s",aP))end;parallel.waitForAll(aE,aG,aK)term.setCursorBlink(true)if not d.s.print.get()then term.setBackgroundColor(colors.black)term.setTextColor(colors.white)term.clear()term.setCursorPos(1,1)end;d.s.print.set(true)end;j.setOffset=au;j.clearOffset=az;j.canResume=aA;j.setJob=aB;j.runJob=aN;return j
