local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui.base").BaseObject;local c=require("am.ui")local d=require("am.event")local e=require("am.log")local f=require("am.core")local g=require("am.progress.helpers")local h=require("am.progress.quarry")local i=require("am.progress.colonies")local j={}local k={}local function l(m,n,o)a.expect(1,m,"table")a.expect(2,o,"table","nil")a.expect(3,n,"table","nil")local p=o~=nil and n~=nil;if o~=nil then c.h.requireOutput(o)end;local q=k[m.id]local r=false;if p then if q~=nil then if q.progress.name~=n.name or not c.h.isSameScreen(q.screen.output,o)then k[m.id]=nil;q=nil end end;if q==nil then r=true;if n.name==d.c.Event.Progress.quarry then q=h(m,n,o)q:createUI()k[m.id]=q elseif n.name==d.c.Event.Colonies.status_poll then q=i(m,n.status.id,o)q.status=n.status;q:createUI()k[m.id]=q end end end;return q,r end;local function s(o)for t,q in pairs(k)do if c.h.isSameScreen(o,q.screen.output)then return{id=t}end end;return nil end;local function u(m,v)a.expect(1,m,"table")a.expect(2,v,"string")local q=l(m)if q~=nil then q:updateStatus(v)end end;local function w(m,n,o)a.expect(1,m,"table")a.expect(2,n,"table")a.expect(3,o,"table","nil")if o==nil then o=term else c.h.requireOutput(o)end;local q,r=l(m,n,o)if q~=nil and not r then q:update(n)end end;local function x(n,y)for z,q in pairs(k)do q:handle(n,y)end end;local function A(m,n,y)local B=nil;if c.c.l.Events.Always[n]then x(n,y)return elseif c.c.l.Events.UI[n]then local C=f.split(y[1].objId,".")if C[1]=="screen"then B={id=tonumber(C[2])}end elseif c.c.l.Events.Terminal[n]then B=s(term)elseif c.c.l.Events.Monitor[n]then B=s(peripheral.wrap(y[1]))end;if B~=nil then m=B end;local q,z=l(m)if q~=nil then q:handle(n,y)end end;j.updateStatus=u;j.print=w;j.handle=A;j.itemStrings=g.itemStrings;return j
