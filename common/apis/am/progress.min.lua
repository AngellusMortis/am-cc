local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui")local c=require("am.event")local d=require("am.core")local e=require("am.progress.helpers")local f=require("am.progress.quarry")local g=require("am.progress.tree")local h=require("am.progress.colonies")local i={}local j={}local function k(l,m,n)a.expect(1,l,"table")a.expect(2,n,"table","nil")a.expect(3,m,"table","nil")local o=n~=nil and m~=nil;if n~=nil then b.h.requireOutput(n)end;local p=j[l.id]local q=false;if o then if p~=nil then if not p.names[m.name]or not b.h.isSameScreen(p.screen.output,n)then j[l.id]=nil;p=nil end end;if p==nil then if m.name==c.c.Event.Progress.quarry then p=f(l,m,n)p:createUI()j[l.id]=p elseif m.name==c.c.Event.Progress.tree then p=g(l,m,n)p:createUI()j[l.id]=p elseif m.name==c.c.Event.Colonies.status_poll then p=h(l,m.status.id,n)p.progress.status=m.status;p:createUI()j[l.id]=p end;q=p~=nil end end;return p,q end;local function r(n)for s,p in pairs(j)do if b.h.isSameScreen(n,p.screen.output)then return{id=s}end end;return nil end;local function t(l,u)a.expect(1,l,"table")a.expect(2,u,"string")local p=k(l)if p~=nil then p:updateStatus(u)end end;local function v(l,m,n)a.expect(1,l,"table")a.expect(2,m,"table")a.expect(3,n,"table","nil")if n==nil then n=term else b.h.requireOutput(n)end;local p,q=k(l,m,n)if p~=nil and not q then p:update(m)end end;local function w(m,x)for y,p in pairs(j)do p:handle(m,x)end end;local function z(l,m,x)local A=nil;if b.c.l.Events.Always[m]then w(m,x)return elseif b.c.l.Events.UI[m]then local B=d.split(x[1].objId,".")if B[1]=="screen"then A={id=tonumber(B[2])}end elseif b.c.l.Events.Terminal[m]then A=r(term)elseif b.c.l.Events.Monitor[m]then A=r(peripheral.wrap(x[1]))end;if A~=nil then l=A end;local p,y=k(l)if p~=nil then p:handle(m,x)end end;i.updateStatus=t;i.print=v;i.handle=z;i.itemStrings=e.itemStrings;return i
