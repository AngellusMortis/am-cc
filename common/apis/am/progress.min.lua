local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui")local c=require("am.event")local d=require("am.core")local e=require("am.progress.helpers")local f=require("am.progress.quarry")local g=require("am.progress.colonies")local h={}local i={}local function j(k,l,m)a.expect(1,k,"table")a.expect(2,m,"table","nil")a.expect(3,l,"table","nil")local n=m~=nil and l~=nil;if m~=nil then b.h.requireOutput(m)end;local o=i[k.id]local p=false;if n then if o~=nil then if not o.names[l.name]or not b.h.isSameScreen(o.screen.output,m)then i[k.id]=nil;o=nil end end;if o==nil then if l.name==c.c.Event.Progress.quarry then o=f(k,l,m)o:createUI()i[k.id]=o elseif l.name==c.c.Event.Colonies.status_poll then o=g(k,l.status.id,m)o.progress.status=l.status;o:createUI()i[k.id]=o end;p=o~=nil end end;return o,p end;local function q(m)for r,o in pairs(i)do if b.h.isSameScreen(m,o.screen.output)then return{id=r}end end;return nil end;local function s(k,t)a.expect(1,k,"table")a.expect(2,t,"string")local o=j(k)if o~=nil then o:updateStatus(t)end end;local function u(k,l,m)a.expect(1,k,"table")a.expect(2,l,"table")a.expect(3,m,"table","nil")if m==nil then m=term else b.h.requireOutput(m)end;local o,p=j(k,l,m)if o~=nil and not p then o:update(l)end end;local function v(l,w)for x,o in pairs(i)do o:handle(l,w)end end;local function y(k,l,w)local z=nil;if b.c.l.Events.Always[l]then v(l,w)return elseif b.c.l.Events.UI[l]then local A=d.split(w[1].objId,".")if A[1]=="screen"then z={id=tonumber(A[2])}end elseif b.c.l.Events.Terminal[l]then z=q(term)elseif b.c.l.Events.Monitor[l]then z=q(peripheral.wrap(w[1]))end;if z~=nil then k=z end;local o,x=j(k)if o~=nil then o:handle(l,w)end end;h.updateStatus=s;h.print=u;h.handle=y;h.itemStrings=e.itemStrings;return h
