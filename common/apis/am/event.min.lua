local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").e.BaseEvent;local c=require("am.helpers")local d=require("am.log")local e={}local f=false;e.online=false;e.type="am.net"local function g()if f then return end;e.online=false;local h={peripheral.find("modem",function(i,j)return j.isWireless()end)}if#h>0 then rednet.open(peripheral.getName(h[1]))e.online=true end;f=true end;local function k()return{id=os.getComputerID(),label=os.computerLabel()}end;e.c={}e.c.Turtle={}e.c.Turtle.Direction={Up=-1,Down=0,Front=1,Right=2,Back=3,Left=4}e.c.Turtle.GoTo={Node=0,Origin=1,Return=2}e.broadcastMap={["am.progress_quarry"]=true,["am.pathfind_position"]=false,["am.pathfind_node"]=false,["am.pathfind_reset_nodes"]=false,["am.pathfind_reset"]=false,["am.pathfind_turn"]=false,["am.pathfind_go_to"]=false,["am.turtle_started"]=false,["am.turtle_paused"]=false,["am.turtle_exited"]=false,["am.turtle_request_halt"]=false,["am.turtle_request_pause"]=false,["am.turtle_request_continue"]=false,["am.turtle_empty"]=false,["am.turtle_fetch_fill"]=false,["am.turtle_refuel"]=false,["am.turtle_dig"]=false,["am.turtle_error"]=false}e.c.Lookup={}e.c.Lookup.Progress={["am.progress_quarry"]=true}e.c.Event={}e.c.Event.Progress={quarry="am.progress_quarry"}e.c.Event.Pathfind={position="am.pathfind_position",node="am.pathfind_node",reset_nodes="am.pathfind_reset_nodes",reset="am.pathfind_reset",turn="am.pathfind_turn",go_to="am.pathfind_go_to"}e.c.Event.Turtle={started="am.turtle_started",paused="am.turtle_paused",exited="am.turtle_exited",request_halt="am.turtle_request_halt",request_pause="am.turtle_request_pause",request_continue="am.turtle_request_continue",empty="am.turtle_empty",fetch_fill="am.turtle_fetch_fill",refuel="am.turtle_refuel",dig="am.turtle_dig",error="am.turtle_error"}local l=b:extend("am.e.DistributedEvent")e.DistributedEvent=l;function l:init(i)a.expect(1,i,"string")l.super.init(self,i)return self end;function l:validate(m)return true end;function l:sign()return""end;function l:send()os.queueEvent(self.name,self)if e.broadcastMap[self.name]then g()if e.online then d.debug(string.format("broadcast %s",self.name))rednet.broadcast({type=e.type,src=k(),name=self.name,event=self,signature=self:sign()})end end end;local n=l:extend("am.e.ProgressEvent")e.ProgressEvent=n;function n:init(i)a.expect(1,i,"string")n.super.init(self,i)return self end;local o=n:extend("am.e.QuarryProgressEvent")e.QuarryProgressEvent=o;function o:init(p,q,r)a.expect(1,p,"table")a.expect(2,q,"table")a.expect(3,r,"table")c.requirePosition(1,p)o.super.init(self,e.c.Event.Progress.quarry)self.pos=p;self.job=q;self.progress=r;return self end;local s=l:extend("am.e.PathfindEvent")e.PathfindEvent=s;function s:init(i)a.expect(1,i,"string")s.super.init(self,i)return self end;local t=s:extend("am.e.PositionUpdateEvent")e.PositionUpdateEvent=t;function t:init(u)a.expect(1,u,"table")c.requirePosition(1,u)t.super.init(self,e.c.Event.Pathfind.position)self.position=u;return self end;local v=s:extend("am.e.ResetPathfindEvent")e.ResetPathfindEvent=v;function v:init()v.super.init(self,e.c.Event.Pathfind.reset)return self end;local w=s:extend("am.e.NewNodeEvent")e.NewNodeEvent=w;function w:init(u,x)a.expect(1,u,"table")a.expect(1,x,"boolean","nil")c.requirePosition(1,u)w.super.init(self,e.c.Event.Pathfind.node)if x==nil then x=false end;self.position=u;self.isReturn=x;return self end;local y=s:extend("am.e.ResetNodesEvent")e.ResetNodesEvent=y;function y:init(x)a.expect(1,x,"boolean","nil")y.super.init(self,e.c.Event.Pathfind.reset_nodes)if x==nil then x=false end;self.isReturn=x;return self end;local z=s:extend("am.e.FailableTurtleEvent")e.FailableTurtleEvent=z;function z:init(i,A)a.expect(1,i,"string")a.expect(2,A,"boolean","nil")z.super.init(self,i)self.success=A;return self end;local B=z:extend("am.e.PathfindTurnEvent")e.PathfindTurnEvent=B;function B:init(C,A)a.expect(1,C,"number")a.expect(2,A,"boolean","nil")a.range(C,1,4)z.super.init(self,e.c.Event.Pathfind.turn,A)self.dir=C;return self end;local D=z:extend("am.e.PathfindGoToEvent")e.PathfindGoToEvent=D;function D:init(E,F,G,A)a.expect(1,E,"table")a.expect(2,F,"table")a.expect(3,G,"number")a.expect(4,A,"boolean","nil")c.requirePosition(1,E)c.requirePosition(2,F)a.range(G,0,2)D.super.init(self,e.c.Event.Pathfind.go_to,A)self.destPos=E;self.startPos=F;self.gotoType=G;return self end;local H=l:extend("am.e.TurtleEvent")e.TurtleEvent=H;function H:init(i)a.expect(1,i,"string")H.super.init(self,i)return self end;local I=H:extend("am.e.TurtleStartedEvent")e.TurtleStartedEvent=I;function I:init()I.super.init(self,e.c.Event.Turtle.started)return self end;local J=H:extend("am.e.TurtlePausedEvent")e.TurtlePausedEvent=J;function J:init()J.super.init(self,e.c.Event.Turtle.paused)return self end;local K=H:extend("am.e.TurtleExitEvent")e.TurtleExitEvent=K;function K:init(L)a.expect(1,L,"boolean")K.super.init(self,e.c.Event.Turtle.exited)self.completed=L;return self end;local M=H:extend("am.e.TurtleRequestHaltEvent")e.TurtleRequestHaltEvent=M;function M:init(N)M.super.init(self,e.c.Event.Turtle.request_halt)self.id=N;return self end;local O=H:extend("am.e.TurtleRequestPauseEvent")e.TurtleRequestPauseEvent=O;function O:init(N)O.super.init(self,e.c.Event.Turtle.request_pause)self.id=N;return self end;local P=H:extend("am.e.TurtleRequestHaltEvent")e.TurtleRequestContinueEvent=P;function P:init(N)P.super.init(self,e.c.Event.Turtle.request_continue)self.id=N;return self end;local Q=H:extend("am.e.TurtleErrorEvent")e.TurtleErrorEvent=Q;function Q:init(error)a.expect(1,error,"string")Q.super.init(self,e.c.Event.Turtle.error)self.error=error;return self end;local R=H:extend("am.e.TurtleCompletableEvent")e.TurtleCompletableEvent=R;function R:init(i,L)a.expect(1,i,"string")a.expect(2,L,"boolean")R.super.init(self,i)self.completed=L;return self end;local S=R:extend("am.e.TurtleEmptyEvent")e.TurtleEmptyEvent=S;function S:init(L,T)a.expect(1,L,"boolean")a.expect(2,T,"table","nil")if L and T==nil then error("Must include items if is complete")end;S.super.init(self,e.c.Event.Turtle.empty,L)self.items=T;return self end;local U=R:extend("am.e.TurtleFetchFillEvent")e.TurtleFetchFillEvent=U;function U:init(L,V)a.expect(1,L,"boolean")a.expect(2,V,"table","nil")if L and V==nil then error("Must include item if is complete")end;U.super.init(self,e.c.Event.Turtle.fetch_fill,L)self.item=V;return self end;local W=R:extend("am.e.TurtleRefuelEvent")e.TurtleRefuelEvent=W;function W:init(L,X,Y,Z)a.expect(1,L,"boolean")a.expect(2,X,"number","nil")a.expect(3,Y,"number","nil")a.expect(4,Z,"number","nil")if L and(Y==nil or Z==nil)then error("Must include levels if is complete")end;W.super.init(self,e.c.Event.Turtle.refuel,L)self.requested=X;self.oldLevel=Y;self.newLevel=Z;return self end;local _=R:extend("am.e.TurtleDigEvent")e.TurtleDigEvent=_;function _:init(L,a0,a1)a.expect(1,L,"boolean")a.expect(2,a0,"number")a.expect(3,a1,"number")a.range(a0,-1,1)_.super.init(self,e.c.Event.Turtle.dig,L)self.moveDir=a0;self.count=a1;return self end;e.initNetwork=g;e.getComputer=k;return e
