local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").e.BaseEvent;local c=require("am.helpers")local d=require("am.core")local e=require("ext.hmac")local f=require("am.log")local g={}local h={}h.signing={name="event.signing",default=false,type="boolean"}h.psk={name="event.psk",default="",type="string"}h=d.makeSettingWrapper(h)local i=false;g.online=false;g.type="am.net"local function j()if i then return end;if not h.signing.get()or h.psk.get()~=""then g.online=false;local k={peripheral.find("modem",function(l,m)return m.isWireless()end)}if#k>0 then rednet.open(peripheral.getName(k[1]))g.online=true end end;i=true end;local function n()return{id=os.getComputerID(),label=os.computerLabel()}end;local function o()if not g.online then return nil end;local p,q=rednet.receive(nil,3)if q~=nil and q.type==g.type then if g.DistributedEvent.validate(nil,d.copy(q,false))then return q else f.debug(string.format("bad signature: %s",f.format(q)))end end;return nil end;g.c={}g.c.Turtle={}g.c.Turtle.Direction={Up=-1,Down=0,Front=1,Right=2,Back=3,Left=4}g.c.Turtle.GoTo={Node=0,Origin=1,Return=2}g.c.RunType={Running=1,Completed=2,Paused=3,Halted=4}g.broadcastMap={["am.progress_quarry"]=true,["am.progress_tree"]=true,["am.pathfind_position"]=false,["am.pathfind_node"]=false,["am.pathfind_reset_nodes"]=false,["am.pathfind_reset"]=false,["am.pathfind_turn"]=false,["am.pathfind_go_to"]=false,["am.turtle_started"]=true,["am.turtle_paused"]=true,["am.turtle_exited"]=true,["am.turtle_request_halt"]=true,["am.turtle_request_pause"]=true,["am.turtle_request_continue"]=true,["am.turtle_empty"]=false,["am.turtle_fetch_fill"]=false,["am.turtle_refuel"]=false,["am.turtle_dig"]=false,["am.turtle_error"]=false,["am.turtle_error_clear"]=false,["am.colonies_warehouse_poll"]=true,["am.colonies_status_poll"]=true}g.c.Lookup={}g.c.Lookup.Progress={["am.progress_quarry"]=true,["am.progress_tree"]=true,["am.colonies_status_poll"]=true}g.c.Event={}g.c.Event.Progress={quarry="am.progress_quarry",tree="am.progress_tree"}g.c.Event.Pathfind={position="am.pathfind_position",node="am.pathfind_node",reset_nodes="am.pathfind_reset_nodes",reset="am.pathfind_reset",turn="am.pathfind_turn",go_to="am.pathfind_go_to"}g.c.Event.Turtle={started="am.turtle_started",paused="am.turtle_paused",exited="am.turtle_exited",request_halt="am.turtle_request_halt",request_pause="am.turtle_request_pause",request_continue="am.turtle_request_continue",empty="am.turtle_empty",fetch_fill="am.turtle_fetch_fill",refuel="am.turtle_refuel",dig="am.turtle_dig",error="am.turtle_error",error_clear="am.turtle_error_clear"}g.c.Event.Colonies={warehouse_poll="am.colonies_warehouse_poll",status_poll="am.colonies_status_poll"}local r=b:extend("am.e.DistributedEvent")g.DistributedEvent=r;function r:init(l)a.expect(1,l,"string")r.super.init(self,l)return self end;function r:validate(s)if not h.signing.get()and s.signature==nil then return true end;if not g.online or s.signature==nil then return false end;local t=s.signature;s.signature=nil;local u=e.hmac(e.sha256,h.psk.get(),f.format(s))return t==u end;function r:sign(s)if not h.signing.get()then return s end;local v=e.hmac(e.sha256,h.psk.get(),f.format(s))s.signature=v;return s end;function r:send()os.queueEvent(self.name,self)if g.broadcastMap[self.name]then j()if g.online then rednet.broadcast(self:sign({type=g.type,src=n(),name=self.name,event=d.copy(self,false)}))end end end;local w=r:extend("am.e.ProgressEvent")g.ProgressEvent=w;function w:init(l)a.expect(1,l,"string")w.super.init(self,l)return self end;local x=w:extend("am.e.TreeProgressEvent")g.TreeProgressEvent=x;function x:init(y,z,A,B)a.expect(1,y,"table")a.expect(2,z,"table")a.expect(3,A,"string")a.expect(4,B,"number")c.requirePosition(1,y)x.super.init(self,g.c.Event.Progress.tree)self.pos=y;self.trees=z;self.status=A;self.rate=B;return self end;local C=w:extend("am.e.QuarryProgressEvent")g.QuarryProgressEvent=C;function C:init(y,D,E)a.expect(1,y,"table")a.expect(2,D,"table")a.expect(3,E,"table")c.requirePosition(1,y)C.super.init(self,g.c.Event.Progress.quarry)self.pos=y;self.job=D;self.progress=E;return self end;local F=r:extend("am.e.PathfindEvent")g.PathfindEvent=F;function F:init(l)a.expect(1,l,"string")F.super.init(self,l)return self end;local G=F:extend("am.e.PositionUpdateEvent")g.PositionUpdateEvent=G;function G:init(H)a.expect(1,H,"table")c.requirePosition(1,H)G.super.init(self,g.c.Event.Pathfind.position)self.position=H;return self end;local I=F:extend("am.e.ResetPathfindEvent")g.ResetPathfindEvent=I;function I:init()I.super.init(self,g.c.Event.Pathfind.reset)return self end;local J=F:extend("am.e.NewNodeEvent")g.NewNodeEvent=J;function J:init(H,K)a.expect(1,H,"table")a.expect(1,K,"boolean","nil")c.requirePosition(1,H)J.super.init(self,g.c.Event.Pathfind.node)if K==nil then K=false end;self.position=H;self.isReturn=K;return self end;local L=F:extend("am.e.ResetNodesEvent")g.ResetNodesEvent=L;function L:init(K)a.expect(1,K,"boolean","nil")L.super.init(self,g.c.Event.Pathfind.reset_nodes)if K==nil then K=false end;self.isReturn=K;return self end;local M=F:extend("am.e.FailableTurtleEvent")g.FailableTurtleEvent=M;function M:init(l,N)a.expect(1,l,"string")a.expect(2,N,"boolean","nil")M.super.init(self,l)self.success=N;return self end;local O=M:extend("am.e.PathfindTurnEvent")g.PathfindTurnEvent=O;function O:init(P,N)a.expect(1,P,"number")a.expect(2,N,"boolean","nil")a.range(P,1,4)M.super.init(self,g.c.Event.Pathfind.turn,N)self.dir=P;return self end;local Q=M:extend("am.e.PathfindGoToEvent")g.PathfindGoToEvent=Q;function Q:init(R,S,T,N)a.expect(1,R,"table")a.expect(2,S,"table")a.expect(3,T,"number")a.expect(4,N,"boolean","nil")c.requirePosition(1,R)c.requirePosition(2,S)a.range(T,0,2)Q.super.init(self,g.c.Event.Pathfind.go_to,N)self.destPos=R;self.startPos=S;self.gotoType=T;return self end;local U=r:extend("am.e.TurtleEvent")g.TurtleEvent=U;function U:init(l)a.expect(1,l,"string")U.super.init(self,l)return self end;local V=U:extend("am.e.TurtleStartedEvent")g.TurtleStartedEvent=V;function V:init()V.super.init(self,g.c.Event.Turtle.started)return self end;local W=U:extend("am.e.TurtlePausedEvent")g.TurtlePausedEvent=W;function W:init()W.super.init(self,g.c.Event.Turtle.paused)return self end;local X=U:extend("am.e.TurtleExitEvent")g.TurtleExitEvent=X;function X:init(Y)a.expect(1,Y,"boolean")X.super.init(self,g.c.Event.Turtle.exited)self.completed=Y;return self end;local Z=U:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestHaltEvent=Z;function Z:init(_)Z.super.init(self,g.c.Event.Turtle.request_halt)self.id=_;return self end;local a0=U:extend("am.e.TurtleRequestPauseEvent")g.TurtleRequestPauseEvent=a0;function a0:init(_)a0.super.init(self,g.c.Event.Turtle.request_pause)self.id=_;return self end;local a1=U:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestContinueEvent=a1;function a1:init(_)a1.super.init(self,g.c.Event.Turtle.request_continue)self.id=_;return self end;local a2=U:extend("am.e.TurtleErrorEvent")g.TurtleErrorEvent=a2;function a2:init(a3)a.expect(1,a3,"string")a2.super.init(self,g.c.Event.Turtle.error)self.error=a3;return self end;local a4=U:extend("am.e.TurtleErrorClearEvent")g.TurtleErrorClearEvent=a4;function a4:init()a4.super.init(self,g.c.Event.Turtle.error_clear)return self end;local a5=U:extend("am.e.TurtleCompletableEvent")g.TurtleCompletableEvent=a5;function a5:init(l,Y)a.expect(1,l,"string")a.expect(2,Y,"boolean")a5.super.init(self,l)self.completed=Y;return self end;local a6=a5:extend("am.e.TurtleEmptyEvent")g.TurtleEmptyEvent=a6;function a6:init(Y,a7)a.expect(1,Y,"boolean")a.expect(2,a7,"table","nil")if Y and a7==nil then error("Must include items if is complete")end;a6.super.init(self,g.c.Event.Turtle.empty,Y)self.items=a7;return self end;local a8=a5:extend("am.e.TurtleFetchFillEvent")g.TurtleFetchFillEvent=a8;function a8:init(Y,a9)a.expect(1,Y,"boolean")a.expect(2,a9,"table","nil")if Y and a9==nil then error("Must include item if is complete")end;a8.super.init(self,g.c.Event.Turtle.fetch_fill,Y)self.item=a9;return self end;local aa=a5:extend("am.e.TurtleRefuelEvent")g.TurtleRefuelEvent=aa;function aa:init(Y,ab,ac,ad)a.expect(1,Y,"boolean")a.expect(2,ab,"number","nil")a.expect(3,ac,"number","nil")a.expect(4,ad,"number","nil")if Y and(ac==nil or ad==nil)then error("Must include levels if is complete")end;aa.super.init(self,g.c.Event.Turtle.refuel,Y)self.requested=ab;self.oldLevel=ac;self.newLevel=ad;return self end;local ae=a5:extend("am.e.TurtleDigEvent")g.TurtleDigEvent=ae;function ae:init(Y,af,ag)a.expect(1,Y,"boolean")a.expect(2,af,"number")a.expect(3,ag,"number")a.range(af,-1,1)ae.super.init(self,g.c.Event.Turtle.dig,Y)self.moveDir=af;self.count=ag;return self end;local ah=r:extend("am.e.ColoniesEvent")g.ColoniesEvent=ah;function ah:init(l)a.expect(1,l,"string")ah.super.init(self,l)return self end;local ai=ah:extend("am.e.TurtleEmptyEvent")g.ColonyStatusPollEvent=ai;function ai:init(A)a.expect(1,A,"table")ai.super.init(self,g.c.Event.Colonies.status_poll)self.status=A;return self end;g.initNetwork=j;g.getComputer=n;g.receive=o;return g
