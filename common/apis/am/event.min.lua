local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").e.BaseEvent;local c=require("am.helpers")local d={}local e=false;d.online=false;d.type="am.net"local function f()if e then return end;d.online=false;local g={peripheral.find("modem",function(h,i)return i.isWireless()end)}if#g>0 then rednet.open(peripheral.getName(g[1]))d.online=true end;e=true end;local function j()return{id=os.getComputerID(),label=os.computerLabel()}end;d.c={}d.c.Turtle={}d.c.Turtle.Direction={Up=-1,Down=0,Front=1,Right=2,Back=3,Left=4}d.c.Turtle.GoTo={Node=0,Origin=1,Return=2}d.broadcastMap={["am.progress_quarry"]=true,["am.pathfind_position"]=false,["am.pathfind_node"]=false,["am.pathfind_reset_nodes"]=false,["am.pathfind_reset"]=false,["am.pathfind_turn"]=false,["am.pathfind_go_to"]=false,["am.turtle_started"]=false,["am.turtle_paused"]=false,["am.turtle_exited"]=false,["am.turtle_request_halt"]=false,["am.turtle_request_pause"]=false,["am.turtle_request_continue"]=false,["am.turtle_empty"]=false,["am.turtle_fetch_fill"]=false,["am.turtle_refuel"]=false,["am.turtle_dig"]=false,["am.turtle_error"]=false}d.c.Event={}d.c.Event.Progress={quarry="am.progress_quarry"}d.c.Event.Pathfind={position="am.pathfind_position",node="am.pathfind_node",reset_nodes="am.pathfind_reset_nodes",reset="am.pathfind_reset",turn="am.pathfind_turn",go_to="am.pathfind_go_to"}d.c.Event.Turtle={started="am.turtle_started",paused="am.turtle_paused",exited="am.turtle_exited",request_halt="am.turtle_request_halt",request_pause="am.turtle_request_pause",request_continue="am.turtle_request_continue",empty="am.turtle_empty",fetch_fill="am.turtle_fetch_fill",refuel="am.turtle_refuel",dig="am.turtle_dig",error="am.turtle_error"}local k=b:extend("am.e.DistributedEvent")d.DistributedEvent=k;function k:init(h)a.expect(1,h,"string")k.super.init(self,h)return self end;function k:validate(l)return true end;function k:sign()return""end;function k:send()os.queueEvent(self.name,self)if d.broadcastMap[self.name]then f()if d.online then rednet.broadcast({type=d.type,src=j(),name=self.name,event=self,signature=self:sign()})end end end;local m=k:extend("am.e.ProgressEvent")d.ProgressEvent=m;function m:init(h)a.expect(1,h,"string")m.super.init(self,h)return self end;local n=m:extend("am.e.QuarryProgressEvent")d.QuarryProgressEvent=n;function n:init(o,p,q)a.expect(1,o,"table")a.expect(2,p,"table")a.expect(3,q,"table")c.requirePosition(1,o)n.super.init(self,d.c.Event.Progress.quarry)self.pos=o;self.job=p;self.progress=q;return self end;local r=k:extend("am.e.PathfindEvent")d.PathfindEvent=r;function r:init(h)a.expect(1,h,"string")r.super.init(self,h)return self end;local s=r:extend("am.e.PositionUpdateEvent")d.PositionUpdateEvent=s;function s:init(t)a.expect(1,t,"table")c.requirePosition(1,t)s.super.init(self,d.c.Event.Pathfind.position)self.position=t;return self end;local u=r:extend("am.e.ResetPathfindEvent")d.ResetPathfindEvent=u;function u:init()u.super.init(self,d.c.Event.Pathfind.reset)return self end;local v=r:extend("am.e.NewNodeEvent")d.NewNodeEvent=v;function v:init(t,w)a.expect(1,t,"table")a.expect(1,w,"boolean","nil")c.requirePosition(1,t)v.super.init(self,d.c.Event.Pathfind.node)if w==nil then w=false end;self.position=t;self.isReturn=w;return self end;local x=r:extend("am.e.ResetNodesEvent")d.ResetNodesEvent=x;function x:init(w)a.expect(1,w,"boolean","nil")x.super.init(self,d.c.Event.Pathfind.reset_nodes)if w==nil then w=false end;self.isReturn=w;return self end;local y=r:extend("am.e.FailableTurtleEvent")d.FailableTurtleEvent=y;function y:init(h,z)a.expect(1,h,"string")a.expect(2,z,"boolean","nil")y.super.init(self,h)self.success=z;return self end;local A=y:extend("am.e.PathfindTurnEvent")d.PathfindTurnEvent=A;function A:init(B,z)a.expect(1,B,"number")a.expect(2,z,"boolean","nil")a.range(B,1,4)y.super.init(self,d.c.Event.Pathfind.turn,z)self.dir=B;return self end;local C=y:extend("am.e.PathfindGoToEvent")d.PathfindGoToEvent=C;function C:init(D,E,F,z)a.expect(1,D,"table")a.expect(2,E,"table")a.expect(3,F,"number")a.expect(4,z,"boolean","nil")c.requirePosition(1,D)c.requirePosition(2,E)a.range(F,0,2)C.super.init(self,d.c.Event.Pathfind.go_to,z)self.destPos=D;self.startPos=E;self.gotoType=F;return self end;local G=k:extend("am.e.TurtleEvent")d.TurtleEvent=G;function G:init(h)a.expect(1,h,"string")G.super.init(self,h)return self end;local H=G:extend("am.e.TurtleStartedEvent")d.TurtleStartedEvent=H;function H:init()H.super.init(self,d.c.Event.Turtle.started)return self end;local I=G:extend("am.e.TurtlePausedEvent")d.TurtlePausedEvent=I;function I:init()I.super.init(self,d.c.Event.Turtle.paused)return self end;local J=G:extend("am.e.TurtleExitEvent")d.TurtleExitEvent=J;function J:init(K)a.expect(1,K,"boolean")J.super.init(self,d.c.Event.Turtle.exited)self.completed=K;return self end;local L=G:extend("am.e.TurtleRequestHaltEvent")d.TurtleRequestHaltEvent=L;function L:init()L.super.init(self,d.c.Event.Turtle.request_halt)return self end;local M=G:extend("am.e.TurtleRequestPauseEvent")d.TurtleRequestPauseEvent=M;function M:init()M.super.init(self,d.c.Event.Turtle.request_pause)return self end;local N=G:extend("am.e.TurtleRequestHaltEvent")d.TurtleRequestContinueEvent=N;function N:init()N.super.init(self,d.c.Event.Turtle.request_continue)return self end;local O=G:extend("am.e.TurtleErrorEvent")d.TurtleErrorEvent=O;function O:init(error)a.expect(1,error,"string")O.super.init(self,d.c.Event.Turtle.error)self.error=error;return self end;local P=G:extend("am.e.TurtleCompletableEvent")d.TurtleCompletableEvent=P;function P:init(h,K)a.expect(1,h,"string")a.expect(2,K,"boolean")P.super.init(self,h)self.completed=K;return self end;local Q=P:extend("am.e.TurtleEmptyEvent")d.TurtleEmptyEvent=Q;function Q:init(K,R)a.expect(1,K,"boolean")a.expect(2,R,"table","nil")if K and R==nil then error("Must include items if is complete")end;Q.super.init(self,d.c.Event.Turtle.empty,K)self.items=R;return self end;local S=P:extend("am.e.TurtleFetchFillEvent")d.TurtleFetchFillEvent=S;function S:init(K,T)a.expect(1,K,"boolean")a.expect(2,T,"table","nil")if K and T==nil then error("Must include item if is complete")end;S.super.init(self,d.c.Event.Turtle.fetch_fill,K)self.item=T;return self end;local U=P:extend("am.e.TurtleRefuelEvent")d.TurtleRefuelEvent=U;function U:init(K,V,W,X)a.expect(1,K,"boolean")a.expect(2,V,"number","nil")a.expect(3,W,"number","nil")a.expect(4,X,"number","nil")if K and(W==nil or X==nil)then error("Must include levels if is complete")end;U.super.init(self,d.c.Event.Turtle.refuel,K)self.requested=V;self.oldLevel=W;self.newLevel=X;return self end;local Y=P:extend("am.e.TurtleDigEvent")d.TurtleDigEvent=Y;function Y:init(K,Z,_)a.expect(1,K,"boolean")a.expect(2,Z,"number")a.expect(3,_,"number")a.range(Z,-1,1)Y.super.init(self,d.c.Event.Turtle.dig,K)self.moveDir=Z;self.count=_;return self end;d.initNetwork=f;d.getComputer=j;return d
