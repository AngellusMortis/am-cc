local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").e.BaseEvent;local c=require("am.helpers")local d=require("am.core")local e=require("ext.hmac")local f=require("am.log")local g={}local h={}h.signing={name="event.signing",default=false,type="boolean"}h.psk={name="event.psk",default="",type="string"}h=d.makeSettingWrapper(h)local i=false;g.online=false;g.type="am.net"local function j()if i then return end;if not h.signing.get()or h.psk.get()~=""then g.online=false;local k={peripheral.find("modem",function(l,m)return m.isWireless()end)}if#k>0 then rednet.open(peripheral.getName(k[1]))g.online=true end end;i=true end;local function n()return{id=os.getComputerID(),label=os.computerLabel()}end;local function o()if not g.online then return nil end;local p,q=rednet.receive(nil,3)if q~=nil and q.type==g.type then if g.DistributedEvent.validate(nil,d.copy(q,false))then return q else f.debug(string.format("bad signature: %s",f.format(q)))end end;return nil end;g.c={}g.c.Turtle={}g.c.Turtle.Direction={Up=-1,Down=0,Front=1,Right=2,Back=3,Left=4}g.c.Turtle.GoTo={Node=0,Origin=1,Return=2}g.broadcastMap={["am.progress_quarry"]=true,["am.pathfind_position"]=false,["am.pathfind_node"]=false,["am.pathfind_reset_nodes"]=false,["am.pathfind_reset"]=false,["am.pathfind_turn"]=false,["am.pathfind_go_to"]=false,["am.turtle_started"]=true,["am.turtle_paused"]=true,["am.turtle_exited"]=true,["am.turtle_request_halt"]=true,["am.turtle_request_pause"]=true,["am.turtle_request_continue"]=true,["am.turtle_empty"]=false,["am.turtle_fetch_fill"]=false,["am.turtle_refuel"]=false,["am.turtle_dig"]=false,["am.turtle_error"]=false}g.c.Lookup={}g.c.Lookup.Progress={["am.progress_quarry"]=true}g.c.Event={}g.c.Event.Progress={quarry="am.progress_quarry"}g.c.Event.Pathfind={position="am.pathfind_position",node="am.pathfind_node",reset_nodes="am.pathfind_reset_nodes",reset="am.pathfind_reset",turn="am.pathfind_turn",go_to="am.pathfind_go_to"}g.c.Event.Turtle={started="am.turtle_started",paused="am.turtle_paused",exited="am.turtle_exited",request_halt="am.turtle_request_halt",request_pause="am.turtle_request_pause",request_continue="am.turtle_request_continue",empty="am.turtle_empty",fetch_fill="am.turtle_fetch_fill",refuel="am.turtle_refuel",dig="am.turtle_dig",error="am.turtle_error"}local r=b:extend("am.e.DistributedEvent")g.DistributedEvent=r;function r:init(l)a.expect(1,l,"string")r.super.init(self,l)return self end;function r:validate(s)if not h.signing.get()and s.signature==nil then return true end;if not g.online or s.signature==nil then return false end;local t=s.signature;s.signature=nil;local u=e.hmac(e.sha256,h.psk.get(),f.format(s))return t==u end;function r:sign(s)if not h.signing.get()then return s end;local v=e.hmac(e.sha256,h.psk.get(),f.format(s))s.signature=v;return s end;function r:send()os.queueEvent(self.name,self)if g.broadcastMap[self.name]then j()if g.online then rednet.broadcast(self:sign({type=g.type,src=n(),name=self.name,event=d.copy(self,false)}))end end end;local w=r:extend("am.e.ProgressEvent")g.ProgressEvent=w;function w:init(l)a.expect(1,l,"string")w.super.init(self,l)return self end;local x=w:extend("am.e.QuarryProgressEvent")g.QuarryProgressEvent=x;function x:init(y,z,A)a.expect(1,y,"table")a.expect(2,z,"table")a.expect(3,A,"table")c.requirePosition(1,y)x.super.init(self,g.c.Event.Progress.quarry)self.pos=y;self.job=z;self.progress=A;return self end;local B=r:extend("am.e.PathfindEvent")g.PathfindEvent=B;function B:init(l)a.expect(1,l,"string")B.super.init(self,l)return self end;local C=B:extend("am.e.PositionUpdateEvent")g.PositionUpdateEvent=C;function C:init(D)a.expect(1,D,"table")c.requirePosition(1,D)C.super.init(self,g.c.Event.Pathfind.position)self.position=D;return self end;local E=B:extend("am.e.ResetPathfindEvent")g.ResetPathfindEvent=E;function E:init()E.super.init(self,g.c.Event.Pathfind.reset)return self end;local F=B:extend("am.e.NewNodeEvent")g.NewNodeEvent=F;function F:init(D,G)a.expect(1,D,"table")a.expect(1,G,"boolean","nil")c.requirePosition(1,D)F.super.init(self,g.c.Event.Pathfind.node)if G==nil then G=false end;self.position=D;self.isReturn=G;return self end;local H=B:extend("am.e.ResetNodesEvent")g.ResetNodesEvent=H;function H:init(G)a.expect(1,G,"boolean","nil")H.super.init(self,g.c.Event.Pathfind.reset_nodes)if G==nil then G=false end;self.isReturn=G;return self end;local I=B:extend("am.e.FailableTurtleEvent")g.FailableTurtleEvent=I;function I:init(l,J)a.expect(1,l,"string")a.expect(2,J,"boolean","nil")I.super.init(self,l)self.success=J;return self end;local K=I:extend("am.e.PathfindTurnEvent")g.PathfindTurnEvent=K;function K:init(L,J)a.expect(1,L,"number")a.expect(2,J,"boolean","nil")a.range(L,1,4)I.super.init(self,g.c.Event.Pathfind.turn,J)self.dir=L;return self end;local M=I:extend("am.e.PathfindGoToEvent")g.PathfindGoToEvent=M;function M:init(N,O,P,J)a.expect(1,N,"table")a.expect(2,O,"table")a.expect(3,P,"number")a.expect(4,J,"boolean","nil")c.requirePosition(1,N)c.requirePosition(2,O)a.range(P,0,2)M.super.init(self,g.c.Event.Pathfind.go_to,J)self.destPos=N;self.startPos=O;self.gotoType=P;return self end;local Q=r:extend("am.e.TurtleEvent")g.TurtleEvent=Q;function Q:init(l)a.expect(1,l,"string")Q.super.init(self,l)return self end;local R=Q:extend("am.e.TurtleStartedEvent")g.TurtleStartedEvent=R;function R:init()R.super.init(self,g.c.Event.Turtle.started)return self end;local S=Q:extend("am.e.TurtlePausedEvent")g.TurtlePausedEvent=S;function S:init()S.super.init(self,g.c.Event.Turtle.paused)return self end;local T=Q:extend("am.e.TurtleExitEvent")g.TurtleExitEvent=T;function T:init(U)a.expect(1,U,"boolean")T.super.init(self,g.c.Event.Turtle.exited)self.completed=U;return self end;local V=Q:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestHaltEvent=V;function V:init(W)V.super.init(self,g.c.Event.Turtle.request_halt)self.id=W;return self end;local X=Q:extend("am.e.TurtleRequestPauseEvent")g.TurtleRequestPauseEvent=X;function X:init(W)X.super.init(self,g.c.Event.Turtle.request_pause)self.id=W;return self end;local Y=Q:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestContinueEvent=Y;function Y:init(W)Y.super.init(self,g.c.Event.Turtle.request_continue)self.id=W;return self end;local Z=Q:extend("am.e.TurtleErrorEvent")g.TurtleErrorEvent=Z;function Z:init(error)a.expect(1,error,"string")Z.super.init(self,g.c.Event.Turtle.error)self.error=error;return self end;local _=Q:extend("am.e.TurtleCompletableEvent")g.TurtleCompletableEvent=_;function _:init(l,U)a.expect(1,l,"string")a.expect(2,U,"boolean")_.super.init(self,l)self.completed=U;return self end;local a0=_:extend("am.e.TurtleEmptyEvent")g.TurtleEmptyEvent=a0;function a0:init(U,a1)a.expect(1,U,"boolean")a.expect(2,a1,"table","nil")if U and a1==nil then error("Must include items if is complete")end;a0.super.init(self,g.c.Event.Turtle.empty,U)self.items=a1;return self end;local a2=_:extend("am.e.TurtleFetchFillEvent")g.TurtleFetchFillEvent=a2;function a2:init(U,a3)a.expect(1,U,"boolean")a.expect(2,a3,"table","nil")if U and a3==nil then error("Must include item if is complete")end;a2.super.init(self,g.c.Event.Turtle.fetch_fill,U)self.item=a3;return self end;local a4=_:extend("am.e.TurtleRefuelEvent")g.TurtleRefuelEvent=a4;function a4:init(U,a5,a6,a7)a.expect(1,U,"boolean")a.expect(2,a5,"number","nil")a.expect(3,a6,"number","nil")a.expect(4,a7,"number","nil")if U and(a6==nil or a7==nil)then error("Must include levels if is complete")end;a4.super.init(self,g.c.Event.Turtle.refuel,U)self.requested=a5;self.oldLevel=a6;self.newLevel=a7;return self end;local a8=_:extend("am.e.TurtleDigEvent")g.TurtleDigEvent=a8;function a8:init(U,a9,aa)a.expect(1,U,"boolean")a.expect(2,a9,"number")a.expect(3,aa,"number")a.range(a9,-1,1)a8.super.init(self,g.c.Event.Turtle.dig,U)self.moveDir=a9;self.count=aa;return self end;g.initNetwork=j;g.getComputer=n;g.receive=o;return g
