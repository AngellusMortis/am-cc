local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").e.BaseEvent;local c=require("am.helpers")local d={}local e=false;d.online=false;local function f()if e then return end;d.online=false;local g={peripheral.find("modem",function(h,i)return i.isWireless()end)}if#g>0 then rednet.open(peripheral.getName(g[1]))d.online=true end;e=true end;local function j()return{id=os.getComputerID(),label=os.computerLabel()}end;d.c={}d.c.Turtle={}d.c.Turtle.Direction={Up=-1,Down=0,Front=1,Right=2,Back=3,Left=4}d.c.Turtle.GoTo={Node=0,Origin=1,Return=2}d.broadcastMap={["am.progress_quarry"]=true,["am.pathfind_position"]=false,["am.pathfind_node"]=false,["am.pathfind_reset_nodes"]=false,["am.pathfind_reset"]=false,["am.pathfind_turn"]=false,["am.pathfind_go_to"]=false,["am.pathfind_go_to_origin"]=false,["am.pathfind_go_to_return"]=false,["am.turtle_started"]=false,["am.turtle_paused"]=false,["am.turtle_exited"]=false,["am.turtle_request_halt"]=false,["am.turtle_request_pause"]=false,["am.turtle_request_continue"]=false,["am.turtle_empty"]=false,["am.turtle_fetch_fill"]=false,["am.turtle_refuel"]=false,["am.turtle_dig"]=false,["am.turtle_error"]=false}d.c.Event={}d.c.Event.Progress={quarry="am.progress_quarry"}d.c.Event.Pathfind={position="am.pathfind_position",node="am.pathfind_node",reset_nodes="am.pathfind_reset_nodes",reset="am.pathfind_reset",turn="am.pathfind_turn",go_to="am.pathfind_go_to",go_to_origin="am.pathfind_go_to_origin",go_to_return="am.pathfind_go_to_return"}d.c.Event.Turtle={started="am.turtle_started",paused="am.turtle_paused",exited="am.turtle_exited",request_halt="am.turtle_request_halt",request_pause="am.turtle_request_pause",request_continue="am.turtle_request_continue",empty="am.turtle_empty",fetch_fill="am.turtle_fetch_fill",refuel="am.turtle_refuel",dig="am.turtle_dig",error="am.turtle_error"}local k=b:extend("am.e.DistributedEvent")d.DistributedEvent=k;function k:init(h)a.expect(1,h,"string")k.super.init(self,h)return self end;function k:validate(l)return true end;function k:sign()return""end;function k:send()os.queueEvent(self.name,self)if d.broadcastMap[self.name]then f()if d.online then rednet.broadcast({src=j(),name=self.name,event=self,signature=self:sign()})end end end;local m=k:extend("am.e.ProgressEvent")d.ProgressEvent=m;function m:init(h)a.expect(1,h,"string")m.super.init(self,h)return self end;local n=m:extend("am.e.QuarryProgressEvent")d.QuarryProgressEvent=n;function n:init()n.super.init(self,d.c.Event.Progress.quarry)return self end;local o=k:extend("am.e.PathfindEvent")d.PathfindEvent=o;function o:init(h)a.expect(1,h,"string")o.super.init(self,h)return self end;local p=o:extend("am.e.PositionUpdateEvent")d.PositionUpdateEvent=p;function p:init(q)a.expect(1,q,"table")c.requirePosition(1,q)p.super.init(self,d.c.Event.Pathfind.position)self.position=q;return self end;local r=o:extend("am.e.ResetPathfindEvent")d.ResetPathfindEvent=r;function r:init()r.super.init(self,d.c.Event.Pathfind.reset)return self end;local s=o:extend("am.e.NewNodeEvent")d.NewNodeEvent=s;function s:init(q,t)a.expect(1,q,"table")a.expect(1,t,"boolean","nil")c.requirePosition(1,q)s.super.init(self,d.c.Event.Pathfind.node)if t==nil then t=false end;self.position=q;self.isReturn=t;return self end;local u=o:extend("am.e.ResetNodesEvent")d.ResetNodesEvent=u;function u:init(t)a.expect(1,t,"boolean","nil")u.super.init(self,d.c.Event.Pathfind.reset_nodes)if t==nil then t=false end;self.isReturn=t;return self end;local v=o:extend("am.e.FailableTurtleEvent")d.FailableTurtleEvent=v;function v:init(h,w)a.expect(1,h,"string")a.expect(2,w,"boolean","nil")v.super.init(self,h)self.success=w;return self end;local x=v:extend("am.e.PathfindTurnEvent")d.PathfindTurnEvent=x;function x:init(y,w)a.expect(1,y,"number")a.expect(2,w,"boolean","nil")a.range(y,1,4)v.super.init(self,d.c.Event.Pathfind.turn,w)self.dir=y;return self end;local z=v:extend("am.e.PathfindGoToEvent")d.PathfindGoToEvent=z;function z:init(A,B,C,w)a.expect(1,A,"table")a.expect(2,B,"table")a.expect(3,C,"number")a.expect(4,w,"boolean","nil")c.requirePosition(1,A)c.requirePosition(2,B)a.range(C,0,2)z.super.init(self,d.c.Event.Pathfind.go_to,w)self.destPos=A;self.startPos=B;self.gotoType=C;return self end;local D=k:extend("am.e.TurtleEvent")d.TurtleEvent=D;function D:init(h)a.expect(1,h,"string")D.super.init(self,h)return self end;local E=D:extend("am.e.TurtleStartedEvent")d.TurtleStartedEvent=E;function E:init()E.super.init(self,d.c.Event.Turtle.started)return self end;local F=D:extend("am.e.TurtlePausedEvent")d.TurtlePausedEvent=F;function F:init()F.super.init(self,d.c.Event.Turtle.paused)return self end;local G=D:extend("am.e.TurtleExitEvent")d.TurtleExitEvent=G;function G:init(H)a.expect(1,H,"boolean")G.super.init(self,d.c.Event.Turtle.exited)self.completed=H;return self end;local I=D:extend("am.e.TurtleRequestHaltEvent")d.TurtleRequestHaltEvent=I;function I:init()I.super.init(self,d.c.Event.Turtle.request_halt)return self end;local J=D:extend("am.e.TurtleRequestPauseEvent")d.TurtleRequestPauseEvent=J;function J:init()J.super.init(self,d.c.Event.Turtle.request_pause)return self end;local K=D:extend("am.e.TurtleRequestHaltEvent")d.TurtleRequestContinueEvent=K;function K:init()K.super.init(self,d.c.Event.Turtle.request_continue)return self end;local L=D:extend("am.e.TurtleErrorEvent")d.TurtleErrorEvent=L;function L:init(error)a.expect(1,error,"string")L.super.init(self,d.c.Event.Turtle.error)self.error=error;return self end;local M=D:extend("am.e.TurtleCompletableEvent")d.TurtleCompletableEvent=M;function M:init(h,H)a.expect(1,h,"string")a.expect(2,H,"boolean")M.super.init(self,h)self.completed=H;return self end;local N=M:extend("am.e.TurtleEmptyEvent")d.TurtleEmptyEvent=N;function N:init(H,O)a.expect(1,H,"boolean")a.expect(2,O,"table","nil")if H and O==nil then error("Must include items if is complete")end;N.super.init(self,d.c.Event.Turtle.empty,H)self.items=O;return self end;local P=M:extend("am.e.TurtleFetchFillEvent")d.TurtleFetchFillEvent=P;function P:init(H,Q)a.expect(1,H,"boolean")a.expect(2,Q,"table","nil")if H and Q==nil then error("Must include item if is complete")end;P.super.init(self,d.c.Event.Turtle.fetch_fill,H)self.item=Q;return self end;local R=M:extend("am.e.TurtleRefuelEvent")d.TurtleRefuelEvent=R;function R:init(H,S,T,U)a.expect(1,H,"boolean")a.expect(2,S,"number","nil")a.expect(3,T,"number","nil")a.expect(4,U,"number","nil")if H and(T==nil or U==nil)then error("Must include levels if is complete")end;R.super.init(self,d.c.Event.Turtle.refuel,H)self.requested=S;self.oldLevel=T;self.newLevel=U;return self end;local V=M:extend("am.e.TurtleDigEvent")d.TurtleDigEvent=V;function V:init(H,W,X)a.expect(1,H,"boolean")a.expect(2,W,"number")a.expect(3,X,"number")a.range(W,-1,1)V.super.init(self,d.c.Event.Turtle.dig,H)self.moveDir=W;self.count=X;return self end;d.initNetwork=f;d.getComputer=j;return d
