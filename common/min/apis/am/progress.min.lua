local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui")local c=require("am.event")local d=require("am.core")local e=require("am.progress.helpers")local f=require("am.progress.quarry")local g=require("am.progress.tree")local h=require("am.progress.colonies")local i={}local j={}local k=nil;local function l(m,n)if not n then return b.Frame(b.a.Anchor(1,1),{id=string.format("progressFrame.%d",m.id),fillHorizontal=true,fillVertical=true,border=0,backgroundColor=colors.black,textColor=colors.white})end;if k==nil then k=b.TabbedFrame(b.a.Anchor(1,1),{id="progressFrame",fillHorizontal=true,fillVertical=true,border=0,backgroundColor=colors.black,textColor=colors.white,primaryTabId=tostring(m.id),showTabs=true,tabFillColor=colors.gray,tabTextColor=colors.black,activeTabFillColor=colors.black,activeTabTextColor=colors.yellow,tabPadTop=1,tabPadBottom=0})return k.tabs[1]end;return k:createTab(tostring(m.id))end;local function o(m,p,q,n)a.expect(1,m,"table")a.expect(2,q,"table","nil")a.expect(3,p,"table","nil")a.expect(4,n,"boolean","nil")local r=q~=nil and p~=nil;if q~=nil then b.h.requireOutput(q)end;if n==nil then n=false end;local s=j[m.id]local t=false;if r then if s~=nil then local u=s.output;if b.h.isFrameScreen(u)then u=b.h.getFrameScreen(u).output end;if not s.names[p.name]or not b.h.isSameScreen(u,q)then j[m.id]=nil;s=nil end end;if s==nil then if p.name==c.c.Event.Progress.quarry or p.name==c.c.Event.Progress.tree or p.name==c.c.Event.Colonies.status_poll then local v=l(m,n)local w=q;if n then w=k:makeScreen(q)end;if p.name==c.c.Event.Progress.quarry then s=f(m,p,w,v)elseif p.name==c.c.Event.Progress.tree then s=g(m,p,w,v)elseif p.name==c.c.Event.Colonies.status_poll then s=h(m,p.status.id,w,v)s.progress.status=p.status end end;if s~=nil then s:createUI()j[m.id]=s;if k~=nil then k:setActive(q,#k.tabs)if#k.tabs==1 then q.clear()k:render(q)end end end;t=s~=nil end end;return s,t end;local function x(q)for y,s in pairs(j)do local u=s.output;if b.h.isFrameScreen(u)then u=b.h.getFrameScreen(u).output end;if b.h.isSameScreen(q,u)then return{id=y}end end;return nil end;local function z(m,A)a.expect(1,m,"table")a.expect(2,A,"table")local s=o(m)if s~=nil then s:updatePosition(m,A)end end;local function B(m,C)a.expect(1,m,"table")a.expect(2,C,"string")local s=o(m)if s~=nil then s:updateStatus(m,C)end end;local function D(m,p,q,n)a.expect(1,m,"table")a.expect(2,p,"table")a.expect(3,q,"table","nil")a.expect(4,n,"boolean","nil")if q==nil then q=term else b.h.requireOutput(q)end;if n==nil then n=false end;local s,t=o(m,p,q,n)if s~=nil and not t then s:update(m,p)end end;local function E(p,F)if k~=nil then k:handle(term,p,table.unpack(F))else for G,s in pairs(j)do s:handle(c.getComputer(),p,F)end end end;local function H(m,p,F)local I=nil;if b.c.l.Events.Always[p]then E(p,F)return elseif b.c.l.Events.UI[p]then local J=d.split(F[1].objId,".")if J[1]=="progressFrame"then I={id=tonumber(J[2])}end elseif b.c.l.Events.Terminal[p]then I=x(term)elseif b.c.l.Events.Monitor[p]then I=x(peripheral.wrap(F[1]))elseif p==c.c.Event.Pathfind.position then z(m,F[1].position)return end;if I~=nil then m=I end;if k~=nil then k:handle(term,p,table.unpack(F))else local s,G=o(m)if s~=nil then s:handle(m,p,F)end end end;i.updateStatus=B;i.updatePosition=z;i.print=D;i.handle=H;i.itemStrings=e.itemStrings;return i
