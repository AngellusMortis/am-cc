local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui")local c=require("am.event")local d=require("am.core")local e=require("am.progress.helpers")local f=require("am.log")local g=require("am.progress.quarry")local h=require("am.progress.collect")local i=require("am.progress.colonies")local j={}local k={}local l=nil;local m=100;local function n(o,p)if not p then return b.Frame(b.a.Anchor(1,1),{id=string.format("progressFrame.%d",o.id),fillHorizontal=true,fillVertical=true,border=0,backgroundColor=colors.black,textColor=colors.white})end;if l==nil then l=b.TabbedFrame(b.a.Anchor(1,1),{id="progressFrame",fillHorizontal=true,fillVertical=true,border=0,backgroundColor=colors.black,textColor=colors.white,primaryTabId=tostring(o.id),showTabs=true,tabFillColor=colors.gray,tabTextColor=colors.black,activeTabFillColor=colors.black,activeTabTextColor=colors.yellow,tabPadTop=1,tabPadBottom=0})return l.tabs[1]end;return l:createTab(tostring(o.id))end;local function q(o,r,s,p)a.expect(1,o,"table")a.expect(2,s,"table","nil")a.expect(3,r,"table","nil")a.expect(4,p,"boolean","nil")local t=s~=nil and r~=nil;if s~=nil then b.h.requireOutput(s)end;if p==nil then p=false end;local u=k[o.id]local v=false;if t then if u~=nil then local w=u.output;if b.h.isFrameScreen(w)then w=b.h.getFrameScreen(w).output end;if not u.names[r.name]or not b.h.isSameScreen(w,s)then k[o.id]=nil;u=nil end end;if u==nil then if r.name==c.c.Event.Progress.quarry or r.name==c.c.Event.Progress.collect or r.name==c.c.Event.Progress.tree or r.name==c.c.Event.Colonies.status_poll then local x=n(o,p)local y=s;if p then y=l:makeScreen(s)end;if r.name==c.c.Event.Progress.quarry then u=g(o,r,y,x)elseif r.name==c.c.Event.Progress.collect or r.name==c.c.Event.Progress.tree then u=h(o,r,y,x)elseif r.name==c.c.Event.Colonies.status_poll then u=i(o,r.status.id,y,x)u.progress.status=r.status end end;if u~=nil then u:createUI()k[o.id]=u;if l~=nil then l:setActive(s,#l.tabs)if#l.tabs==1 then s.clear()l:render(s)end end end;v=u~=nil end end;return u,v end;local function z(s)for A,u in pairs(k)do local w=u.output;if b.h.isFrameScreen(w)then w=b.h.getFrameScreen(w).output end;if b.h.isSameScreen(s,w)then return{id=A}end end;return nil end;local function B(o,C)a.expect(1,o,"table")a.expect(2,C,"table")local u=q(o)if u~=nil then u:updatePosition(o,C)end end;local function D(o,E)a.expect(1,o,"table")a.expect(2,E,"string")local u=q(o)if u~=nil then u:updateStatus(o,E)end end;local function F(o,r,s,p)a.expect(1,o,"table")a.expect(2,r,"table")a.expect(3,s,"table","nil")a.expect(4,p,"boolean","nil")if s==nil then s=term else b.h.requireOutput(s)end;if p==nil then p=false end;local u,v=q(o,r,s,p)if u~=nil and not v then u:update(o,r)end end;local function G(r,H)if l~=nil then l:handle(term,r,table.unpack(H))else for I,u in pairs(k)do u:handle(c.getComputer(),r,H)end end end;local function J(o,r,H)local K=os.epoch("utc")local L=nil;if b.c.l.Events.Always[r]then G(r,H)return elseif b.c.l.Events.UI[r]then local M=d.split(H[1].objId,".")if M[1]=="progressFrame"then L={id=tonumber(M[2])}end elseif b.c.l.Events.Terminal[r]then L=z(term)elseif b.c.l.Events.Monitor[r]then L=z(peripheral.wrap(H[1]))elseif r==c.c.Event.Pathfind.position then B(o,H[1].position)return end;if l~=nil and r==b.c.e.Events.tab_change and H[1].objId==l.id then local N=l:getTab(H[1].newTabId)for A,u in pairs(k)do if u.frame.id==N.id then u:update({id=A},nil,true)break end end end;if L~=nil then o=L end;if l~=nil then l:handle(term,r,table.unpack(H))else local u,I=q(o)if u~=nil then u:handle(o,r,H)end end;local O=os.epoch("utc")-K;if O>m then if b.c.l.Events.UI[r]then f.warning(string.format("UI Event %s took too long to process (%s): %s",r,O,f.format(H[1])))else f.warning(string.format("Event %s took too long to process (%s)",r,O))end end end;j.updateStatus=D;j.updatePosition=B;j.print=F;j.handle=J;j.itemStrings=e.itemStrings;return j
