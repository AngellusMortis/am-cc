local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").e.BaseEvent;local c=require("am.helpers")local d=require("am.core")local e=require("ext.hmac")local f=require("am.log")local g={}local h={}h.signing={name="event.signing",default=false,type="boolean"}h.psk={name="event.psk",default="",type="string"}h=d.makeSettingWrapper(h)local i=false;local j=5000;g.online=false;g.type="am.net"local function k()if i then return end;if not h.signing.get()or h.psk.get()~=""then g.online=false;local l={peripheral.find("modem",function(m,n)return n.isWireless()end)}if#l>0 then rednet.open(peripheral.getName(l[1]))g.online=true end end;i=true end;local function o()return{id=os.getComputerID(),label=os.computerLabel()}end;local function p()if not g.online then return nil end;local q,r=rednet.receive(nil,3)if r~=nil and r.type==g.type then if g.DistributedEvent.validate(nil,d.copy(r,false))then return r else f.debug(string.format("bad signature: %s",f.format(r)))end end;return nil end;g.c={}g.c.Turtle={}g.c.Turtle.Direction={Up=-1,Down=0,Front=1,Right=2,Back=3,Left=4}g.c.Turtle.GoTo={Node=0,Origin=1,Return=2}g.c.RunType={Running=1,Completed=2,Paused=3,Halted=4}g.broadcastMap={["am.progress_quarry"]=true,["am.progress_tree"]=true,["am.pathfind_position"]=false,["am.pathfind_node"]=false,["am.pathfind_reset_nodes"]=false,["am.pathfind_reset"]=false,["am.pathfind_turn"]=false,["am.pathfind_go_to"]=false,["am.turtle_started"]=true,["am.turtle_paused"]=true,["am.turtle_exited"]=true,["am.turtle_request_halt"]=true,["am.turtle_request_pause"]=true,["am.turtle_request_continue"]=true,["am.turtle_empty"]=false,["am.turtle_fetch_fill"]=false,["am.turtle_refuel"]=false,["am.turtle_dig"]=false,["am.turtle_error"]=false,["am.turtle_error_clear"]=false,["am.colonies_warehouse_poll"]=true,["am.colonies_status_poll"]=true}g.c.Lookup={}g.c.Lookup.Progress={["am.progress_quarry"]=true,["am.progress_tree"]=true,["am.colonies_status_poll"]=true}g.c.Event={}g.c.Event.Progress={quarry="am.progress_quarry",tree="am.progress_tree"}g.c.Event.Pathfind={position="am.pathfind_position",node="am.pathfind_node",reset_nodes="am.pathfind_reset_nodes",reset="am.pathfind_reset",turn="am.pathfind_turn",go_to="am.pathfind_go_to"}g.c.Event.Turtle={started="am.turtle_started",paused="am.turtle_paused",exited="am.turtle_exited",request_halt="am.turtle_request_halt",request_pause="am.turtle_request_pause",request_continue="am.turtle_request_continue",empty="am.turtle_empty",fetch_fill="am.turtle_fetch_fill",refuel="am.turtle_refuel",dig="am.turtle_dig",error="am.turtle_error",error_clear="am.turtle_error_clear"}g.c.Event.Colonies={warehouse_poll="am.colonies_warehouse_poll",status_poll="am.colonies_status_poll"}local s=b:extend("am.e.DistributedEvent")g.DistributedEvent=s;function s:init(m)a.expect(1,m,"string")s.super.init(self,m)return self end;function s:validate(t)if not h.signing.get()and t.signature==nil then return true end;if not g.online or t.signature==nil or t.epoch==nil then return false end;if type(t.signature)~="string"or type(t.epoch)~="number"then return false end;local u=os.epoch()if t.epoch>u or u-j>t.epoch then return false end;local v=t.signature;t.signature=nil;local w=e.hmac(e.sha256,h.psk.get(),f.format(t))return v==w end;function s:sign(t)if not h.signing.get()then return t end;t.epoch=os.epoch()local x=e.hmac(e.sha256,h.psk.get(),f.format(t))t.signature=x;return t end;function s:send()os.queueEvent(self.name,self)if g.broadcastMap[self.name]then k()if g.online then rednet.broadcast(self:sign({type=g.type,src=o(),name=self.name,event=d.copy(self,false)}))end end end;local y=s:extend("am.e.ProgressEvent")g.ProgressEvent=y;function y:init(m)a.expect(1,m,"string")y.super.init(self,m)return self end;local z=y:extend("am.e.TreeProgressEvent")g.TreeProgressEvent=z;function z:init(A,B,C,D)a.expect(1,A,"table")a.expect(2,B,"table")a.expect(3,C,"string")a.expect(4,D,"number")c.requirePosition(1,A)z.super.init(self,g.c.Event.Progress.tree)self.pos=A;self.trees=B;self.status=C;self.rate=D;return self end;local E=y:extend("am.e.QuarryProgressEvent")g.QuarryProgressEvent=E;function E:init(A,F,G)a.expect(1,A,"table")a.expect(2,F,"table")a.expect(3,G,"table")c.requirePosition(1,A)E.super.init(self,g.c.Event.Progress.quarry)self.pos=A;self.job=F;self.progress=G;return self end;local H=s:extend("am.e.PathfindEvent")g.PathfindEvent=H;function H:init(m)a.expect(1,m,"string")H.super.init(self,m)return self end;local I=H:extend("am.e.PositionUpdateEvent")g.PositionUpdateEvent=I;function I:init(J)a.expect(1,J,"table")c.requirePosition(1,J)I.super.init(self,g.c.Event.Pathfind.position)self.position=J;return self end;local K=H:extend("am.e.ResetPathfindEvent")g.ResetPathfindEvent=K;function K:init()K.super.init(self,g.c.Event.Pathfind.reset)return self end;local L=H:extend("am.e.NewNodeEvent")g.NewNodeEvent=L;function L:init(J,M)a.expect(1,J,"table")a.expect(1,M,"boolean","nil")c.requirePosition(1,J)L.super.init(self,g.c.Event.Pathfind.node)if M==nil then M=false end;self.position=J;self.isReturn=M;return self end;local N=H:extend("am.e.ResetNodesEvent")g.ResetNodesEvent=N;function N:init(M)a.expect(1,M,"boolean","nil")N.super.init(self,g.c.Event.Pathfind.reset_nodes)if M==nil then M=false end;self.isReturn=M;return self end;local O=H:extend("am.e.FailableTurtleEvent")g.FailableTurtleEvent=O;function O:init(m,P)a.expect(1,m,"string")a.expect(2,P,"boolean","nil")O.super.init(self,m)self.success=P;return self end;local Q=O:extend("am.e.PathfindTurnEvent")g.PathfindTurnEvent=Q;function Q:init(R,P)a.expect(1,R,"number")a.expect(2,P,"boolean","nil")a.range(R,1,4)O.super.init(self,g.c.Event.Pathfind.turn,P)self.dir=R;return self end;local S=O:extend("am.e.PathfindGoToEvent")g.PathfindGoToEvent=S;function S:init(T,U,V,P)a.expect(1,T,"table")a.expect(2,U,"table")a.expect(3,V,"number")a.expect(4,P,"boolean","nil")c.requirePosition(1,T)c.requirePosition(2,U)a.range(V,0,2)S.super.init(self,g.c.Event.Pathfind.go_to,P)self.destPos=T;self.startPos=U;self.gotoType=V;return self end;local W=s:extend("am.e.TurtleEvent")g.TurtleEvent=W;function W:init(m)a.expect(1,m,"string")W.super.init(self,m)return self end;local X=W:extend("am.e.TurtleStartedEvent")g.TurtleStartedEvent=X;function X:init()X.super.init(self,g.c.Event.Turtle.started)return self end;local Y=W:extend("am.e.TurtlePausedEvent")g.TurtlePausedEvent=Y;function Y:init()Y.super.init(self,g.c.Event.Turtle.paused)return self end;local Z=W:extend("am.e.TurtleExitEvent")g.TurtleExitEvent=Z;function Z:init(_)a.expect(1,_,"boolean")Z.super.init(self,g.c.Event.Turtle.exited)self.completed=_;return self end;local a0=W:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestHaltEvent=a0;function a0:init(a1)a0.super.init(self,g.c.Event.Turtle.request_halt)self.id=a1;return self end;local a2=W:extend("am.e.TurtleRequestPauseEvent")g.TurtleRequestPauseEvent=a2;function a2:init(a1)a2.super.init(self,g.c.Event.Turtle.request_pause)self.id=a1;return self end;local a3=W:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestContinueEvent=a3;function a3:init(a1)a3.super.init(self,g.c.Event.Turtle.request_continue)self.id=a1;return self end;local a4=W:extend("am.e.TurtleErrorEvent")g.TurtleErrorEvent=a4;function a4:init(a5)a.expect(1,a5,"string")a4.super.init(self,g.c.Event.Turtle.error)self.error=a5;return self end;local a6=W:extend("am.e.TurtleErrorClearEvent")g.TurtleErrorClearEvent=a6;function a6:init()a6.super.init(self,g.c.Event.Turtle.error_clear)return self end;local a7=W:extend("am.e.TurtleCompletableEvent")g.TurtleCompletableEvent=a7;function a7:init(m,_)a.expect(1,m,"string")a.expect(2,_,"boolean")a7.super.init(self,m)self.completed=_;return self end;local a8=a7:extend("am.e.TurtleEmptyEvent")g.TurtleEmptyEvent=a8;function a8:init(_,a9)a.expect(1,_,"boolean")a.expect(2,a9,"table","nil")if _ and a9==nil then error("Must include items if is complete")end;a8.super.init(self,g.c.Event.Turtle.empty,_)self.items=a9;return self end;local aa=a7:extend("am.e.TurtleFetchFillEvent")g.TurtleFetchFillEvent=aa;function aa:init(_,ab)a.expect(1,_,"boolean")a.expect(2,ab,"table","nil")if _ and ab==nil then error("Must include item if is complete")end;aa.super.init(self,g.c.Event.Turtle.fetch_fill,_)self.item=ab;return self end;local ac=a7:extend("am.e.TurtleRefuelEvent")g.TurtleRefuelEvent=ac;function ac:init(_,ad,ae,af)a.expect(1,_,"boolean")a.expect(2,ad,"number","nil")a.expect(3,ae,"number","nil")a.expect(4,af,"number","nil")if _ and(ae==nil or af==nil)then error("Must include levels if is complete")end;ac.super.init(self,g.c.Event.Turtle.refuel,_)self.requested=ad;self.oldLevel=ae;self.newLevel=af;return self end;local ag=a7:extend("am.e.TurtleDigEvent")g.TurtleDigEvent=ag;function ag:init(_,ah,ai)a.expect(1,_,"boolean")a.expect(2,ah,"number")a.expect(3,ai,"number")a.range(ah,-1,1)ag.super.init(self,g.c.Event.Turtle.dig,_)self.moveDir=ah;self.count=ai;return self end;local aj=s:extend("am.e.ColoniesEvent")g.ColoniesEvent=aj;function aj:init(m)a.expect(1,m,"string")aj.super.init(self,m)return self end;local ak=aj:extend("am.e.TurtleEmptyEvent")g.ColonyStatusPollEvent=ak;function ak:init(C)a.expect(1,C,"table")ak.super.init(self,g.c.Event.Colonies.status_poll)self.status=C;return self end;g.initNetwork=k;g.getComputer=o;g.receive=p;return g
