local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").e.BaseEvent;local c=require("am.helpers")local d=require("am.core")local e=require("ext.hmac")local f=require("am.log")local g={}local h={}h.signing={name="event.signing",default=false,type="boolean"}h.psk={name="event.psk",default="",type="string"}h=d.makeSettingWrapper(h)local i=false;local j=72000*3;g.online=false;g.type="am.net"local function k()if i then return end;if not h.signing.get()or h.psk.get()~=""then g.online=false;local l={peripheral.find("modem",function(m,n)return n.isWireless()end)}if#l>0 then rednet.open(peripheral.getName(l[1]))g.online=true end end;i=true end;local function o()return{id=os.getComputerID(),label=os.computerLabel()}end;local function p()if not g.online then return nil end;local q,r=rednet.receive(nil,3)if r~=nil and r.type==g.type then if g.DistributedEvent.validate(nil,d.copy(r,false))then return r end end;return nil end;g.c={}g.c.Turtle={}g.c.Turtle.Direction={Up=-1,Down=0,Front=1,Right=2,Back=3,Left=4}g.c.Turtle.GoTo={Node=0,Origin=1,Return=2}g.c.RunType={Running=1,Completed=2,Paused=3,Halted=4}g.broadcastMap={["am.error"]=false,["am.ping"]=true,["am.progress_quarry"]=true,["am.progress_collect"]=true,["am.progress_tree"]=true,["am.pathfind_position"]=true,["am.pathfind_node"]=false,["am.pathfind_reset_nodes"]=false,["am.pathfind_reset"]=false,["am.pathfind_turn"]=false,["am.pathfind_go_to"]=false,["am.turtle_started"]=true,["am.turtle_paused"]=true,["am.turtle_exited"]=true,["am.turtle_request_halt"]=true,["am.turtle_request_pause"]=true,["am.turtle_request_continue"]=true,["am.turtle_empty"]=false,["am.turtle_fetch_fill"]=false,["am.turtle_refuel"]=false,["am.turtle_dig"]=false,["am.turtle_error"]=false,["am.turtle_error_clear"]=false,["am.colonies_warehouse_poll"]=true,["am.colonies_status_poll"]=true}g.c.Lookup={}g.c.Lookup.Progress={["am.progress_quarry"]=true,["am.progress_collect"]=true,["am.progress_tree"]=true,["am.colonies_status_poll"]=true}g.c.Event={}g.c.Event.Common={error="am.error",ping="am.ping"}g.c.Event.Progress={quarry="am.progress_quarry",collect="am.progress_collect",tree="am.progress_tree"}g.c.Event.Pathfind={position="am.pathfind_position",node="am.pathfind_node",reset_nodes="am.pathfind_reset_nodes",reset="am.pathfind_reset",turn="am.pathfind_turn",go_to="am.pathfind_go_to"}g.c.Event.Turtle={started="am.turtle_started",paused="am.turtle_paused",exited="am.turtle_exited",request_halt="am.turtle_request_halt",request_pause="am.turtle_request_pause",request_continue="am.turtle_request_continue",empty="am.turtle_empty",fetch_fill="am.turtle_fetch_fill",refuel="am.turtle_refuel",dig="am.turtle_dig",error="am.turtle_error",error_clear="am.turtle_error_clear"}g.c.Event.Colonies={warehouse_poll="am.colonies_warehouse_poll",status_poll="am.colonies_status_poll"}local s=b:extend("am.e.DistributedEvent")g.DistributedEvent=s;function s:init(m)a.expect(1,m,"string")s.super.init(self,m)return self end;function s:validate(t)if not h.signing.get()and t.signature==nil then return true end;if not g.online then f.debug("bad message: offline")return false end;if t.signature==nil or t.epoch==nil then f.debug("bad message: missing signature")return false end;if type(t.signature)~="string"or type(t.epoch)~="number"then f.debug("bad message: invalid signature")return false end;local u=os.epoch()if t.epoch>u or u-j>t.epoch then f.debug(string.format("bad message: outdated signature: %s %s %s",t.src,u,t.epoch))return false end;local v=t.signature;t.signature=nil;local w=e.hmac(e.sha256,h.psk.get(),f.format(t))local x=v==w;if not x then f.debug(string.format("bad message: mismatch: %s %s %s",f.format(t.src),v,w))end;return x end;function s:sign(t)if not h.signing.get()then return t end;t.epoch=os.epoch()local y=e.hmac(e.sha256,h.psk.get(),f.format(t))t.signature=y;return t end;function s:send()os.queueEvent(self.name,self)if g.broadcastMap[self.name]then k()if g.online then rednet.broadcast(self:sign({type=g.type,src=o(),name=self.name,event=d.copy(self,false)}))end end end;local z=s:extend("am.e.ErrorEvent")g.ErrorEvent=z;function z:init(A)a.expect(1,A,"string")z.super.init(self,g.c.Event.Common.error)self.error=A;return self end;local B=s:extend("am.e.PingEvent")g.PingEvent=B;function B:init()B.super.init(self,g.c.Event.Common.ping)return self end;local C=s:extend("am.e.ProgressEvent")g.ProgressEvent=C;function C:init(m)a.expect(1,m,"string")C.super.init(self,m)return self end;local D=C:extend("am.e.CollectProgressEvent")g.CollectProgressEvent=D;function D:init(E,F)a.expect(1,F,"table")D.super.init(self,g.c.Event.Progress.collect)self.status=E;self.rates=F;return self end;local G=D:extend("am.e.TreeProgressEvent")g.TreeProgressEvent=G;function G:init(H,I,E,F)a.expect(1,H,"table")a.expect(2,I,"table")a.expect(3,E,"string")a.expect(4,F,"table")c.requirePosition(1,H)G.super.init(self,E,F)self.name=g.c.Event.Progress.tree;self.pos=H;self.trees=I;return self end;local J=C:extend("am.e.QuarryProgressEvent")g.QuarryProgressEvent=J;function J:init(H,K,L)a.expect(1,H,"table")a.expect(2,K,"table")a.expect(3,L,"table")c.requirePosition(1,H)J.super.init(self,g.c.Event.Progress.quarry)self.pos=H;self.job=K;self.progress=L;return self end;local M=s:extend("am.e.PathfindEvent")g.PathfindEvent=M;function M:init(m)a.expect(1,m,"string")M.super.init(self,m)return self end;local N=M:extend("am.e.PositionUpdateEvent")g.PositionUpdateEvent=N;function N:init(O)a.expect(1,O,"table")c.requirePosition(1,O)N.super.init(self,g.c.Event.Pathfind.position)self.position=O;return self end;local P=M:extend("am.e.ResetPathfindEvent")g.ResetPathfindEvent=P;function P:init()P.super.init(self,g.c.Event.Pathfind.reset)return self end;local Q=M:extend("am.e.NewNodeEvent")g.NewNodeEvent=Q;function Q:init(O,R)a.expect(1,O,"table")a.expect(1,R,"boolean","nil")c.requirePosition(1,O)Q.super.init(self,g.c.Event.Pathfind.node)if R==nil then R=false end;self.position=O;self.isReturn=R;return self end;local S=M:extend("am.e.ResetNodesEvent")g.ResetNodesEvent=S;function S:init(R)a.expect(1,R,"boolean","nil")S.super.init(self,g.c.Event.Pathfind.reset_nodes)if R==nil then R=false end;self.isReturn=R;return self end;local T=M:extend("am.e.FailableTurtleEvent")g.FailableTurtleEvent=T;function T:init(m,U)a.expect(1,m,"string")a.expect(2,U,"boolean","nil")T.super.init(self,m)self.success=U;return self end;local V=T:extend("am.e.PathfindTurnEvent")g.PathfindTurnEvent=V;function V:init(W,U)a.expect(1,W,"number")a.expect(2,U,"boolean","nil")a.range(W,1,4)T.super.init(self,g.c.Event.Pathfind.turn,U)self.dir=W;return self end;local X=T:extend("am.e.PathfindGoToEvent")g.PathfindGoToEvent=X;function X:init(Y,Z,_,U)a.expect(1,Y,"table")a.expect(2,Z,"table")a.expect(3,_,"number")a.expect(4,U,"boolean","nil")c.requirePosition(1,Y)c.requirePosition(2,Z)a.range(_,0,2)X.super.init(self,g.c.Event.Pathfind.go_to,U)self.destPos=Y;self.startPos=Z;self.gotoType=_;return self end;local a0=s:extend("am.e.TurtleEvent")g.TurtleEvent=a0;function a0:init(m)a.expect(1,m,"string")a0.super.init(self,m)return self end;local a1=a0:extend("am.e.TurtleStartedEvent")g.TurtleStartedEvent=a1;function a1:init()a1.super.init(self,g.c.Event.Turtle.started)return self end;local a2=a0:extend("am.e.TurtlePausedEvent")g.TurtlePausedEvent=a2;function a2:init()a2.super.init(self,g.c.Event.Turtle.paused)return self end;local a3=a0:extend("am.e.TurtleExitEvent")g.TurtleExitEvent=a3;function a3:init(a4)a.expect(1,a4,"boolean")a3.super.init(self,g.c.Event.Turtle.exited)self.completed=a4;return self end;local a5=a0:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestHaltEvent=a5;function a5:init(a6)a5.super.init(self,g.c.Event.Turtle.request_halt)self.id=a6;return self end;local a7=a0:extend("am.e.TurtleRequestPauseEvent")g.TurtleRequestPauseEvent=a7;function a7:init(a6)a7.super.init(self,g.c.Event.Turtle.request_pause)self.id=a6;return self end;local a8=a0:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestContinueEvent=a8;function a8:init(a6)a8.super.init(self,g.c.Event.Turtle.request_continue)self.id=a6;return self end;local a9=a0:extend("am.e.TurtleErrorEvent")g.TurtleErrorEvent=a9;function a9:init(A)a.expect(1,A,"string")a9.super.init(self,g.c.Event.Turtle.error)self.error=A;return self end;local aa=a0:extend("am.e.TurtleErrorClearEvent")g.TurtleErrorClearEvent=aa;function aa:init()aa.super.init(self,g.c.Event.Turtle.error_clear)return self end;local ab=a0:extend("am.e.TurtleCompletableEvent")g.TurtleCompletableEvent=ab;function ab:init(m,a4)a.expect(1,m,"string")a.expect(2,a4,"boolean")ab.super.init(self,m)self.completed=a4;return self end;local ac=ab:extend("am.e.TurtleEmptyEvent")g.TurtleEmptyEvent=ac;function ac:init(a4,ad)a.expect(1,a4,"boolean")a.expect(2,ad,"table","nil")if a4 and ad==nil then error("Must include items if is complete")end;ac.super.init(self,g.c.Event.Turtle.empty,a4)self.items=ad;return self end;local ae=ab:extend("am.e.TurtleFetchFillEvent")g.TurtleFetchFillEvent=ae;function ae:init(a4,af)a.expect(1,a4,"boolean")a.expect(2,af,"table","nil")if a4 and af==nil then error("Must include item if is complete")end;ae.super.init(self,g.c.Event.Turtle.fetch_fill,a4)self.item=af;return self end;local ag=ab:extend("am.e.TurtleRefuelEvent")g.TurtleRefuelEvent=ag;function ag:init(a4,ah,ai,aj)a.expect(1,a4,"boolean")a.expect(2,ah,"number","nil")a.expect(3,ai,"number","nil")a.expect(4,aj,"number","nil")if a4 and(ai==nil or aj==nil)then error("Must include levels if is complete")end;ag.super.init(self,g.c.Event.Turtle.refuel,a4)self.requested=ah;self.oldLevel=ai;self.newLevel=aj;return self end;local ak=ab:extend("am.e.TurtleDigEvent")g.TurtleDigEvent=ak;function ak:init(a4,al,am)a.expect(1,a4,"boolean")a.expect(2,al,"number")a.expect(3,am,"number")a.range(al,-1,1)ak.super.init(self,g.c.Event.Turtle.dig,a4)self.moveDir=al;self.count=am;return self end;local an=s:extend("am.e.ColoniesEvent")g.ColoniesEvent=an;function an:init(m)a.expect(1,m,"string")an.super.init(self,m)return self end;local ao=an:extend("am.e.ColonyStatusPollEvent")g.ColonyStatusPollEvent=ao;function ao:init(E,ap)a.expect(1,E,"table")ao.super.init(self,g.c.Event.Colonies.status_poll)self.status=E;self.text=ap;return self end;local aq=an:extend("am.e.ColonyWarehousePollEvent")g.ColonyWarehousePollEvent=aq;function aq:init(a6,ad,ar,as)a.expect(1,a6,"number")a.expect(2,ad,"table")a.expect(3,ar,"number")a.expect(4,as,"number")aq.super.init(self,g.c.Event.Colonies.warehouse_poll)self.id=a6;self.items=ad;self.usedSlots=ar;self.totalSlots=as;return self end;g.initNetwork=k;g.getComputer=o;g.receive=p;return g
