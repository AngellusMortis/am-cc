local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").e.BaseEvent;local c=require("am.helpers")local d=require("am.core")local e=require("ext.hmac")local f=require("am.log")local g={}local h={}h.signing={name="event.signing",default=false,type="boolean"}h.psk={name="event.psk",default="",type="string"}h=d.makeSettingWrapper(h)local i=false;local j=72000*3;g.online=false;g.type="am.net"local function k()if i then return end;if not h.signing.get()or h.psk.get()~=""then g.online=false;local l={peripheral.find("modem",function(m,n)return n.isWireless()end)}if#l>0 then rednet.open(peripheral.getName(l[1]))g.online=true end end;i=true end;local function o()return{id=os.getComputerID(),label=os.computerLabel()}end;local function p()if not g.online then return nil end;local q,r=rednet.receive(nil,3)if r~=nil and r.type==g.type then if g.DistributedEvent.validate(nil,d.copy(r,false))then return r end end;return nil end;g.c={}g.c.Turtle={}g.c.Turtle.Direction={Up=-1,Down=0,Front=1,Right=2,Back=3,Left=4}g.c.Turtle.GoTo={Node=0,Origin=1,Return=2}g.c.RunType={Running=1,Completed=2,Paused=3,Halted=4}g.broadcastMap={["am.progress_quarry"]=true,["am.progress_tree"]=true,["am.pathfind_position"]=false,["am.pathfind_node"]=false,["am.pathfind_reset_nodes"]=false,["am.pathfind_reset"]=false,["am.pathfind_turn"]=false,["am.pathfind_go_to"]=false,["am.turtle_started"]=true,["am.turtle_paused"]=true,["am.turtle_exited"]=true,["am.turtle_request_halt"]=true,["am.turtle_request_pause"]=true,["am.turtle_request_continue"]=true,["am.turtle_empty"]=false,["am.turtle_fetch_fill"]=false,["am.turtle_refuel"]=false,["am.turtle_dig"]=false,["am.turtle_error"]=false,["am.turtle_error_clear"]=false,["am.colonies_warehouse_poll"]=true,["am.colonies_status_poll"]=true}g.c.Lookup={}g.c.Lookup.Progress={["am.progress_quarry"]=true,["am.progress_tree"]=true,["am.colonies_status_poll"]=true}g.c.Event={}g.c.Event.Progress={quarry="am.progress_quarry",tree="am.progress_tree"}g.c.Event.Pathfind={position="am.pathfind_position",node="am.pathfind_node",reset_nodes="am.pathfind_reset_nodes",reset="am.pathfind_reset",turn="am.pathfind_turn",go_to="am.pathfind_go_to"}g.c.Event.Turtle={started="am.turtle_started",paused="am.turtle_paused",exited="am.turtle_exited",request_halt="am.turtle_request_halt",request_pause="am.turtle_request_pause",request_continue="am.turtle_request_continue",empty="am.turtle_empty",fetch_fill="am.turtle_fetch_fill",refuel="am.turtle_refuel",dig="am.turtle_dig",error="am.turtle_error",error_clear="am.turtle_error_clear"}g.c.Event.Colonies={warehouse_poll="am.colonies_warehouse_poll",status_poll="am.colonies_status_poll"}local s=b:extend("am.e.DistributedEvent")g.DistributedEvent=s;function s:init(m)a.expect(1,m,"string")s.super.init(self,m)return self end;function s:validate(t)if not h.signing.get()and t.signature==nil then return true end;if not g.online then f.debug("bad message: offline")return false end;if t.signature==nil or t.epoch==nil then f.debug("bad message: missing signature")return false end;if type(t.signature)~="string"or type(t.epoch)~="number"then f.debug("bad message: invalid signature")return false end;local u=os.epoch()if t.epoch>u or u-j>t.epoch then f.debug(string.format("bad message: outdated signature: %s %s %s",t.src,u,t.epoch))return false end;local v=t.signature;t.signature=nil;local w=e.hmac(e.sha256,h.psk.get(),f.format(t))local x=v==w;if not x then f.debug(string.format("bad message: mismatch: %s %s %s",f.format(t.src),v,w))end;return x end;function s:sign(t)if not h.signing.get()then return t end;t.epoch=os.epoch()local y=e.hmac(e.sha256,h.psk.get(),f.format(t))t.signature=y;return t end;function s:send()os.queueEvent(self.name,self)if g.broadcastMap[self.name]then k()if g.online then rednet.broadcast(self:sign({type=g.type,src=o(),name=self.name,event=d.copy(self,false)}))end end end;local z=s:extend("am.e.ProgressEvent")g.ProgressEvent=z;function z:init(m)a.expect(1,m,"string")z.super.init(self,m)return self end;local A=z:extend("am.e.TreeProgressEvent")g.TreeProgressEvent=A;function A:init(B,C,D,E)a.expect(1,B,"table")a.expect(2,C,"table")a.expect(3,D,"string")a.expect(4,E,"number")c.requirePosition(1,B)A.super.init(self,g.c.Event.Progress.tree)self.pos=B;self.trees=C;self.status=D;self.rate=E;return self end;local F=z:extend("am.e.QuarryProgressEvent")g.QuarryProgressEvent=F;function F:init(B,G,H)a.expect(1,B,"table")a.expect(2,G,"table")a.expect(3,H,"table")c.requirePosition(1,B)F.super.init(self,g.c.Event.Progress.quarry)self.pos=B;self.job=G;self.progress=H;return self end;local I=s:extend("am.e.PathfindEvent")g.PathfindEvent=I;function I:init(m)a.expect(1,m,"string")I.super.init(self,m)return self end;local J=I:extend("am.e.PositionUpdateEvent")g.PositionUpdateEvent=J;function J:init(K)a.expect(1,K,"table")c.requirePosition(1,K)J.super.init(self,g.c.Event.Pathfind.position)self.position=K;return self end;local L=I:extend("am.e.ResetPathfindEvent")g.ResetPathfindEvent=L;function L:init()L.super.init(self,g.c.Event.Pathfind.reset)return self end;local M=I:extend("am.e.NewNodeEvent")g.NewNodeEvent=M;function M:init(K,N)a.expect(1,K,"table")a.expect(1,N,"boolean","nil")c.requirePosition(1,K)M.super.init(self,g.c.Event.Pathfind.node)if N==nil then N=false end;self.position=K;self.isReturn=N;return self end;local O=I:extend("am.e.ResetNodesEvent")g.ResetNodesEvent=O;function O:init(N)a.expect(1,N,"boolean","nil")O.super.init(self,g.c.Event.Pathfind.reset_nodes)if N==nil then N=false end;self.isReturn=N;return self end;local P=I:extend("am.e.FailableTurtleEvent")g.FailableTurtleEvent=P;function P:init(m,Q)a.expect(1,m,"string")a.expect(2,Q,"boolean","nil")P.super.init(self,m)self.success=Q;return self end;local R=P:extend("am.e.PathfindTurnEvent")g.PathfindTurnEvent=R;function R:init(S,Q)a.expect(1,S,"number")a.expect(2,Q,"boolean","nil")a.range(S,1,4)P.super.init(self,g.c.Event.Pathfind.turn,Q)self.dir=S;return self end;local T=P:extend("am.e.PathfindGoToEvent")g.PathfindGoToEvent=T;function T:init(U,V,W,Q)a.expect(1,U,"table")a.expect(2,V,"table")a.expect(3,W,"number")a.expect(4,Q,"boolean","nil")c.requirePosition(1,U)c.requirePosition(2,V)a.range(W,0,2)T.super.init(self,g.c.Event.Pathfind.go_to,Q)self.destPos=U;self.startPos=V;self.gotoType=W;return self end;local X=s:extend("am.e.TurtleEvent")g.TurtleEvent=X;function X:init(m)a.expect(1,m,"string")X.super.init(self,m)return self end;local Y=X:extend("am.e.TurtleStartedEvent")g.TurtleStartedEvent=Y;function Y:init()Y.super.init(self,g.c.Event.Turtle.started)return self end;local Z=X:extend("am.e.TurtlePausedEvent")g.TurtlePausedEvent=Z;function Z:init()Z.super.init(self,g.c.Event.Turtle.paused)return self end;local _=X:extend("am.e.TurtleExitEvent")g.TurtleExitEvent=_;function _:init(a0)a.expect(1,a0,"boolean")_.super.init(self,g.c.Event.Turtle.exited)self.completed=a0;return self end;local a1=X:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestHaltEvent=a1;function a1:init(a2)a1.super.init(self,g.c.Event.Turtle.request_halt)self.id=a2;return self end;local a3=X:extend("am.e.TurtleRequestPauseEvent")g.TurtleRequestPauseEvent=a3;function a3:init(a2)a3.super.init(self,g.c.Event.Turtle.request_pause)self.id=a2;return self end;local a4=X:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestContinueEvent=a4;function a4:init(a2)a4.super.init(self,g.c.Event.Turtle.request_continue)self.id=a2;return self end;local a5=X:extend("am.e.TurtleErrorEvent")g.TurtleErrorEvent=a5;function a5:init(a6)a.expect(1,a6,"string")a5.super.init(self,g.c.Event.Turtle.error)self.error=a6;return self end;local a7=X:extend("am.e.TurtleErrorClearEvent")g.TurtleErrorClearEvent=a7;function a7:init()a7.super.init(self,g.c.Event.Turtle.error_clear)return self end;local a8=X:extend("am.e.TurtleCompletableEvent")g.TurtleCompletableEvent=a8;function a8:init(m,a0)a.expect(1,m,"string")a.expect(2,a0,"boolean")a8.super.init(self,m)self.completed=a0;return self end;local a9=a8:extend("am.e.TurtleEmptyEvent")g.TurtleEmptyEvent=a9;function a9:init(a0,aa)a.expect(1,a0,"boolean")a.expect(2,aa,"table","nil")if a0 and aa==nil then error("Must include items if is complete")end;a9.super.init(self,g.c.Event.Turtle.empty,a0)self.items=aa;return self end;local ab=a8:extend("am.e.TurtleFetchFillEvent")g.TurtleFetchFillEvent=ab;function ab:init(a0,ac)a.expect(1,a0,"boolean")a.expect(2,ac,"table","nil")if a0 and ac==nil then error("Must include item if is complete")end;ab.super.init(self,g.c.Event.Turtle.fetch_fill,a0)self.item=ac;return self end;local ad=a8:extend("am.e.TurtleRefuelEvent")g.TurtleRefuelEvent=ad;function ad:init(a0,ae,af,ag)a.expect(1,a0,"boolean")a.expect(2,ae,"number","nil")a.expect(3,af,"number","nil")a.expect(4,ag,"number","nil")if a0 and(af==nil or ag==nil)then error("Must include levels if is complete")end;ad.super.init(self,g.c.Event.Turtle.refuel,a0)self.requested=ae;self.oldLevel=af;self.newLevel=ag;return self end;local ah=a8:extend("am.e.TurtleDigEvent")g.TurtleDigEvent=ah;function ah:init(a0,ai,aj)a.expect(1,a0,"boolean")a.expect(2,ai,"number")a.expect(3,aj,"number")a.range(ai,-1,1)ah.super.init(self,g.c.Event.Turtle.dig,a0)self.moveDir=ai;self.count=aj;return self end;local ak=s:extend("am.e.ColoniesEvent")g.ColoniesEvent=ak;function ak:init(m)a.expect(1,m,"string")ak.super.init(self,m)return self end;local al=ak:extend("am.e.TurtleEmptyEvent")g.ColonyStatusPollEvent=al;function al:init(D)a.expect(1,D,"table")al.super.init(self,g.c.Event.Colonies.status_poll)self.status=D;return self end;g.initNetwork=k;g.getComputer=o;g.receive=p;return g
