local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").e.BaseEvent;local c=require("am.helpers")local d=require("am.core")local e=require("ext.hmac")local f=require("am.log")local g={}local h={}h.signing={name="event.signing",default=false,type="boolean"}h.psk={name="event.psk",default="",type="string"}h=d.makeSettingWrapper(h)local i=false;local j=72000*3;g.online=false;g.type="am.net"local function k()if i then return end;if not h.signing.get()or h.psk.get()~=""then g.online=false;local l={peripheral.find("modem",function(m,n)return n.isWireless()end)}if#l>0 then rednet.open(peripheral.getName(l[1]))g.online=true end end;i=true end;local function o()return{id=os.getComputerID(),label=os.computerLabel()}end;local function p()if not g.online then return nil end;local q,r=rednet.receive(nil,3)if r~=nil and r.type==g.type then if g.DistributedEvent.validate(nil,d.copy(r,false))then return r end end;return nil end;g.c={}g.c.Turtle={}g.c.Turtle.Direction={Up=-1,Down=0,Front=1,Right=2,Back=3,Left=4}g.c.Turtle.GoTo={Node=0,Origin=1,Return=2}g.c.RunType={Running=1,Completed=2,Paused=3,Halted=4}g.broadcastMap={["am.error"]=false,["am.progress_quarry"]=true,["am.progress_collect"]=true,["am.progress_tree"]=true,["am.pathfind_position"]=true,["am.pathfind_node"]=false,["am.pathfind_reset_nodes"]=false,["am.pathfind_reset"]=false,["am.pathfind_turn"]=false,["am.pathfind_go_to"]=false,["am.turtle_started"]=true,["am.turtle_paused"]=true,["am.turtle_exited"]=true,["am.turtle_request_halt"]=true,["am.turtle_request_pause"]=true,["am.turtle_request_continue"]=true,["am.turtle_empty"]=false,["am.turtle_fetch_fill"]=false,["am.turtle_refuel"]=false,["am.turtle_dig"]=false,["am.turtle_error"]=false,["am.turtle_error_clear"]=false,["am.colonies_warehouse_poll"]=true,["am.colonies_status_poll"]=true}g.c.Lookup={}g.c.Lookup.Progress={["am.progress_quarry"]=true,["am.progress_collect"]=true,["am.progress_tree"]=true,["am.colonies_status_poll"]=true}g.c.Event={}g.c.Event.Common={error="am.error"}g.c.Event.Progress={quarry="am.progress_quarry",collect="am.progress_collect",tree="am.progress_tree"}g.c.Event.Pathfind={position="am.pathfind_position",node="am.pathfind_node",reset_nodes="am.pathfind_reset_nodes",reset="am.pathfind_reset",turn="am.pathfind_turn",go_to="am.pathfind_go_to"}g.c.Event.Turtle={started="am.turtle_started",paused="am.turtle_paused",exited="am.turtle_exited",request_halt="am.turtle_request_halt",request_pause="am.turtle_request_pause",request_continue="am.turtle_request_continue",empty="am.turtle_empty",fetch_fill="am.turtle_fetch_fill",refuel="am.turtle_refuel",dig="am.turtle_dig",error="am.turtle_error",error_clear="am.turtle_error_clear"}g.c.Event.Colonies={warehouse_poll="am.colonies_warehouse_poll",status_poll="am.colonies_status_poll"}local s=b:extend("am.e.DistributedEvent")g.DistributedEvent=s;function s:init(m)a.expect(1,m,"string")s.super.init(self,m)return self end;function s:validate(t)if not h.signing.get()and t.signature==nil then return true end;if not g.online then f.debug("bad message: offline")return false end;if t.signature==nil or t.epoch==nil then f.debug("bad message: missing signature")return false end;if type(t.signature)~="string"or type(t.epoch)~="number"then f.debug("bad message: invalid signature")return false end;local u=os.epoch()if t.epoch>u or u-j>t.epoch then f.debug(string.format("bad message: outdated signature: %s %s %s",t.src,u,t.epoch))return false end;local v=t.signature;t.signature=nil;local w=e.hmac(e.sha256,h.psk.get(),f.format(t))local x=v==w;if not x then f.debug(string.format("bad message: mismatch: %s %s %s",f.format(t.src),v,w))end;return x end;function s:sign(t)if not h.signing.get()then return t end;t.epoch=os.epoch()local y=e.hmac(e.sha256,h.psk.get(),f.format(t))t.signature=y;return t end;function s:send()os.queueEvent(self.name,self)if g.broadcastMap[self.name]then k()if g.online then rednet.broadcast(self:sign({type=g.type,src=o(),name=self.name,event=d.copy(self,false)}))end end end;local z=s:extend("am.e.ErrorEvent")g.ErrorEvent=z;function z:init(A)a.expect(1,A,"string")z.super.init(self,g.c.Event.Turtle.error)self.error=A;return self end;local B=s:extend("am.e.ProgressEvent")g.ProgressEvent=B;function B:init(m)a.expect(1,m,"string")B.super.init(self,m)return self end;local C=B:extend("am.e.CollectProgressEvent")g.CollectProgressEvent=C;function C:init(D)a.expect(1,D,"table")C.super.init(self,g.c.Event.Progress.collect)self.rates=D;return self end;local E=C:extend("am.e.TreeProgressEvent")g.TreeProgressEvent=E;function E:init(F,G,H,D)a.expect(1,F,"table")a.expect(2,G,"table")a.expect(3,H,"string")a.expect(4,D,"table")c.requirePosition(1,F)E.super.init(self,D)self.name=g.c.Event.Progress.tree;self.pos=F;self.trees=G;self.status=H;return self end;local I=B:extend("am.e.QuarryProgressEvent")g.QuarryProgressEvent=I;function I:init(F,J,K)a.expect(1,F,"table")a.expect(2,J,"table")a.expect(3,K,"table")c.requirePosition(1,F)I.super.init(self,g.c.Event.Progress.quarry)self.pos=F;self.job=J;self.progress=K;return self end;local L=s:extend("am.e.PathfindEvent")g.PathfindEvent=L;function L:init(m)a.expect(1,m,"string")L.super.init(self,m)return self end;local M=L:extend("am.e.PositionUpdateEvent")g.PositionUpdateEvent=M;function M:init(N)a.expect(1,N,"table")c.requirePosition(1,N)M.super.init(self,g.c.Event.Pathfind.position)self.position=N;return self end;local O=L:extend("am.e.ResetPathfindEvent")g.ResetPathfindEvent=O;function O:init()O.super.init(self,g.c.Event.Pathfind.reset)return self end;local P=L:extend("am.e.NewNodeEvent")g.NewNodeEvent=P;function P:init(N,Q)a.expect(1,N,"table")a.expect(1,Q,"boolean","nil")c.requirePosition(1,N)P.super.init(self,g.c.Event.Pathfind.node)if Q==nil then Q=false end;self.position=N;self.isReturn=Q;return self end;local R=L:extend("am.e.ResetNodesEvent")g.ResetNodesEvent=R;function R:init(Q)a.expect(1,Q,"boolean","nil")R.super.init(self,g.c.Event.Pathfind.reset_nodes)if Q==nil then Q=false end;self.isReturn=Q;return self end;local S=L:extend("am.e.FailableTurtleEvent")g.FailableTurtleEvent=S;function S:init(m,T)a.expect(1,m,"string")a.expect(2,T,"boolean","nil")S.super.init(self,m)self.success=T;return self end;local U=S:extend("am.e.PathfindTurnEvent")g.PathfindTurnEvent=U;function U:init(V,T)a.expect(1,V,"number")a.expect(2,T,"boolean","nil")a.range(V,1,4)S.super.init(self,g.c.Event.Pathfind.turn,T)self.dir=V;return self end;local W=S:extend("am.e.PathfindGoToEvent")g.PathfindGoToEvent=W;function W:init(X,Y,Z,T)a.expect(1,X,"table")a.expect(2,Y,"table")a.expect(3,Z,"number")a.expect(4,T,"boolean","nil")c.requirePosition(1,X)c.requirePosition(2,Y)a.range(Z,0,2)W.super.init(self,g.c.Event.Pathfind.go_to,T)self.destPos=X;self.startPos=Y;self.gotoType=Z;return self end;local _=s:extend("am.e.TurtleEvent")g.TurtleEvent=_;function _:init(m)a.expect(1,m,"string")_.super.init(self,m)return self end;local a0=_:extend("am.e.TurtleStartedEvent")g.TurtleStartedEvent=a0;function a0:init()a0.super.init(self,g.c.Event.Turtle.started)return self end;local a1=_:extend("am.e.TurtlePausedEvent")g.TurtlePausedEvent=a1;function a1:init()a1.super.init(self,g.c.Event.Turtle.paused)return self end;local a2=_:extend("am.e.TurtleExitEvent")g.TurtleExitEvent=a2;function a2:init(a3)a.expect(1,a3,"boolean")a2.super.init(self,g.c.Event.Turtle.exited)self.completed=a3;return self end;local a4=_:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestHaltEvent=a4;function a4:init(a5)a4.super.init(self,g.c.Event.Turtle.request_halt)self.id=a5;return self end;local a6=_:extend("am.e.TurtleRequestPauseEvent")g.TurtleRequestPauseEvent=a6;function a6:init(a5)a6.super.init(self,g.c.Event.Turtle.request_pause)self.id=a5;return self end;local a7=_:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestContinueEvent=a7;function a7:init(a5)a7.super.init(self,g.c.Event.Turtle.request_continue)self.id=a5;return self end;local a8=_:extend("am.e.TurtleErrorEvent")g.TurtleErrorEvent=a8;function a8:init(A)a.expect(1,A,"string")a8.super.init(self,g.c.Event.Turtle.error)self.error=A;return self end;local a9=_:extend("am.e.TurtleErrorClearEvent")g.TurtleErrorClearEvent=a9;function a9:init()a9.super.init(self,g.c.Event.Turtle.error_clear)return self end;local aa=_:extend("am.e.TurtleCompletableEvent")g.TurtleCompletableEvent=aa;function aa:init(m,a3)a.expect(1,m,"string")a.expect(2,a3,"boolean")aa.super.init(self,m)self.completed=a3;return self end;local ab=aa:extend("am.e.TurtleEmptyEvent")g.TurtleEmptyEvent=ab;function ab:init(a3,ac)a.expect(1,a3,"boolean")a.expect(2,ac,"table","nil")if a3 and ac==nil then error("Must include items if is complete")end;ab.super.init(self,g.c.Event.Turtle.empty,a3)self.items=ac;return self end;local ad=aa:extend("am.e.TurtleFetchFillEvent")g.TurtleFetchFillEvent=ad;function ad:init(a3,ae)a.expect(1,a3,"boolean")a.expect(2,ae,"table","nil")if a3 and ae==nil then error("Must include item if is complete")end;ad.super.init(self,g.c.Event.Turtle.fetch_fill,a3)self.item=ae;return self end;local af=aa:extend("am.e.TurtleRefuelEvent")g.TurtleRefuelEvent=af;function af:init(a3,ag,ah,ai)a.expect(1,a3,"boolean")a.expect(2,ag,"number","nil")a.expect(3,ah,"number","nil")a.expect(4,ai,"number","nil")if a3 and(ah==nil or ai==nil)then error("Must include levels if is complete")end;af.super.init(self,g.c.Event.Turtle.refuel,a3)self.requested=ag;self.oldLevel=ah;self.newLevel=ai;return self end;local aj=aa:extend("am.e.TurtleDigEvent")g.TurtleDigEvent=aj;function aj:init(a3,ak,al)a.expect(1,a3,"boolean")a.expect(2,ak,"number")a.expect(3,al,"number")a.range(ak,-1,1)aj.super.init(self,g.c.Event.Turtle.dig,a3)self.moveDir=ak;self.count=al;return self end;local am=s:extend("am.e.ColoniesEvent")g.ColoniesEvent=am;function am:init(m)a.expect(1,m,"string")am.super.init(self,m)return self end;local an=am:extend("am.e.TurtleEmptyEvent")g.ColonyStatusPollEvent=an;function an:init(H)a.expect(1,H,"table")an.super.init(self,g.c.Event.Colonies.status_poll)self.status=H;return self end;g.initNetwork=k;g.getComputer=o;g.receive=p;return g
