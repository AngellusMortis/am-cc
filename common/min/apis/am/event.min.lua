local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").e.BaseEvent;local c=require("am.helpers")local d=require("am.core")local e=require("ext.hmac")local f=require("am.log")local g={}local h={}h.signing={name="event.signing",default=false,type="boolean"}h.psk={name="event.psk",default="",type="string"}h=d.makeSettingWrapper(h)local i=false;local j=72000*3;g.online=false;g.type="am.net"local function k()if i then return end;if not h.signing.get()or h.psk.get()~=""then g.online=false;local l={peripheral.find("modem",function(m,n)return n.isWireless()end)}if#l>0 then rednet.open(peripheral.getName(l[1]))g.online=true end end;i=true end;local function o()return{id=os.getComputerID(),label=os.computerLabel()}end;local function p()if not g.online then return nil end;local q,r=rednet.receive(nil,3)if r~=nil and r.type==g.type then if g.DistributedEvent.validate(nil,d.copy(r,false))then return r end end;return nil end;g.c={}g.c.Turtle={}g.c.Turtle.Direction={Up=-1,Down=0,Front=1,Right=2,Back=3,Left=4}g.c.Turtle.GoTo={Node=0,Origin=1,Return=2}g.c.RunType={Running=1,Completed=2,Paused=3,Halted=4}g.broadcastMap={["am.progress_quarry"]=true,["am.progress_collect"]=true,["am.progress_tree"]=true,["am.pathfind_position"]=true,["am.pathfind_node"]=false,["am.pathfind_reset_nodes"]=false,["am.pathfind_reset"]=false,["am.pathfind_turn"]=false,["am.pathfind_go_to"]=false,["am.turtle_started"]=true,["am.turtle_paused"]=true,["am.turtle_exited"]=true,["am.turtle_request_halt"]=true,["am.turtle_request_pause"]=true,["am.turtle_request_continue"]=true,["am.turtle_empty"]=false,["am.turtle_fetch_fill"]=false,["am.turtle_refuel"]=false,["am.turtle_dig"]=false,["am.turtle_error"]=false,["am.turtle_error_clear"]=false,["am.colonies_warehouse_poll"]=true,["am.colonies_status_poll"]=true}g.c.Lookup={}g.c.Lookup.Progress={["am.progress_quarry"]=true,["am.progress_collect"]=true,["am.progress_tree"]=true,["am.colonies_status_poll"]=true}g.c.Event={}g.c.Event.Progress={quarry="am.progress_quarry",collect="am.progress_collect",tree="am.progress_tree"}g.c.Event.Pathfind={position="am.pathfind_position",node="am.pathfind_node",reset_nodes="am.pathfind_reset_nodes",reset="am.pathfind_reset",turn="am.pathfind_turn",go_to="am.pathfind_go_to"}g.c.Event.Turtle={started="am.turtle_started",paused="am.turtle_paused",exited="am.turtle_exited",request_halt="am.turtle_request_halt",request_pause="am.turtle_request_pause",request_continue="am.turtle_request_continue",empty="am.turtle_empty",fetch_fill="am.turtle_fetch_fill",refuel="am.turtle_refuel",dig="am.turtle_dig",error="am.turtle_error",error_clear="am.turtle_error_clear"}g.c.Event.Colonies={warehouse_poll="am.colonies_warehouse_poll",status_poll="am.colonies_status_poll"}local s=b:extend("am.e.DistributedEvent")g.DistributedEvent=s;function s:init(m)a.expect(1,m,"string")s.super.init(self,m)return self end;function s:validate(t)if not h.signing.get()and t.signature==nil then return true end;if not g.online then f.debug("bad message: offline")return false end;if t.signature==nil or t.epoch==nil then f.debug("bad message: missing signature")return false end;if type(t.signature)~="string"or type(t.epoch)~="number"then f.debug("bad message: invalid signature")return false end;local u=os.epoch()if t.epoch>u or u-j>t.epoch then f.debug(string.format("bad message: outdated signature: %s %s %s",t.src,u,t.epoch))return false end;local v=t.signature;t.signature=nil;local w=e.hmac(e.sha256,h.psk.get(),f.format(t))local x=v==w;if not x then f.debug(string.format("bad message: mismatch: %s %s %s",f.format(t.src),v,w))end;return x end;function s:sign(t)if not h.signing.get()then return t end;t.epoch=os.epoch()local y=e.hmac(e.sha256,h.psk.get(),f.format(t))t.signature=y;return t end;function s:send()os.queueEvent(self.name,self)if g.broadcastMap[self.name]then k()if g.online then rednet.broadcast(self:sign({type=g.type,src=o(),name=self.name,event=d.copy(self,false)}))end end end;local z=s:extend("am.e.ProgressEvent")g.ProgressEvent=z;function z:init(m)a.expect(1,m,"string")z.super.init(self,m)return self end;local A=z:extend("am.e.CollectProgressEvent")g.CollectProgressEvent=A;function A:init(B)a.expect(1,B,"table")A.super.init(self,g.c.Event.Progress.collect)self.rates=B;return self end;local C=A:extend("am.e.TreeProgressEvent")g.TreeProgressEvent=C;function C:init(D,E,F,B)a.expect(1,D,"table")a.expect(2,E,"table")a.expect(3,F,"string")a.expect(4,B,"table")c.requirePosition(1,D)C.super.init(self,B)self.name=g.c.Event.Progress.tree;self.pos=D;self.trees=E;self.status=F;return self end;local G=z:extend("am.e.QuarryProgressEvent")g.QuarryProgressEvent=G;function G:init(D,H,I)a.expect(1,D,"table")a.expect(2,H,"table")a.expect(3,I,"table")c.requirePosition(1,D)G.super.init(self,g.c.Event.Progress.quarry)self.pos=D;self.job=H;self.progress=I;return self end;local J=s:extend("am.e.PathfindEvent")g.PathfindEvent=J;function J:init(m)a.expect(1,m,"string")J.super.init(self,m)return self end;local K=J:extend("am.e.PositionUpdateEvent")g.PositionUpdateEvent=K;function K:init(L)a.expect(1,L,"table")c.requirePosition(1,L)K.super.init(self,g.c.Event.Pathfind.position)self.position=L;return self end;local M=J:extend("am.e.ResetPathfindEvent")g.ResetPathfindEvent=M;function M:init()M.super.init(self,g.c.Event.Pathfind.reset)return self end;local N=J:extend("am.e.NewNodeEvent")g.NewNodeEvent=N;function N:init(L,O)a.expect(1,L,"table")a.expect(1,O,"boolean","nil")c.requirePosition(1,L)N.super.init(self,g.c.Event.Pathfind.node)if O==nil then O=false end;self.position=L;self.isReturn=O;return self end;local P=J:extend("am.e.ResetNodesEvent")g.ResetNodesEvent=P;function P:init(O)a.expect(1,O,"boolean","nil")P.super.init(self,g.c.Event.Pathfind.reset_nodes)if O==nil then O=false end;self.isReturn=O;return self end;local Q=J:extend("am.e.FailableTurtleEvent")g.FailableTurtleEvent=Q;function Q:init(m,R)a.expect(1,m,"string")a.expect(2,R,"boolean","nil")Q.super.init(self,m)self.success=R;return self end;local S=Q:extend("am.e.PathfindTurnEvent")g.PathfindTurnEvent=S;function S:init(T,R)a.expect(1,T,"number")a.expect(2,R,"boolean","nil")a.range(T,1,4)Q.super.init(self,g.c.Event.Pathfind.turn,R)self.dir=T;return self end;local U=Q:extend("am.e.PathfindGoToEvent")g.PathfindGoToEvent=U;function U:init(V,W,X,R)a.expect(1,V,"table")a.expect(2,W,"table")a.expect(3,X,"number")a.expect(4,R,"boolean","nil")c.requirePosition(1,V)c.requirePosition(2,W)a.range(X,0,2)U.super.init(self,g.c.Event.Pathfind.go_to,R)self.destPos=V;self.startPos=W;self.gotoType=X;return self end;local Y=s:extend("am.e.TurtleEvent")g.TurtleEvent=Y;function Y:init(m)a.expect(1,m,"string")Y.super.init(self,m)return self end;local Z=Y:extend("am.e.TurtleStartedEvent")g.TurtleStartedEvent=Z;function Z:init()Z.super.init(self,g.c.Event.Turtle.started)return self end;local _=Y:extend("am.e.TurtlePausedEvent")g.TurtlePausedEvent=_;function _:init()_.super.init(self,g.c.Event.Turtle.paused)return self end;local a0=Y:extend("am.e.TurtleExitEvent")g.TurtleExitEvent=a0;function a0:init(a1)a.expect(1,a1,"boolean")a0.super.init(self,g.c.Event.Turtle.exited)self.completed=a1;return self end;local a2=Y:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestHaltEvent=a2;function a2:init(a3)a2.super.init(self,g.c.Event.Turtle.request_halt)self.id=a3;return self end;local a4=Y:extend("am.e.TurtleRequestPauseEvent")g.TurtleRequestPauseEvent=a4;function a4:init(a3)a4.super.init(self,g.c.Event.Turtle.request_pause)self.id=a3;return self end;local a5=Y:extend("am.e.TurtleRequestHaltEvent")g.TurtleRequestContinueEvent=a5;function a5:init(a3)a5.super.init(self,g.c.Event.Turtle.request_continue)self.id=a3;return self end;local a6=Y:extend("am.e.TurtleErrorEvent")g.TurtleErrorEvent=a6;function a6:init(a7)a.expect(1,a7,"string")a6.super.init(self,g.c.Event.Turtle.error)self.error=a7;return self end;local a8=Y:extend("am.e.TurtleErrorClearEvent")g.TurtleErrorClearEvent=a8;function a8:init()a8.super.init(self,g.c.Event.Turtle.error_clear)return self end;local a9=Y:extend("am.e.TurtleCompletableEvent")g.TurtleCompletableEvent=a9;function a9:init(m,a1)a.expect(1,m,"string")a.expect(2,a1,"boolean")a9.super.init(self,m)self.completed=a1;return self end;local aa=a9:extend("am.e.TurtleEmptyEvent")g.TurtleEmptyEvent=aa;function aa:init(a1,ab)a.expect(1,a1,"boolean")a.expect(2,ab,"table","nil")if a1 and ab==nil then error("Must include items if is complete")end;aa.super.init(self,g.c.Event.Turtle.empty,a1)self.items=ab;return self end;local ac=a9:extend("am.e.TurtleFetchFillEvent")g.TurtleFetchFillEvent=ac;function ac:init(a1,ad)a.expect(1,a1,"boolean")a.expect(2,ad,"table","nil")if a1 and ad==nil then error("Must include item if is complete")end;ac.super.init(self,g.c.Event.Turtle.fetch_fill,a1)self.item=ad;return self end;local ae=a9:extend("am.e.TurtleRefuelEvent")g.TurtleRefuelEvent=ae;function ae:init(a1,af,ag,ah)a.expect(1,a1,"boolean")a.expect(2,af,"number","nil")a.expect(3,ag,"number","nil")a.expect(4,ah,"number","nil")if a1 and(ag==nil or ah==nil)then error("Must include levels if is complete")end;ae.super.init(self,g.c.Event.Turtle.refuel,a1)self.requested=af;self.oldLevel=ag;self.newLevel=ah;return self end;local ai=a9:extend("am.e.TurtleDigEvent")g.TurtleDigEvent=ai;function ai:init(a1,aj,ak)a.expect(1,a1,"boolean")a.expect(2,aj,"number")a.expect(3,ak,"number")a.range(aj,-1,1)ai.super.init(self,g.c.Event.Turtle.dig,a1)self.moveDir=aj;self.count=ak;return self end;local al=s:extend("am.e.ColoniesEvent")g.ColoniesEvent=al;function al:init(m)a.expect(1,m,"string")al.super.init(self,m)return self end;local am=al:extend("am.e.TurtleEmptyEvent")g.ColonyStatusPollEvent=am;function am:init(F)a.expect(1,F,"table")am.super.init(self,g.c.Event.Colonies.status_poll)self.status=F;return self end;g.initNetwork=k;g.getComputer=o;g.receive=p;return g
