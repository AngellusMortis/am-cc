local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.event")local d=require("am.ui")local e=require("am.progress")local f=require("am.core")local g=require("am.peripheral")local h={}h.autoDiscover={name="progress.autoDiscover",default=true,type="boolean"}h.outputMap={name="progress.outputMap",default={},type="table"}h.timeout={name="progress.timeout",default=30,type="number"}h=f.makeSettingWrapper(h)local i={width=13,height=7}local j={width=25,height=13}local k={}local l={}local m=false;_G.RUN_PROGRESS=true;_G.PROGRESS_SHOW_CLOSE=false;local function n()local o={}for p,q in ipairs(peripheral.getNames())do if peripheral.getType(q)=="monitor"then local r=peripheral.wrap(q)r.clear()r.setCursorPos(1,1)r.setTextScale(1.0)local s,t=r.getSize()if s>i.width and t>i.height then if s<j.width or t<j.height then r.setTextScale(0.5)elseif s>=j.width*5 and t>=j.height*5 then r.setTextScale(5.0)elseif s>=j.width*4 and t>=j.height*4 then r.setTextScale(4.0)elseif s>=j.width*3 and t>=j.height*3 then r.setTextScale(3.0)elseif s>=j.width*2 and t>=j.height*2 then r.setTextScale(2.0)end;o[q]=r end end end;return o end;local function u(v)if v==nil or v=="term"then return term,"term"end;a.expect(1,v,"string")local o=n()local w=o[v]if w==nil then error(string.format("Could not find montior at %s",v))end;return w,v end;local function x(y)a.expect(1,y,"table")local z={}for A,w in pairs(y)do local v;if d.h.isTerm(w)then v="term"else v=peripheral.getName(w)end;z[A]=v end;h.outputMap.set(z)end;local function B(C,v)a.expect(1,C,"table")a.expect(2,v,"string")local z=h.outputMap.get()z[C.id]=v;h.outputMap.set(z)local q=C.label or C.id;b.info(string.format("Adding %s as output for %s...",v,q))end;local function D()local z=h.outputMap.get()local y={}local E={}for A,v in pairs(z)do local w=u(v)if w~=nil then y[A]=w;E[v]=A end end;x(y)return y,E end;local function F(C,G)a.expect(1,C,"table")a.expect(2,G,"boolean","nil")if G==nil then G=h.autoDiscover.get()end;if m then return term end;if l.outputMap==nil or l.computerMap==nil then l.outputMap,l.computerMap=D()end;local w=l.outputMap[C.id]if w==nil and C.label~=nil then w=l.outputMap[string.lower(C.label)]end;if w~=nil or not G then return w end;local H=0;for v,w in pairs(n())do H=H+1;local I=l.computerMap[v]if I==nil then B(C,v)l.outputMap[C.id]=w;l.computerMap[v]=C.id;return w end end;if H==0 then return term end;return nil end;local function J(E)if E["term"]~=nil or _G.PROGRESS_SHOW_CLOSE then b.s.print.set(false)else b.s.print.set(true)term.clear()term.setCursorPos(1,1)term.setTextColor(colors.white)end end;local function K(A)k[A]=-1 end;local function L(A,M)if M==nil then M=false end;if k[A]~=-1 or M then k[A]=os.clock()+settings.get(h.timeout.name)end end;local function N()while _G.RUN_PROGRESS do local O,P=f.cleanEventArgs(os.pullEvent())e.handle(c.getComputer(),O,P)end end;local function Q()while _G.RUN_PROGRESS do local R=c.receive()if R~=nil then local w=nil;if c.c.Lookup.Progress[R.name]then w=F(R.src)if w~=nil then e.print(R.src,R.event,w,m)L(R.src.id)end end;if w==nil then w=F(R.src,false)end;if w~=nil then if R.event.name==c.c.Event.Pathfind.position or R.event.name==c.c.Event.Common.ping then L(R.src.id)elseif R.event.name==c.c.Event.Turtle.turtle_started then L(R.src.id,true)elseif R.event.name==c.c.Event.Turtle.paused or R.event.name==c.c.Event.Turtle.exited then K(R.src.id)end;e.handle(R.src,R.event.name,{R.event})end end end end;local function S()while _G.RUN_PROGRESS do sleep(1)local T=os.clock()for A,U in pairs(k)do if U~=-1 and T>U then local w=F({id=A})if w~=nil then e.updateStatus({id=A},"error:Progress Timeout")end end end end end;local function V()local H=0;for W=1,multishell.getCount(),1 do if multishell.getTitle(W)=="progress"then H=H+1;if H>1 then return true end end end;return false end;local function X(q,v)local y={}local E={}if q~=nil then local Y;Y,v=u(v)a.expect(1,q,"string")a.expect(2,Y,"table")q=string.lower(q)h.autoDiscover.set(false)y[q]=Y;E[v]=q;x(y)if v=="term"then _G.PROGRESS_SHOW_CLOSE=true end else local Z=false;for p,p in pairs(h.outputMap.get())do Z=true;break end;if h.autoDiscover.get()or not Z then local o=g.getMonitorNames()if#o==0 then m=true;_G.PROGRESS_SHOW_CLOSE=true else h.autoDiscover.set(true)y,E=D()end else y,E=D()_G.PROGRESS_SHOW_CLOSE=true end;if V()then error("Auto-Progress already running")return end end;J(E)c.initNetwork()if not c.online then error("Could not find modem")end;local _=q;for A,w in pairs(y)do q=_ or A;v="term"if not d.h.isTerm(w)then v=peripheral.getName(w)end;b.info(string.format("Using %s output for %s",v,q))w.clear()w.setCursorPos(1,1)w.setTextColor(colors.white)w.write(string.format("Wait for %s...",q))w.setCursorPos(1,2)end;b.info("Listening for progress events...")l={outputMap=y,computerMap=E}parallel.waitForAny(N,Q,S)b.s.print.set(true)term.setBackgroundColor(colors.black)term.setTextColor(colors.white)term.clear()term.setCursorPos(1,1)end;X(arg[1],arg[2])
