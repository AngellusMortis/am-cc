local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.event")local d=require("am.ui")local e=require("am.progress")local f=require("am.core")local g={}g.autoDiscover={name="progress.autoDiscover",default=true,type="boolean"}g.outputMap={name="progress.outputMap",default={},type="table"}g.timeout={name="progress.timeout",default=30,type="number"}g=f.makeSettingWrapper(g)local h={width=13,height=7}local i={width=25,height=13}local j={}local k={}_G.RUN_PROGRESS=true;local function l()local m={}for n,o in ipairs(peripheral.getNames())do if peripheral.getType(o)=="monitor"then local p=peripheral.wrap(o)p.clear()p.setCursorPos(1,1)p.setTextScale(1.0)local q,r=p.getSize()if q>h.width and r>h.height then if q<i.width or r<i.height then p.setTextScale(0.5)elseif q>=i.width*5 and r>=i.height*5 then p.setTextScale(5.0)elseif q>=i.width*4 and r>=i.height*4 then p.setTextScale(4.0)elseif q>=i.width*3 and r>=i.height*3 then p.setTextScale(3.0)elseif q>=i.width*2 and r>=i.height*2 then p.setTextScale(2.0)end;m[o]=p end end end;return m end;local function s(t)if t==nil or t=="term"then return term,"term"end;a.expect(1,t,"string")local m=l()local u=m[t]if u==nil then error(string.format("Could not find montior at %s",t))end;return u,t end;local function v(w)a.expect(1,w,"table")local x={}for y,u in pairs(w)do local t;if d.h.isTerm(u)then t="term"else t=peripheral.getName(u)end;x[y]=t end;g.outputMap.set(x)end;local function z(A,t)a.expect(1,A,"table")a.expect(2,t,"string")local x=g.outputMap.get()x[A.id]=t;g.outputMap.set(x)local o=A.label or A.id;b.info(string.format("Adding %s as output for %s...",t,o))end;local function B()local x=g.outputMap.get()local w={}local C={}for y,t in pairs(x)do local u=s(t)if u~=nil then w[y]=u;C[t]=y end end;v(w)return w,C end;local function D(A,E)a.expect(1,A,"table")a.expect(2,E,"boolean","nil")if E==nil then E=g.autoDiscover.get()end;if k.outputMap==nil or k.computerMap==nil then k.outputMap,k.computerMap=B()end;local u=k.outputMap[A.id]if u==nil and A.label~=nil then u=k.outputMap[string.lower(A.label)]end;if u~=nil or not E then return u end;local F=0;for t,u in pairs(l())do F=F+1;local G=k.computerMap[t]if G==nil then z(A,t)k.outputMap[A.id]=u;k.computerMap[t]=A.id;return u end end;if F==0 then return term end;return nil end;local function H(C)if C["term"]~=nil then b.s.print.set(false)else b.s.print.set(true)term.clear()term.setCursorPos(1,1)term.setTextColor(colors.white)end end;local function I()while _G.RUN_PROGRESS do local J,K=f.cleanEventArgs(os.pullEvent())e.handle(c.getComputer(),J,K)end end;local function L()while _G.RUN_PROGRESS do local M=c.receive()if M~=nil then local u=nil;if c.c.Lookup.Progress[M.name]then u=D(M.src)if u~=nil then e.print(M.src,M.event,u,g.autoDiscover.get())if j[M.src.id]~=-1 then j[M.src.id]=os.clock()+settings.get(g.timeout.name)end end end;if u==nil then u=D(M.src,false)end;if u~=nil then if M.event.name==c.c.Event.Turtle.turtle_started then j[M.src.id]=os.clock()+settings.get(g.timeout.name)elseif M.event.name==c.c.Event.Turtle.paused or M.event.name==c.c.Event.Turtle.exited then j[M.src.id]=-1 end;e.handle(M.src,M.event.name,{M.event})end end end end;local function N()while _G.RUN_PROGRESS do sleep(1)local O=os.clock()for y,P in pairs(j)do if P~=-1 and O>P then local u=D({id=y})if u~=nil then e.updateStatus({id=y},"error:Progress Timeout")end end end end end;local function Q()local F=0;for R=1,multishell.getCount(),1 do if multishell.getTitle(R)=="progress"then F=F+1;if F>1 then return true end end end;return false end;local function S(o,t)local w={}local C={}if o~=nil then local T;T,t=s(t)a.expect(1,o,"string")a.expect(2,T,"table")o=string.lower(o)g.autoDiscover.set(false)w[o]=T;C[t]=o;v(w)else w,C=B()if Q()then error("Auto-discovery progress already running")return end end;H(C)c.initNetwork()if not c.online then error("Could not find modem")end;local U=o;for y,u in pairs(w)do o=U or y;t="term"if not d.h.isTerm(u)then t=peripheral.getName(u)end;b.info(string.format("Using %s output for %s",t,o))u.clear()u.setCursorPos(1,1)u.setTextColor(colors.white)u.write(string.format("Wait for %s...",o))u.setCursorPos(1,2)end;b.info("Listening for progress events...")k={outputMap=w,computerMap=C}parallel.waitForAny(I,L,N)b.s.print.set(true)term.setBackgroundColor(colors.black)term.setTextColor(colors.white)term.clear()term.setCursorPos(1,1)end;S(arg[1],arg[2])
