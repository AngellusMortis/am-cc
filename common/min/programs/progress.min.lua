local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.event")local d=require("am.ui")local e=require("am.progress")local f=require("am.core")local g={}g.autoDiscover={name="progress.autoDiscover",default=true,type="boolean"}g.outputMap={name="progress.outputMap",default={},type="table"}g.timeout={name="progress.timeout",default=30,type="number"}g=f.makeSettingWrapper(g)local h={width=13,height=7}local i={width=25,height=13}local j={}local k={}local l=false;_G.RUN_PROGRESS=true;_G.PROGRESS_SHOW_CLOSE=false;local function m()local n={}for o,p in ipairs(peripheral.getNames())do if peripheral.getType(p)=="monitor"then local q=peripheral.wrap(p)q.clear()q.setCursorPos(1,1)q.setTextScale(1.0)local r,s=q.getSize()if r>h.width and s>h.height then if r<i.width or s<i.height then q.setTextScale(0.5)elseif r>=i.width*5 and s>=i.height*5 then q.setTextScale(5.0)elseif r>=i.width*4 and s>=i.height*4 then q.setTextScale(4.0)elseif r>=i.width*3 and s>=i.height*3 then q.setTextScale(3.0)elseif r>=i.width*2 and s>=i.height*2 then q.setTextScale(2.0)end;n[p]=q end end end;return n end;local function t(u)if u==nil or u=="term"then return term,"term"end;a.expect(1,u,"string")local n=m()local v=n[u]if v==nil then error(string.format("Could not find montior at %s",u))end;return v,u end;local function w(x)a.expect(1,x,"table")local y={}for z,v in pairs(x)do local u;if d.h.isTerm(v)then u="term"else u=peripheral.getName(v)end;y[z]=u end;g.outputMap.set(y)end;local function A(B,u)a.expect(1,B,"table")a.expect(2,u,"string")local y=g.outputMap.get()y[B.id]=u;g.outputMap.set(y)local p=B.label or B.id;b.info(string.format("Adding %s as output for %s...",u,p))end;local function C()local y=g.outputMap.get()local x={}local D={}for z,u in pairs(y)do local v=t(u)if v~=nil then x[z]=v;D[u]=z end end;w(x)return x,D end;local function E(B,F)a.expect(1,B,"table")a.expect(2,F,"boolean","nil")if F==nil then F=g.autoDiscover.get()end;if l then return term end;if k.outputMap==nil or k.computerMap==nil then k.outputMap,k.computerMap=C()end;local v=k.outputMap[B.id]if v==nil and B.label~=nil then v=k.outputMap[string.lower(B.label)]end;if v~=nil or not F then return v end;local G=0;for u,v in pairs(m())do G=G+1;local H=k.computerMap[u]if H==nil then A(B,u)k.outputMap[B.id]=v;k.computerMap[u]=B.id;return v end end;if G==0 then return term end;return nil end;local function I(D)if D["term"]~=nil or _G.PROGRESS_SHOW_CLOSE then b.s.print.set(false)else b.s.print.set(true)term.clear()term.setCursorPos(1,1)term.setTextColor(colors.white)end end;local function J(z)j[z]=-1 end;local function K(z,L)if L==nil then L=false end;if j[z]~=-1 or L then j[z]=os.clock()+settings.get(g.timeout.name)end end;local function M()while _G.RUN_PROGRESS do local N,O=f.cleanEventArgs(os.pullEvent())e.handle(c.getComputer(),N,O)end end;local function P()while _G.RUN_PROGRESS do local Q=c.receive()if Q~=nil then local v=nil;if c.c.Lookup.Progress[Q.name]then v=E(Q.src)if v~=nil then e.print(Q.src,Q.event,v,l)K(Q.src.id)end end;if v==nil then v=E(Q.src,false)end;if v~=nil then if Q.event.name==c.c.Event.Pathfind.position then K(Q.src.id)elseif Q.event.name==c.c.Event.Turtle.turtle_started then K(Q.src.id,true)elseif Q.event.name==c.c.Event.Turtle.paused or Q.event.name==c.c.Event.Turtle.exited then J(Q.src.id)end;e.handle(Q.src,Q.event.name,{Q.event})end end end end;local function R()while _G.RUN_PROGRESS do sleep(1)local S=os.clock()for z,T in pairs(j)do if T~=-1 and S>T then local v=E({id=z})if v~=nil then e.updateStatus({id=z},"error:Progress Timeout")end end end end end;local function U()local G=0;for V=1,multishell.getCount(),1 do if multishell.getTitle(V)=="progress"then G=G+1;if G>1 then return true end end end;return false end;local function W(p,u)local x={}local D={}if p~=nil then local X;X,u=t(u)a.expect(1,p,"string")a.expect(2,X,"table")p=string.lower(p)g.autoDiscover.set(false)x[p]=X;D[u]=p;w(x)if u=="term"then _G.PROGRESS_SHOW_CLOSE=true end else if g.autoDiscover.get()then local n=m()if#n==0 then l=true;_G.PROGRESS_SHOW_CLOSE=true else x,D=C()end else x,D=C()_G.PROGRESS_SHOW_CLOSE=true end;if U()then error("Auto-Progress already running")return end end;I(D)c.initNetwork()if not c.online then error("Could not find modem")end;local Y=p;for z,v in pairs(x)do p=Y or z;u="term"if not d.h.isTerm(v)then u=peripheral.getName(v)end;b.info(string.format("Using %s output for %s",u,p))v.clear()v.setCursorPos(1,1)v.setTextColor(colors.white)v.write(string.format("Wait for %s...",p))v.setCursorPos(1,2)end;b.info("Listening for progress events...")k={outputMap=x,computerMap=D}parallel.waitForAny(M,P,R)b.s.print.set(true)term.setBackgroundColor(colors.black)term.setTextColor(colors.white)term.clear()term.setCursorPos(1,1)end;W(arg[1],arg[2])
