local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.event")local d=require("am.ui")local e=require("am.progress")local f=require("am.core")local g={}g.outputMap={name="progress.outputMap",default={},type="table"}g.timeout={name="progress.timeout",default=30,type="number"}g=f.makeSettingWrapper(g)local h=true;local i={width=13,height=7}local j={width=25,height=13}local k={}local l={}local function m()local n={}for o,p in ipairs(peripheral.getNames())do if peripheral.getType(p)=="monitor"then local q=peripheral.wrap(p)q.clear()q.setCursorPos(1,1)q.setTextScale(1.0)local r,s=q.getSize()if r>i.width and s>i.height then if r<j.width or s<j.height then q.setTextScale(0.5)elseif r>=j.width*5 and s>=j.height*5 then q.setTextScale(5.0)elseif r>=j.width*4 and s>=j.height*4 then q.setTextScale(4.0)elseif r>=j.width*3 and s>=j.height*3 then q.setTextScale(3.0)elseif r>=j.width*2 and s>=j.height*2 then q.setTextScale(2.0)end;n[p]=q end end end;return n end;local function t(u)if u==nil or u=="term"then return term,"term"end;a.expect(1,u,"string")local n=m()local v=n[u]if v==nil then error(string.format("Could not find montior at %s",u))end;return v,u end;local function w(x)a.expect(1,x,"table")local y={}for z,v in pairs(x)do local u=peripheral.getName(v)y[z]=u end;g.outputMap.set(y)end;local function A(B,u)a.expect(1,B,"table")a.expect(2,u,"string")local y=g.outputMap.get()y[B.id]=u;g.outputMap.set(y)local p=B.label or B.id;b.info(string.format("Adding %s as output for %s...",u,p))end;local function C()local y=g.outputMap.get()local x={}local D={}for z,u in pairs(y)do local v=t(u)if v~=nil then x[z]=v;D[u]=z end end;w(x)return x,D end;local function E(B,F)a.expect(1,B,"table")a.expect(2,F,"boolean","nil")if F==nil then F=h end;if l.outputMap==nil or l.computerMap==nil then l.outputMap,l.computerMap=C()end;local v=l.outputMap[B.id]or l.outputMap[string.lower(B.label)]if v~=nil or not F then return v end;local G=0;for u,v in pairs(m())do G=G+1;local H=l.computerMap[u]if H==nil then A(B,u)l.outputMap[B.id]=v;l.computerMap[u]=B.id;return v end end;if G==0 then return term end;return nil end;local function I(D)if D["term"]~=nil then b.s.print.set(false)else b.s.print.set(true)term.clear()term.setCursorPos(1,1)term.setTextColor(colors.white)end end;local function J()while true do local K,L=f.cleanEventArgs(os.pullEvent())e.handle(c.getComputer(),K,L)end end;local function M()while true do local z,N=rednet.receive()if N~=nil and N.type==c.type then local v=nil;if c.c.Lookup.Progress[N.name]then v=E(N.src)if v~=nil then e.print(N.src,N.event,v)if k[N.src.id]~=-1 then k[N.src.id]=os.clock()+settings.get(g.timeout.name)end end end;if v==nil then v=E(N.src,false)end;if v~=nil then if N.event.name==c.c.Event.Turtle.turtle_started then k[N.src.id]=os.clock()+settings.get(g.timeout.name)elseif N.event.name==c.c.Event.Turtle.turtle_paused or N.event.name==c.c.Event.Turtle.turtle_exited then k[N.src.id]=-1 end;e.handle(N.src,N.event.name,{N.event})end end end end;local function O()while true do sleep(1)local P=os.clock()for z,Q in pairs(k)do if Q~=-1 and P>Q then local v=E({id=z})if v~=nil then e.updateStatus({id=z},"error:Progress Timeout")end end end end end;local function R(p,u)local x={}local D={}if p~=nil then local S;S,u=t(u)a.expect(1,p,"string")a.expect(2,S,"table")p=string.lower(p)h=false;x[p]=S;D[u]=p else x,D=C()end;I(D)c.initNetwork()if not c.online then error("Could not find modem")end;for z,v in pairs(x)do u="term"if not d.h.isTerm(v)then u=peripheral.getName(v)end;b.info(string.format("Using %s output for %s",u,p))v.clear()v.setCursorPos(1,1)v.setTextColor(colors.white)v.write(string.format("Wait for %s...",p))v.setCursorPos(1,2)end;b.info("Listening for progress events...")l={outputMap=x,computerMap=D}parallel.waitForAny(J,M,O)end;R(arg[1],arg[2])
