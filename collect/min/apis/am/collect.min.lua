local a=require("cc.expect")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.log")local e=require("am.event")local f=require("am.turtle")local g=require("am.peripheral")local h={}local i=b:extend("am.c.CollectJob")h.CollectJob=i;function i:init(j,k,l)a.expect(1,j,"string")a.expect(2,k,"string")a.expect(3,l,"number","nil")self.from=j;self.to=k;self.interval=l or 60;return self end;local m={}m.job={name="collect.job",default=nil,type="table"}h.s=c.makeSettingWrapper(m)local n=e.c.RunType.Running;local o=true;local p=nil;local q=300;local function r()e.CollectProgressEvent(g.getRates()):send()end;local function s()local t=h.s.job.get()local j=peripheral.wrap(t.from)if j==nil then error("Could not locate from inventory")end;local k=peripheral.wrap(t.to)if k==nil then error("Could not locate to inventory")end;return j,k end;local function u()g.setStartTime()e.TurtleStartedEvent():send()local t=h.s.job.get()local j,v=s()while n==e.c.RunType.Running or n==e.c.RunType.Paused do if n==e.c.RunType.Running then local w={}for x,y in pairs(j.list())do y=j.getItemDetail(x)if not g.pullItem(t.from,t.to,y.count,nil,x)then f.error("Could not pull item")break end;w[#w+1]=y end;if#w>0 then g.addItems(w)r()end;sleep(t.interval)else sleep(5)end end;e.TurtleExitEvent(true):send()sleep(5)o=false end;local function z()p=os.startTimer(q)while o do local A=os.startTimer(3)local B,C=c.cleanEventArgs(os.pullEvent())if B=="timer"then if C[1]==p then g.calculateRate()r()p=os.startTimer(q)end end;os.cancelTimer(A)end end;local function D()e.initNetwork()if not e.online then return end;while o do local E=e.receive()if E~=nil then local F=os.getComputerID()if E.name==e.c.Event.Turtle.request_halt and E.event.id==F then n=e.c.RunType.Halted;d.info("Halting...")elseif E.name==e.c.Event.Turtle.request_pause and E.event.id==F then n=e.c.RunType.Paused;d.info("Pausing...")elseif E.name==e.c.Event.Turtle.request_continue and E.event.id==F then n=e.c.RunType.Running;d.info("Unpausing...")e.TurtleStartedEvent():send()end end end end;local function G()d.s.print.set(false)parallel.waitForAll(u,z,D)d.s.print.set(true)h.s.job.set(nil)end;h.CollectJob=i;h.collect=G;return h
