local a=require("cc.expect")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.log")local e=require("am.event")local f=require("am.peripheral")local g=require("am.progress")local h={}local i=b:extend("am.c.CollectJob")h.CollectJob=i;function i:init(j,k,l)a.expect(1,j,"string")a.expect(2,k,"string")a.expect(3,l,"number","nil")self.from=j;self.to=k;self.interval=l or 60;return self end;local m={}m.job={name="collect.job",default=nil}h.s=c.makeSettingWrapper(m)local n=e.c.RunType.Running;local o=true;local p=nil;local q=300;local r=""local function s()e.CollectProgressEvent(r,f.getRates()):send()end;local function t(u)r=u;s()end;local function v()local w=h.s.job.get()local j=peripheral.wrap(w.from)if j==nil then error("Could not locate from inventory")end;local k=peripheral.wrap(w.to)if k==nil then error("Could not locate to inventory")end;return j,k end;local function x()f.setStartTime()e.TurtleStartedEvent():send()local w=h.s.job.get()local j,y=v()while n==e.c.RunType.Running or n==e.c.RunType.Paused do t("")local z=5;if n==e.c.RunType.Running then local A={}for B,C in pairs(j.list())do C=j.getItemDetail(B)if not f.pullItem(w.from,w.to,C.count,nil,B)then e.ErrorEvent("Could not move item"):send()break end;A[#A+1]=C end;if#A>0 then f.addItems(A)s()z=w.interval end end;local D=n;while z>0 and n==D do z=z-0.5;sleep(0.5)end;if D==e.c.RunType.Running and n==e.c.RunType.Paused then e.TurtlePausedEvent():send()end end;e.TurtleExitEvent(true):send()sleep(5)o=false end;local function E()p=os.startTimer(q)while o do local F=os.startTimer(3)local G,H=c.cleanEventArgs(os.pullEvent())if G=="timer"then if H[1]==p then f.calculateRates()s()p=os.startTimer(q)end elseif G==e.c.Event.Common.error then t(string.format("error:%s",H[1].error))elseif G==e.c.Event.Turtle.exited then t("error:Stopped")n=e.c.RunType.Halted elseif G==e.c.Event.Turtle.request_pause then n=e.c.RunType.Paused;d.info("Pausing...")elseif G==e.c.Event.Turtle.request_halt then n=e.c.RunType.Halted;d.info("Halting...")elseif G==e.c.Event.Turtle.request_continue then n=e.c.RunType.Running;d.info("Unpausing...")e.TurtleStartedEvent():send()elseif G==e.c.Event.Turtle.paused then t("warning:Paused")elseif G==e.c.Event.Progress.collect then g.print(e.getComputer(),H[1])end;g.handle(e.getComputer(),G,H)os.cancelTimer(F)end end;local function I()e.initNetwork()if not e.online then return end;while o do local J=e.receive()if J~=nil then local K=os.getComputerID()if J.name==e.c.Event.Turtle.request_halt and J.event.id==K then n=e.c.RunType.Halted;d.info("Halting...")elseif J.name==e.c.Event.Turtle.request_pause and J.event.id==K then n=e.c.RunType.Paused;d.info("Pausing...")elseif J.name==e.c.Event.Turtle.request_continue and J.event.id==K then n=e.c.RunType.Running;d.info("Unpausing...")e.TurtleStartedEvent():send()end end end end;local function L()d.s.print.set(false)parallel.waitForAll(x,E,I)d.s.print.set(true)h.s.job.set(nil)term.clear()end;h.CollectJob=i;h.collect=L;return h
