local a=require("cc.expect")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.log")local e=require("am.event")local f=require("am.peripheral")local g={}local h=b:extend("am.c.CollectJob")g.CollectJob=h;function h:init(i,j,k)a.expect(1,i,"string")a.expect(2,j,"string")a.expect(3,k,"number","nil")self.from=i;self.to=j;self.interval=k or 60;return self end;local l={}l.job={name="collect.job",default=nil,type="table"}g.s=c.makeSettingWrapper(l)local m=e.c.RunType.Running;local n=true;local o=nil;local p=300;local function q()e.CollectProgressEvent(f.getRates()):send()end;local function r()local s=g.s.job.get()local i=peripheral.wrap(s.from)if i==nil then error("Could not locate from inventory")end;local j=peripheral.wrap(s.to)if j==nil then error("Could not locate to inventory")end;return i,j end;local function t()f.setStartTime()e.TurtleStartedEvent():send()local s=g.s.job.get()local i,u=r()while m==e.c.RunType.Running or m==e.c.RunType.Paused do if m==e.c.RunType.Running then local v={}for w,x in pairs(i.list())do x=i.getItemDetail(w)if not f.pullItem(s.from,s.to,x.count,nil,w)then break end;v[#v+1]=x end;if#v>0 then f.addItems(v)q()end;sleep(s.interval)else sleep(5)end end;e.TurtleExitEvent(true):send()sleep(5)n=false end;local function y()o=os.startTimer(p)while n do local z=os.startTimer(3)local A,B=c.cleanEventArgs(os.pullEvent())if A=="timer"then if B[1]==o then f.calculateRate()q()o=os.startTimer(p)end end;os.cancelTimer(z)end end;local function C()e.initNetwork()if not e.online then return end;while n do local D=e.receive()if D~=nil then local E=os.getComputerID()if D.name==e.c.Event.Turtle.request_halt and D.event.id==E then m=e.c.RunType.Halted;d.info("Halting...")elseif D.name==e.c.Event.Turtle.request_pause and D.event.id==E then m=e.c.RunType.Paused;d.info("Pausing...")elseif D.name==e.c.Event.Turtle.request_continue and D.event.id==E then m=e.c.RunType.Running;d.info("Unpausing...")e.TurtleStartedEvent():send()end end end end;local function F()d.s.print.set(false)parallel.waitForAll(t,y,C)d.s.print.set(true)g.s.job.set(nil)end;g.CollectJob=h;g.collect=F;return g
