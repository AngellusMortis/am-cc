local a=require("cc.expect")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.log")local e=require("am.event")local f=require("am.peripheral")local g=require("am.progress")local h={}local i=b:extend("am.c.CollectJob")h.CollectJob=i;function i:init(j,k,l)a.expect(1,j,"string")a.expect(2,k,"string")a.expect(3,l,"number","nil")self.from=j;self.to=k;self.interval=l or 60;return self end;local m={}m.job={name="collect.job",default=nil}h.s=c.makeSettingWrapper(m)local n=e.c.RunType.Running;local o=true;local p=nil;local q=300;local r=""local function s()e.CollectProgressEvent(r,f.getRates()):send()end;local function t(u)r=u;s()end;local function v()local w=h.s.job.get()local j=peripheral.wrap(w.from)if j==nil then error("Could not locate from inventory")end;local k=peripheral.wrap(w.to)if k==nil then error("Could not locate to inventory")end;return j,k end;local function x()f.setStartTime()e.TurtleStartedEvent():send()local w=h.s.job.get()local j,y=v()while n==e.c.RunType.Running or n==e.c.RunType.Paused do t("")local z=5;local A=10;if n==e.c.RunType.Running then local B={}for C,D in pairs(j.list())do D=j.getItemDetail(C)if not f.pullItem(w.from,w.to,D.count,nil,C)then e.ErrorEvent("Could not move item"):send()break end;B[#B+1]=D end;if#B>0 then f.addItems(B)s()z=w.interval;A=10 end end;local E=n;while z>0 and n==E do z=z-0.5;A=A-0.5;if A<=0 then e.PingEvent():send()A=10 end;sleep(0.5)end;if E==e.c.RunType.Running and n==e.c.RunType.Paused then e.TurtlePausedEvent():send()end end;e.TurtleExitEvent(true):send()sleep(5)o=false end;local function F()p=os.startTimer(q)while o do local G=os.startTimer(3)local H,I=c.cleanEventArgs(os.pullEvent())if H=="timer"then if I[1]==p then f.calculateRates()s()p=os.startTimer(q)end elseif H==e.c.Event.Common.error then t(string.format("error:%s",I[1].error))elseif H==e.c.Event.Turtle.exited then t("error:Stopped")n=e.c.RunType.Halted elseif H==e.c.Event.Turtle.request_pause then n=e.c.RunType.Paused;d.info("Pausing...")elseif H==e.c.Event.Turtle.request_halt then n=e.c.RunType.Halted;d.info("Halting...")elseif H==e.c.Event.Turtle.request_continue then n=e.c.RunType.Running;d.info("Unpausing...")e.TurtleStartedEvent():send()elseif H==e.c.Event.Turtle.paused then t("warning:Paused")elseif H==e.c.Event.Progress.collect then g.print(e.getComputer(),I[1])end;g.handle(e.getComputer(),H,I)os.cancelTimer(G)end end;local function J()e.initNetwork()if not e.online then return end;while o do local K=e.receive()if K~=nil then local L=os.getComputerID()if K.name==e.c.Event.Turtle.request_halt and K.event.id==L then n=e.c.RunType.Halted;d.info("Halting...")elseif K.name==e.c.Event.Turtle.request_pause and K.event.id==L then n=e.c.RunType.Paused;d.info("Pausing...")elseif K.name==e.c.Event.Turtle.request_continue and K.event.id==L then n=e.c.RunType.Running;d.info("Unpausing...")e.TurtleStartedEvent():send()end end end end;local function M()d.s.print.set(false)parallel.waitForAll(x,F,J)d.s.print.set(true)h.s.job.set(nil)term.clear()end;h.CollectJob=i;h.collect=M;return h
