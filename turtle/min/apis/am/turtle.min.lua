local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.pathfind")local d=require("am.event")local e=require("am.helpers")local f=require("am.core")local g={}local h={["minecraft:coal"]=true,["minecraft:coal_block"]=true,["minecraft:charcoal"]=true,["quark:charcoal_block"]=true,["mekanism:block_charcoal"]=true,["minecraft:lava_bucket"]=true}local i={}local j={}j.chestMap={name="chestMap",default={fuel="top",fill="right",dump="left"},type="table"}g.d=f.makeDataWrapper(j,"tc")local function k(l,m,n)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.expect(3,n,"boolean")a.range(l,-1,1)if m==nil then m=1 end;d.TurtleDigEvent(n,l,m):send()end;local function o(p)a.expect(1,p,"string")b.info(string.format("%s. Retrying...",p))d.TurtleErrorEvent(p):send()end;local function q()local r=peripheral.getNames()local s={}for t,u in ipairs(r)do local v=peripheral.wrap(u)if peripheral.hasType(v,"inventory")then s[#s+1]=v end end;return s end;local function w()local x=peripheral.find("modem",function(t,v)return not v.isWireless()end)if x==nil then return nil end;return x.getNameLocal()end;local function y()local z=nil;local A=nil;local B=nil;while z==nil or A==nil or B==nil do local s=q()for t,C in ipairs(s)do local D=C.list()local E=false;local F=false;for t,G in pairs(D)do E=true;if h[G.name]then F=true;B=peripheral.getName(C)end;break end;if not F then if E then A=peripheral.getName(C)else z=peripheral.getName(C)end end end;local H=true;if z==nil then H=false;o("No Dump Chest")elseif A==nil then H=false;o("No Fill Chest")elseif B==nil then H=false;o("No Fuel Chest")end;if not H then sleep(5)end end;g.d.chestMap.set({fuel=B,fill=A,dump=z})end;local function I(J,m)a.expect(2,m,"number","nil")if m~=nil then a.range(m,0,64)end;if m==0 then return end;local K=false;local L=g.d.chestMap.get()[J]if L=="top"then K=turtle.dropUp(m)elseif L=="bottom"then K=turtle.dropDown(m)elseif L=="left"then c.turnTo(d.c.Turtle.Direction.Left)K=turtle.drop(m)elseif L=="right"then c.turnTo(d.c.Turtle.Direction.Right)K=turtle.drop(m)else c.turnTo(d.c.Turtle.Direction.Front)local M=peripheral.wrap(L)local N=turtle.getSelectedSlot()local O=nil;local D=M.list()for C=1,M.size(),1 do if D[C]==nil then O=C;break end end;if O~=nil then K=pcall(function()M.pullItems(w(),N,m,O)end)end end;return K end;local function P(J,m,p)if m==nil then m=1 end;a.expect(2,m,"number")if p==nil then p=string.format("Failed to Push Item (%s)",J)end;while not I(J,m)do o(p)sleep(5)end end;local function Q(J,m)a.expect(2,m,"number","nil")if m~=nil then a.range(m,0,64)end;if m==0 then return end;local K=false;local L=g.d.chestMap.get()[J]if L=="top"then K=turtle.suckUp(m)elseif L=="bottom"then K=turtle.suckDown(m)elseif L=="left"then c.turnTo(d.c.Turtle.Direction.Left)K=turtle.suck(m)elseif L=="right"then c.turnTo(d.c.Turtle.Direction.Right)K=turtle.suck(m)else c.turnTo(d.c.Turtle.Direction.Front)local O=turtle.getSelectedSlot()local M=peripheral.wrap(L)local N=nil;for R,t in pairs(M.list())do N=R;break end;if N~=nil then K=pcall(function()M.pushItems(w(),N,m,O)end)end end;return K end;local function S(J,m,p)if m==nil then m=1 end;a.expect(2,m,"number")if p==nil then p=string.format("Failed to Pull Item (%s)",J)end;while not Q(J,m)do o(p)sleep(5)end end;local function T()local D={}for C=1,16,1 do D[C]=turtle.getItemDetail(C,true)end;return D end;local function U(V,W)if V==nil and W==nil then return nil end;if V~=nil and W==nil then V.count=-V.count;return V end;if V==nil and W~=nil then return W end;if V.name~=W.name then return W end;W.count=V.count-W.count;if W.count==0 then return nil end;return W end;local function X(Y)local Z={}for C=1,16,1 do local G=turtle.getItemDetail(C)Z[C]=U(Y[C],G)end;return Z end;local function _(m)a.expect(1,m,"number")a.range(m,1)local a0=turtle.getFuelLevel()if a0=="unlimited"then return true end;return a0>m end;local function a1()local a2=0;for C=1,16,1 do if turtle.getItemCount(C)==0 then a2=a2+1 end end;return a2 end;local function a3()return a1()>=4 end;local function a4(a5)local a6=d.TurtleEmptyEvent(false,nil)a6:send()if not c.atOrigin()then b.info("Returning to origin...")while not c.goToOrigin()do o("Cannot Return to Origin")sleep(5)end end;c.turnTo(d.c.Turtle.Direction.Front)b.info("Emptying inventory...")local a7=1;if a5 then a7=2 end;local D=T()for C=a7,16,1 do local a8=turtle.getItemCount(C)if a8>0 then turtle.select(C)P("dump",a8)end end;local a9=X(D)local aa={}for t,G in pairs(a9)do if G~=nil and G.count<0 then G.count=math.abs(G.count)aa[#aa+1]=G end end;a6.completed=true;a6.items=aa;a6:send()if a5 then a6=d.TurtleFetchFillEvent(false,nil)a6:send()D=T()turtle.select(1)local ab=turtle.getItemSpace()if ab>0 then S("fill",ab)end;a9=X(D)for t,G in ipairs(a9)do if G~=nil and G.count>0 then a6.completed=true;a6.item=G;a6:send()end end end;c.turnTo(d.c.Turtle.Direction.Front)end;local function ac(ad,a5)a.expect(1,ad,"boolean","nil")a.expect(2,a5,"boolean","nil")if ad==nil then ad=false end;if a5==nil then a5=true end;a4(a5)local ae=c.getPos()if ad and e.isOrigin(ae)then b.info("Returning...")while not c.goToReturn()do o("Cannot Return to Return")sleep(5)end end end;local function af(m)a.expect(1,m,"number")a.range(m,1)local ag=turtle.getFuelLevel()local ah=m-ag;local ai=nil;turtle.select(2)while m>ag do S("fuel",ai or 1,string.format("Need %d More Fuel",ah))turtle.refuel()if ai==nil then local aj=turtle.getFuelLevel()-ag;ai=math.ceil(ah/aj)if ai<1 then ai=nil elseif ai>64 then ai=64 end end;ag=turtle.getFuelLevel()ah=m-ag end;local a8=turtle.getItemCount(2)if a8>0 then P("fuel",a8)end;turtle.select(1)return true end;local function ak(m,al)a.expect(1,m,"number")a.expect(2,al,"boolean","nil")if al==nil then al=false end;a.range(m,1)if _(m)then return end;local am=turtle.getFuelLevel()local a6=d.TurtleRefuelEvent(false,m,am)a6:send()if al then ac()a6:send()end;local ae=c.getPos()if not e.isOrigin(ae)then b.info("Returning...")while not c.goToOrigin()do o("Cannot Return to Origin")sleep(5)end end;b.info(string.format("Refueling (%d)...",m))af(m)a6.completed=true;a6.newLevel=turtle.getFuelLevel()a6:send()end;local function an(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return""elseif l==d.c.Turtle.Direction.Down then return" Down"else return" Up"end end;local function ao(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.dig()elseif l==d.c.Turtle.Direction.Down then return turtle.digDown()else return turtle.digUp()end end;local function ap(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.place()elseif l==d.c.Turtle.Direction.Down then return turtle.placeDown()else return turtle.placeUp()end end;local function aq(l,m)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.drop(m)elseif l==d.c.Turtle.Direction.Down then return turtle.dropDown(m)else return turtle.dropUp(m)end end;local function ar(l,m)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.suck(m)elseif l==d.c.Turtle.Direction.Down then return turtle.suckDown(m)else return turtle.suckUp(m)end end;local function as(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.detect()elseif l==d.c.Turtle.Direction.Down then return turtle.detectDown()else return turtle.detectUp()end end;local function at(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.inspect()elseif l==d.c.Turtle.Direction.Down then return turtle.inspectDown()else return turtle.inspectUp()end end;local function au(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return c.forward()elseif l==d.c.Turtle.Direction.Down then return c.down()else return c.up()end end;local function av(l)a.expect(1,l,"number")a.range(l,-1,1)local aw="top"if l==d.c.Turtle.Direction.Front then aw="front"elseif l==d.c.Turtle.Direction.Down then aw="bottom"end;local ax=peripheral.wrap(aw)return ax~=nil end;local function ay()return av(d.c.Turtle.Direction.Front)end;local function az()return av(d.c.Turtle.Direction.Down)end;local function aA()return av(d.c.Turtle.Direction.Up)end;local function aB(l)a.expect(1,l,"number")a.range(l,-1,1)local K=false;local aC=nil;if not as(l)then K,aC=at(l)end;if not K then return false end;return K and aC.state.level==0 end;local function aD()return aB(d.c.Turtle.Direction.Front)end;local function aE()return aB(d.c.Turtle.Direction.Down)end;local function aF()return aB(d.c.Turtle.Direction.Up)end;local function aG(l)local K,aC=at(l)if not K then return false elseif aC.tags["forge:ores"]~=nil or string.find(aC.name,"_ore")then return true elseif string.find(aC.name,"raw_")and string.find(aC.name,"_block")then return true else for t,u in ipairs(i)do if u==aC.name then return true end end end;return false end;local function aH()return aG(d.c.Turtle.Direction.Front)end;local function aI()return aG(d.c.Turtle.Direction.Down)end;local function aJ()return aG(d.c.Turtle.Direction.Up)end;local function aK(l,aL)a.expect(1,l,"number")a.expect(2,aL,"boolean","nil")a.range(l,-1,1)if aL==nil then aL=false end;turtle.select(1)if turtle.getItemCount()==0 then ac(true)end;if aL and aG(l)then ao(l)end;ap(l)end;local function aM(aL)aK(d.c.Turtle.Direction.Front,aL)end;local function aN(aL)aK(d.c.Turtle.Direction.Down,aL)end;local function aO(aL)aK(d.c.Turtle.Direction.Up,aL)end;local function aP(l,m)if m==nil then m=1 end;a.expect(1,l,"number")a.expect(2,m,"number")a.range(l,-1,1)k(l,m,false)local aQ=false;for C=1,m,1 do local K=false;local aR=false;while not K do local aS=false;if as(l)then if not a3()then aS=true;aR=true;ac(true)end;if not aS and av(l)then aS=true;aR=true;o("Ignored Block"..an(l))sleep(5)end;if not aS and not ao(l)then local aT,aC=at(l)if aT and aC.name=="minecraft:bedrock"then return false end;aS=true;aR=true;o("Cannot Dig Block"..an(l))sleep(1)end;if not aS and aQ then aS=true;aR=true;sleep(1)end elseif aB(l)then aS=true;aR=true;if aQ then o("Infinite Source"..an(l))sleep(3)else aQ=true;aK(l)end end;if not aS and not au(l)then aS=true;aR=true;o("Cannot Move"..an(l))sleep(1)end;if not aS then K=true end end;if aR then d.TurtleErrorClearEvent():send()end end;k(l,m,true)return true end;local function aU(m)return aP(d.c.Turtle.Direction.Front,m)end;local function aV(m)return aP(d.c.Turtle.Direction.Down,m)end;local function aW(m)return aP(d.c.Turtle.Direction.Up,m)end;local function aX(l,m,p,aY)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if p==nil then p="Failed to Insert Item"..an(l)end;if aY==nil then aY="No Chest For Insert"..an(l)end;while not av(l)do o(aY)sleep(5)end;while not aq(l,m)do o(p)sleep(5)end end;local function aZ(m,p,aY)aX(d.c.Turtle.Direction.Front,m,p,aY)end;local function a_(m,p,aY)aX(d.c.Turtle.Direction.Down,m,p,aY)end;local function b0(m,p,aY)aX(d.c.Turtle.Direction.Up,m,p,aY)end;local function b1(l,m,p,aY)if m==nil then m=1 end;a.expect(1,l,"number")a.expect(2,m,"number")a.range(l,-1,1)if p==nil then p="Failed to Pull Item"..an(l)end;if aY==nil then aY="No Chest For Pull"..an(l)end;while not av(l)do o(aY)sleep(5)end;while not ar(l,m)do o(p)sleep(5)end end;local function b2(m,p,aY)return b1(d.c.Turtle.Direction.Front,m,p,aY)end;local function b3(m,p,aY)return b1(d.c.Turtle.Direction.Down,m,p,aY)end;local function b4(m,p,aY)return b1(d.c.Turtle.Direction.Up,m,p,aY)end;g.discoverChests=y;g.error=o;g.hasRequiredFuel=_;g.emptySlots=a1;g.hasRoom=a3;g.emptyInventory=ac;g.refuel=ak;g.isPerherial=ay;g.isPerherialDown=az;g.isPerherialUp=aA;g.isSourceBlock=aD;g.isSourceBlockDown=aE;g.isSourceBlockUp=aF;g.isOreBlock=aH;g.isOreBlockDown=aI;g.isOreBlockUp=aJ;g.fill=aM;g.fillDown=aN;g.fillUp=aO;g.dig=aU;g.digDown=aV;g.digUp=aW;g.insert=aZ;g.insertDown=a_;g.insertUp=b0;g.pull=b2;g.pullDown=b3;g.pullUp=b4;return g
