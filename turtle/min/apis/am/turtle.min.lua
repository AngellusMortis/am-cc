local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.pathfind")local d=require("am.event")local e=require("am.helpers")local f=require("am.core")local g={}local h={["minecraft:coal"]=true,["minecraft:coal_block"]=true,["minecraft:charcoal"]=true,["quark:charcoal_block"]=true,["minecraft:lava_bucket"]=true}local i={}local j={}j.chestMap={name="tc.chestMape",default={fuel="top",fill="right",dump="left"},type="table"}g.s=f.makeSettingWrapper(j)local function k(l,m,n)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.expect(3,n,"boolean")a.range(l,-1,1)if m==nil then m=1 end;d.TurtleDigEvent(n,l,m):send()end;local function o(p)a.expect(1,p,"string")b.info(string.format("%s. Retrying...",p))d.TurtleErrorEvent(p):send()end;local function q()local r=peripheral.getNames()local s={}for t,u in ipairs(r)do local v=peripheral.wrap(u)if peripheral.hasType(v,"inventory")then s[#s+1]=v end end;return s end;local function w()local x=peripheral.find("modem",function(t,v)return not v.isWireless()end)if x==nil then return nil end;return x.getNameLocal()end;local function y()local z=nil;local A=nil;local B=nil;while z==nil or A==nil or B==nil do local s=q()for t,C in ipairs(s)do local D=C.list()local E=false;local F=false;for t,G in pairs(D)do E=true;if h[G.name]then F=true;B=peripheral.getName(C)end;break end;if not F then if E then A=peripheral.getName(C)else z=peripheral.getName(C)end end end;local H=true;if z==nil then H=false;o("No Dump Chest")elseif A==nil then H=false;o("No Fill Chest")elseif B==nil then H=false;o("No Fuel Chest")end;if not H then sleep(5)end end;g.s.chestMap.set({fuel=B,fill=A,dump=z})end;local function I(J,m)a.expect(2,m,"number","nil")if m~=nil then a.range(m,0,64)end;if m==0 then return end;local K=false;local L=g.s.chestMap.get()[J]if L=="top"then K=turtle.dropUp(m)elseif L=="bottom"then K=turtle.dropDown(m)elseif L=="left"then c.turnTo(d.c.Turtle.Direction.Left)K=turtle.drop(m)elseif L=="right"then c.turnTo(d.c.Turtle.Direction.Right)K=turtle.drop(m)else c.turnTo(d.c.Turtle.Direction.Front)local M=peripheral.wrap(L)local N=nil;local D=M.list()for C=1,M.size(),1 do if D[C]==nil then N=C;break end end;local O=turtle.getSelectedSlot()if N~=nil then K=pcall(function()M.pullItems(w(),O,m,N)end)end end;return K end;local function P(J,m,p)if m==nil then m=1 end;a.expect(2,m,"number")if p==nil then p=string.format("Failed to Push Item (%s)",J)end;while not I(J,m)do o(p)sleep(5)end end;local function Q(J,m)a.expect(2,m,"number","nil")if m~=nil then a.range(m,0,64)end;if m==0 then return end;local K=false;local L=g.s.chestMap.get()[J]if L=="top"then K=turtle.suckUp(m)elseif L=="bottom"then K=turtle.suckDown(m)elseif L=="left"then c.turnTo(d.c.Turtle.Direction.Left)K=turtle.suck(m)elseif L=="right"then c.turnTo(d.c.Turtle.Direction.Right)K=turtle.suck(m)else c.turnTo(d.c.Turtle.Direction.Front)local M=peripheral.wrap(L)local O=nil;for R,t in pairs(M.list())do O=R;break end;local N=turtle.getSelectedSlot()if O~=nil then K=pcall(function()M.pushItems(w(),O,m,N)end)end end;return K end;local function S(J,m,p)if m==nil then m=1 end;a.expect(2,m,"number")if p==nil then p=string.format("Failed to Pull Item (%s)",J)end;while not Q(J,m)do o(p)sleep(5)end end;local function T()local D={}for C=1,16,1 do D[C]=turtle.getItemDetail(C,true)end;return D end;local function U(V,W)if V==nil and W==nil then return nil end;if V~=nil and W==nil then V.count=-V.count;return V end;if V==nil and W~=nil then return W end;if V.name~=W.name then return W end;W.count=V.count-W.count;if W.count==0 then return nil end;return W end;local function X(Y)local Z={}for C=1,16,1 do local G=turtle.getItemDetail(C)Z[C]=U(Y[C],G)end;return Z end;local function _(m)a.expect(1,m,"number")a.range(m,1)local a0=turtle.getFuelLevel()if a0=="unlimited"then return true end;return a0>m end;local function a1()local a2=0;for C=1,16,1 do if turtle.getItemCount(C)==0 then a2=a2+1 end end;return a2 end;local function a3()return a1()>=4 end;local function a4(a5)local a6=d.TurtleEmptyEvent(false,nil)a6:send()if not c.atOrigin()then b.info("Returning to origin...")while not c.goToOrigin()do o("Cannot Return to Origin")sleep(5)end end;c.turnTo(d.c.Turtle.Direction.Front)b.info("Emptying inventory...")local a7=1;if a5 then a7=2 end;local D=T()for C=a7,16,1 do if turtle.getItemCount(C)>0 then turtle.select(C)I("dump")end end;local a8=X(D)local a9={}for t,G in pairs(a8)do if G~=nil and G.count<0 then G.count=math.abs(G.count)a9[#a9+1]=G end end;a6.completed=true;a6.items=a9;a6:send()if a5 then a6=d.TurtleFetchFillEvent(false,nil)a6:send()D=T()turtle.select(1)Q("fill",turtle.getItemSpace())a8=X(D)for t,G in ipairs(a8)do if G~=nil and G.count>0 then a6.completed=true;a6.item=G;a6:send()end end end;c.turnTo(d.c.Turtle.Direction.Front)end;local function aa(ab,a5)a.expect(1,ab,"boolean","nil")a.expect(2,a5,"boolean","nil")if ab==nil then ab=false end;if a5==nil then a5=true end;a4(a5)local ac=c.s.position.get()if ab and e.isOrigin(ac)then b.info("Returning...")while not c.goToReturn()do o("Cannot Return to Return")sleep(5)end end end;local function ad(m)a.expect(1,m,"number")a.range(m,1)local ae=turtle.getFuelLevel()local af=m-ae;local ag=nil;turtle.select(2)while m>ae do S("fuel",ag or 1,string.format("Need %d More Fuel",af))turtle.refuel()if ag==nil then local ah=turtle.getFuelLevel()-ae;ag=math.ceil(af/ah)if ag<1 then ag=nil elseif ag>64 then ag=64 end end;ae=turtle.getFuelLevel()af=m-ae end;P("fuel")turtle.select(1)return true end;local function ai(m,aj)a.expect(1,m,"number")a.expect(2,aj,"boolean","nil")if aj==nil then aj=false end;a.range(m,1)if _(m)then return end;local ak=turtle.getFuelLevel()local a6=d.TurtleRefuelEvent(false,m,ak)a6:send()if aj then aa()a6:send()end;local ac=c.s.position.get()if not e.isOrigin(ac)then b.info("Returning...")while not c.goToOrigin()do o("Cannot Return to Origin")sleep(5)end end;b.info(string.format("Refueling (%d)...",m))ad(m)a6.completed=true;a6.newLevel=turtle.getFuelLevel()a6:send()end;local function al(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return""elseif l==d.c.Turtle.Direction.Down then return" Down"else return" Up"end end;local function am(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.dig()elseif l==d.c.Turtle.Direction.Down then return turtle.digDown()else return turtle.digUp()end end;local function an(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.place()elseif l==d.c.Turtle.Direction.Down then return turtle.placeDown()else return turtle.placeUp()end end;local function ao(l,m)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.drop(m)elseif l==d.c.Turtle.Direction.Down then return turtle.dropDown(m)else return turtle.dropUp(m)end end;local function ap(l,m)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.suck(m)elseif l==d.c.Turtle.Direction.Down then return turtle.suckDown(m)else return turtle.suckUp(m)end end;local function aq(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.detect()elseif l==d.c.Turtle.Direction.Down then return turtle.detectDown()else return turtle.detectUp()end end;local function ar(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.inspect()elseif l==d.c.Turtle.Direction.Down then return turtle.inspectDown()else return turtle.inspectUp()end end;local function as(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return c.forward()elseif l==d.c.Turtle.Direction.Down then return c.down()else return c.up()end end;local function at(l)a.expect(1,l,"number")a.range(l,-1,1)local au="top"if l==d.c.Turtle.Direction.Front then au="front"elseif l==d.c.Turtle.Direction.Down then au="bottom"end;local av=peripheral.wrap(au)return av~=nil end;local function aw()return at(d.c.Turtle.Direction.Front)end;local function ax()return at(d.c.Turtle.Direction.Down)end;local function ay()return at(d.c.Turtle.Direction.Up)end;local function az(l)a.expect(1,l,"number")a.range(l,-1,1)local K=false;local aA=nil;if not aq(l)then K,aA=ar(l)end;if not K then return false end;return K and aA.state.level==0 end;local function aB()return az(d.c.Turtle.Direction.Front)end;local function aC()return az(d.c.Turtle.Direction.Down)end;local function aD()return az(d.c.Turtle.Direction.Up)end;local function aE(l)local K,aA=ar(l)if not K then return false elseif aA.tags["forge:ores"]~=nil or string.find(aA.name,"_ore")then return true elseif string.find(aA.name,"raw_")and string.find(aA.name,"_block")then return true else for t,u in ipairs(i)do if u==aA.name then return true end end end;return false end;local function aF()return aE(d.c.Turtle.Direction.Front)end;local function aG()return aE(d.c.Turtle.Direction.Down)end;local function aH()return aE(d.c.Turtle.Direction.Up)end;local function aI(l,aJ)a.expect(1,l,"number")a.expect(2,aJ,"boolean","nil")a.range(l,-1,1)if aJ==nil then aJ=false end;turtle.select(1)if turtle.getItemCount()==0 then aa(true)end;if aJ and aE(l)then am(l)end;an(l)end;local function aK(aJ)aI(d.c.Turtle.Direction.Front,aJ)end;local function aL(aJ)aI(d.c.Turtle.Direction.Down,aJ)end;local function aM(aJ)aI(d.c.Turtle.Direction.Up,aJ)end;local function aN(l,m)if m==nil then m=1 end;a.expect(1,l,"number")a.expect(2,m,"number")a.range(l,-1,1)k(l,m,false)local aO=false;for C=1,m,1 do local K=false;local aP=false;while not K do local aQ=false;if aq(l)then if not a3()then aQ=true;aP=true;aa(true)end;if not aQ and at(l)then aQ=true;aP=true;o("Ignored Block"..al(l))sleep(5)end;if not aQ and not am(l)then local aR,aA=ar(l)if aR and aA.name=="minecraft:bedrock"then return false end;aQ=true;aP=true;o("Cannot Dig Block"..al(l))sleep(1)end;if not aQ and aO then aQ=true;aP=true;sleep(1)end elseif az(l)then aQ=true;aP=true;if aO then o("Infinite Source"..al(l))sleep(3)else aO=true;aI(l)end end;if not aQ and not as(l)then aQ=true;aP=true;o("Cannot Move"..al(l))sleep(1)end;if not aQ then K=true end end;if aP then d.TurtleErrorClearEvent():send()end end;k(l,m,true)return true end;local function aS(m)return aN(d.c.Turtle.Direction.Front,m)end;local function aT(m)return aN(d.c.Turtle.Direction.Down,m)end;local function aU(m)return aN(d.c.Turtle.Direction.Up,m)end;local function aV(l,m,p,aW)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if p==nil then p="Failed to Insert Item"..al(l)end;if aW==nil then aW="No Chest For Insert"..al(l)end;while not at(l)do o(aW)sleep(5)end;while not ao(l,m)do o(p)sleep(5)end end;local function aX(m,p,aW)aV(d.c.Turtle.Direction.Front,m,p,aW)end;local function aY(m,p,aW)aV(d.c.Turtle.Direction.Down,m,p,aW)end;local function aZ(m,p,aW)aV(d.c.Turtle.Direction.Up,m,p,aW)end;local function a_(l,m,p,aW)if m==nil then m=1 end;a.expect(1,l,"number")a.expect(2,m,"number")a.range(l,-1,1)if p==nil then p="Failed to Pull Item"..al(l)end;if aW==nil then aW="No Chest For Pull"..al(l)end;while not at(l)do o(aW)sleep(5)end;while not ap(l,m)do o(p)sleep(5)end end;local function b0(m,p,aW)return a_(d.c.Turtle.Direction.Front,m,p,aW)end;local function b1(m,p,aW)return a_(d.c.Turtle.Direction.Down,m,p,aW)end;local function b2(m,p,aW)return a_(d.c.Turtle.Direction.Up,m,p,aW)end;g.discoverChests=y;g.error=o;g.hasRequiredFuel=_;g.emptySlots=a1;g.hasRoom=a3;g.emptyInventory=aa;g.refuel=ai;g.isPerherial=aw;g.isPerherialDown=ax;g.isPerherialUp=ay;g.isSourceBlock=aB;g.isSourceBlockDown=aC;g.isSourceBlockUp=aD;g.isOreBlock=aF;g.isOreBlockDown=aG;g.isOreBlockUp=aH;g.fill=aK;g.fillDown=aL;g.fillUp=aM;g.dig=aS;g.digDown=aT;g.digUp=aU;g.insert=aX;g.insertDown=aY;g.insertUp=aZ;g.pull=b0;g.pullDown=b1;g.pullUp=b2;return g
