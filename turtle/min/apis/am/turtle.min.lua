local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.pathfind")local d=require("am.event")local e=require("am.helpers")local f=require("am.core")local g={}local h={["minecraft:coal"]=true,["minecraft:coal_block"]=true,["minecraft:charcoal"]=true,["quark:charcoal_block"]=true,["mekanism:block_charcoal"]=true,["minecraft:lava_bucket"]=true}local i={}local j={}j.chestMap={name="tc.chestMape",default={fuel="top",fill="right",dump="left"},type="table"}g.s=f.makeSettingWrapper(j)local function k(l,m,n)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.expect(3,n,"boolean")a.range(l,-1,1)if m==nil then m=1 end;d.TurtleDigEvent(n,l,m):send()end;local function o(p)a.expect(1,p,"string")b.info(string.format("%s. Retrying...",p))d.TurtleErrorEvent(p):send()end;local function q()local r=peripheral.getNames()local s={}for t,u in ipairs(r)do local v=peripheral.wrap(u)if peripheral.hasType(v,"inventory")then s[#s+1]=v end end;return s end;local function w()local x=peripheral.find("modem",function(t,v)return not v.isWireless()end)if x==nil then return nil end;return x.getNameLocal()end;local function y()local z=nil;local A=nil;local B=nil;while z==nil or A==nil or B==nil do local s=q()for t,C in ipairs(s)do local D=C.list()local E=false;local F=false;for t,G in pairs(D)do E=true;if h[G.name]then F=true;B=peripheral.getName(C)end;break end;if not F then if E then A=peripheral.getName(C)else z=peripheral.getName(C)end end end;local H=true;if z==nil then H=false;o("No Dump Chest")elseif A==nil then H=false;o("No Fill Chest")elseif B==nil then H=false;o("No Fuel Chest")end;if not H then sleep(5)end end;g.s.chestMap.set({fuel=B,fill=A,dump=z})end;local function I(J,m)a.expect(2,m,"number","nil")if m~=nil then a.range(m,0,64)end;if m==0 then return end;local K=false;local L=g.s.chestMap.get()[J]if L=="top"then K=turtle.dropUp(m)elseif L=="bottom"then K=turtle.dropDown(m)elseif L=="left"then c.turnTo(d.c.Turtle.Direction.Left)K=turtle.drop(m)elseif L=="right"then c.turnTo(d.c.Turtle.Direction.Right)K=turtle.drop(m)else c.turnTo(d.c.Turtle.Direction.Front)local M=peripheral.wrap(L)local N=nil;local D=M.list()for C=1,M.size(),1 do if D[C]==nil then N=C;break end end;local O=turtle.getSelectedSlot()if N~=nil then K=pcall(function()M.pullItems(w(),O,m,N)end)end end;return K end;local function P(J,m,p)if m==nil then m=1 end;a.expect(2,m,"number")if p==nil then p=string.format("Failed to Push Item (%s)",J)end;while not I(J,m)do o(p)sleep(5)end end;local function Q(J,m)a.expect(2,m,"number","nil")if m~=nil then a.range(m,0,64)end;if m==0 then return end;local K=false;local L=g.s.chestMap.get()[J]if L=="top"then K=turtle.suckUp(m)elseif L=="bottom"then K=turtle.suckDown(m)elseif L=="left"then c.turnTo(d.c.Turtle.Direction.Left)K=turtle.suck(m)elseif L=="right"then c.turnTo(d.c.Turtle.Direction.Right)K=turtle.suck(m)else c.turnTo(d.c.Turtle.Direction.Front)local M=peripheral.wrap(L)local O=nil;for R,t in pairs(M.list())do O=R;break end;local N=turtle.getSelectedSlot()if O~=nil then K=pcall(function()M.pushItems(w(),O,m,N)end)end end;return K end;local function S(J,m,p)if m==nil then m=1 end;a.expect(2,m,"number")if p==nil then p=string.format("Failed to Pull Item (%s)",J)end;while not Q(J,m)do o(p)sleep(5)end end;local function T()local D={}for C=1,16,1 do D[C]=turtle.getItemDetail(C,true)end;return D end;local function U(V,W)if V==nil and W==nil then return nil end;if V~=nil and W==nil then V.count=-V.count;return V end;if V==nil and W~=nil then return W end;if V.name~=W.name then return W end;W.count=V.count-W.count;if W.count==0 then return nil end;return W end;local function X(Y)local Z={}for C=1,16,1 do local G=turtle.getItemDetail(C)Z[C]=U(Y[C],G)end;return Z end;local function _(m)a.expect(1,m,"number")a.range(m,1)local a0=turtle.getFuelLevel()if a0=="unlimited"then return true end;return a0>m end;local function a1()local a2=0;for C=1,16,1 do if turtle.getItemCount(C)==0 then a2=a2+1 end end;return a2 end;local function a3()return a1()>=4 end;local function a4(a5)local a6=d.TurtleEmptyEvent(false,nil)a6:send()if not c.atOrigin()then b.info("Returning to origin...")while not c.goToOrigin()do o("Cannot Return to Origin")sleep(5)end end;c.turnTo(d.c.Turtle.Direction.Front)b.info("Emptying inventory...")local a7=1;if a5 then a7=2 end;local D=T()for C=a7,16,1 do if turtle.getItemCount(C)>0 then turtle.select(C)P("dump")end end;local a8=X(D)local a9={}for t,G in pairs(a8)do if G~=nil and G.count<0 then G.count=math.abs(G.count)a9[#a9+1]=G end end;a6.completed=true;a6.items=a9;a6:send()if a5 then a6=d.TurtleFetchFillEvent(false,nil)a6:send()D=T()turtle.select(1)local aa=turtle.getItemSpace()if aa>0 then S("fill",aa)end;a8=X(D)for t,G in ipairs(a8)do if G~=nil and G.count>0 then a6.completed=true;a6.item=G;a6:send()end end end;c.turnTo(d.c.Turtle.Direction.Front)end;local function ab(ac,a5)a.expect(1,ac,"boolean","nil")a.expect(2,a5,"boolean","nil")if ac==nil then ac=false end;if a5==nil then a5=true end;a4(a5)local ad=c.s.position.get()if ac and e.isOrigin(ad)then b.info("Returning...")while not c.goToReturn()do o("Cannot Return to Return")sleep(5)end end end;local function ae(m)a.expect(1,m,"number")a.range(m,1)local af=turtle.getFuelLevel()local ag=m-af;local ah=nil;turtle.select(2)while m>af do S("fuel",ah or 1,string.format("Need %d More Fuel",ag))turtle.refuel()if ah==nil then local ai=turtle.getFuelLevel()-af;ah=math.ceil(ag/ai)if ah<1 then ah=nil elseif ah>64 then ah=64 end end;af=turtle.getFuelLevel()ag=m-af end;P("fuel")turtle.select(1)return true end;local function aj(m,ak)a.expect(1,m,"number")a.expect(2,ak,"boolean","nil")if ak==nil then ak=false end;a.range(m,1)if _(m)then return end;local al=turtle.getFuelLevel()local a6=d.TurtleRefuelEvent(false,m,al)a6:send()if ak then ab()a6:send()end;local ad=c.s.position.get()if not e.isOrigin(ad)then b.info("Returning...")while not c.goToOrigin()do o("Cannot Return to Origin")sleep(5)end end;b.info(string.format("Refueling (%d)...",m))ae(m)a6.completed=true;a6.newLevel=turtle.getFuelLevel()a6:send()end;local function am(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return""elseif l==d.c.Turtle.Direction.Down then return" Down"else return" Up"end end;local function an(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.dig()elseif l==d.c.Turtle.Direction.Down then return turtle.digDown()else return turtle.digUp()end end;local function ao(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.place()elseif l==d.c.Turtle.Direction.Down then return turtle.placeDown()else return turtle.placeUp()end end;local function ap(l,m)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.drop(m)elseif l==d.c.Turtle.Direction.Down then return turtle.dropDown(m)else return turtle.dropUp(m)end end;local function aq(l,m)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.suck(m)elseif l==d.c.Turtle.Direction.Down then return turtle.suckDown(m)else return turtle.suckUp(m)end end;local function ar(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.detect()elseif l==d.c.Turtle.Direction.Down then return turtle.detectDown()else return turtle.detectUp()end end;local function as(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.inspect()elseif l==d.c.Turtle.Direction.Down then return turtle.inspectDown()else return turtle.inspectUp()end end;local function at(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return c.forward()elseif l==d.c.Turtle.Direction.Down then return c.down()else return c.up()end end;local function au(l)a.expect(1,l,"number")a.range(l,-1,1)local av="top"if l==d.c.Turtle.Direction.Front then av="front"elseif l==d.c.Turtle.Direction.Down then av="bottom"end;local aw=peripheral.wrap(av)return aw~=nil end;local function ax()return au(d.c.Turtle.Direction.Front)end;local function ay()return au(d.c.Turtle.Direction.Down)end;local function az()return au(d.c.Turtle.Direction.Up)end;local function aA(l)a.expect(1,l,"number")a.range(l,-1,1)local K=false;local aB=nil;if not ar(l)then K,aB=as(l)end;if not K then return false end;return K and aB.state.level==0 end;local function aC()return aA(d.c.Turtle.Direction.Front)end;local function aD()return aA(d.c.Turtle.Direction.Down)end;local function aE()return aA(d.c.Turtle.Direction.Up)end;local function aF(l)local K,aB=as(l)if not K then return false elseif aB.tags["forge:ores"]~=nil or string.find(aB.name,"_ore")then return true elseif string.find(aB.name,"raw_")and string.find(aB.name,"_block")then return true else for t,u in ipairs(i)do if u==aB.name then return true end end end;return false end;local function aG()return aF(d.c.Turtle.Direction.Front)end;local function aH()return aF(d.c.Turtle.Direction.Down)end;local function aI()return aF(d.c.Turtle.Direction.Up)end;local function aJ(l,aK)a.expect(1,l,"number")a.expect(2,aK,"boolean","nil")a.range(l,-1,1)if aK==nil then aK=false end;turtle.select(1)if turtle.getItemCount()==0 then ab(true)end;if aK and aF(l)then an(l)end;ao(l)end;local function aL(aK)aJ(d.c.Turtle.Direction.Front,aK)end;local function aM(aK)aJ(d.c.Turtle.Direction.Down,aK)end;local function aN(aK)aJ(d.c.Turtle.Direction.Up,aK)end;local function aO(l,m)if m==nil then m=1 end;a.expect(1,l,"number")a.expect(2,m,"number")a.range(l,-1,1)k(l,m,false)local aP=false;for C=1,m,1 do local K=false;local aQ=false;while not K do local aR=false;if ar(l)then if not a3()then aR=true;aQ=true;ab(true)end;if not aR and au(l)then aR=true;aQ=true;o("Ignored Block"..am(l))sleep(5)end;if not aR and not an(l)then local aS,aB=as(l)if aS and aB.name=="minecraft:bedrock"then return false end;aR=true;aQ=true;o("Cannot Dig Block"..am(l))sleep(1)end;if not aR and aP then aR=true;aQ=true;sleep(1)end elseif aA(l)then aR=true;aQ=true;if aP then o("Infinite Source"..am(l))sleep(3)else aP=true;aJ(l)end end;if not aR and not at(l)then aR=true;aQ=true;o("Cannot Move"..am(l))sleep(1)end;if not aR then K=true end end;if aQ then d.TurtleErrorClearEvent():send()end end;k(l,m,true)return true end;local function aT(m)return aO(d.c.Turtle.Direction.Front,m)end;local function aU(m)return aO(d.c.Turtle.Direction.Down,m)end;local function aV(m)return aO(d.c.Turtle.Direction.Up,m)end;local function aW(l,m,p,aX)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if p==nil then p="Failed to Insert Item"..am(l)end;if aX==nil then aX="No Chest For Insert"..am(l)end;while not au(l)do o(aX)sleep(5)end;while not ap(l,m)do o(p)sleep(5)end end;local function aY(m,p,aX)aW(d.c.Turtle.Direction.Front,m,p,aX)end;local function aZ(m,p,aX)aW(d.c.Turtle.Direction.Down,m,p,aX)end;local function a_(m,p,aX)aW(d.c.Turtle.Direction.Up,m,p,aX)end;local function b0(l,m,p,aX)if m==nil then m=1 end;a.expect(1,l,"number")a.expect(2,m,"number")a.range(l,-1,1)if p==nil then p="Failed to Pull Item"..am(l)end;if aX==nil then aX="No Chest For Pull"..am(l)end;while not au(l)do o(aX)sleep(5)end;while not aq(l,m)do o(p)sleep(5)end end;local function b1(m,p,aX)return b0(d.c.Turtle.Direction.Front,m,p,aX)end;local function b2(m,p,aX)return b0(d.c.Turtle.Direction.Down,m,p,aX)end;local function b3(m,p,aX)return b0(d.c.Turtle.Direction.Up,m,p,aX)end;g.discoverChests=y;g.error=o;g.hasRequiredFuel=_;g.emptySlots=a1;g.hasRoom=a3;g.emptyInventory=ab;g.refuel=aj;g.isPerherial=ax;g.isPerherialDown=ay;g.isPerherialUp=az;g.isSourceBlock=aC;g.isSourceBlockDown=aD;g.isSourceBlockUp=aE;g.isOreBlock=aG;g.isOreBlockDown=aH;g.isOreBlockUp=aI;g.fill=aL;g.fillDown=aM;g.fillUp=aN;g.dig=aT;g.digDown=aU;g.digUp=aV;g.insert=aY;g.insertDown=aZ;g.insertUp=a_;g.pull=b1;g.pullDown=b2;g.pullUp=b3;return g
