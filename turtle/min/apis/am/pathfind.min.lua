local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.helpers")local e=require("am.event")local f={}local g=b:extend("am.p.TurtlePosition")f.TurtlePosition=g;function g:init(vector,h)a.expect(1,vector,"table")a.expect(2,h,"number","nil")if h~=nil then a.range(h,1,4)end;d.requireVector(1,vector)g.super.init(self)self.v=vector;self.dir=h;return self end;function g:deserialize(i,j)a.expect(2,j,"boolean","nil")if j==nil then j=false end;if j then local k={}for l,m in ipairs(i)do k[l]=g(vector.new(m.v.x,m.v.y,m.v.z),m.dir)end;return k end;return g(vector.new(i.v.x,i.v.y,i.v.z),i.dir)end;function g:copy()return g(vector.new(self.v.x,self.v.y,self.v.z),self.dir)end;local n={}n.position={name="pathfind.position",default=g(vector.new(0,0,0),e.c.Turtle.Direction.Front),type="table"}n.nodes={name="pathfind.nodes",default={},type="table"}n.returnNodes={name="pathfind.returnNodes",default={},type="table"}f.s=c.makeSettingWrapper(n)f.s.position.get=function()return g.deserialize(nil,settings.get(f.s.position.name))end;f.s.position.set=function(m)settings.set(f.s.position.name,m)settings.save()e.PositionUpdateEvent(m):send()end;f.s.nodes.get=function()return g.deserialize(nil,settings.get(f.s.nodes.name),true)end;f.s.returnNodes.get=function()return g.deserialize(nil,settings.get(f.s.returnNodes.name),true)end;f.c={}f.c.Turtle=e.c.Turtle;f.c.DirType={Turn=1,Move=2}local function o(p,q)a.expect(2,q,"number","nil")if p==nil then return nil end;local r=false;local s=false;if q~=nil then a.range(q,1,2)if q==f.c.DirType.Turn then r=true else s=true end end;if not s and p=="left"then p=e.c.Turtle.Direction.Left elseif not s and p=="right"then p=e.c.Turtle.Direction.Right elseif p=="front"then p=e.c.Turtle.Direction.Front elseif not s and p=="back"then p=e.c.Turtle.Direction.Back elseif not r and p=="up"then p=e.c.Turtle.Direction.Up elseif not r and p=="down"then p=e.c.Turtle.Direction.Down else p=tonumber(p)end;a.expect(1,p,"number")a.range(p,-1,4)return p end;local function t(m,u)a.expect(1,m,"table","nil")a.expect(2,u,"boolean","nil")if m==nil then m=f.s.position.get():copy()end;if u==nil then u=false end;d.requirePosition(1,m)local v;if u then v=f.s.returnNodes.get()v[#v+1]=m;f.s.returnNodes.set(v)else v=f.s.nodes.get()v[#v+1]=m;f.s.nodes.set(v)end;e.NewNodeEvent(m,false):send()return m end;local function w(u)if u==nil then u=false end;local v;if u then v=f.s.returnNodes.get()else v=f.s.nodes.get()end;return v[#v]end;local function x(u)if u==nil then u=false end;local v;if u then f.s.returnNodes.set({})else f.s.nodes.set({})end;e.ResetNodesEvent(u):send()end;local function y()f.s.position.set(f.s.position.default:copy())x(false)x(true)e.ResetPathfindEvent():send()end;local function z()local m=f.s.position.get()if m.dir==e.c.Turtle.Direction.Front then m.v.z=m.v.z+1 elseif m.dir==e.c.Turtle.Direction.Right then m.v.x=m.v.x+1 elseif m.dir==e.c.Turtle.Direction.Back then m.v.z=m.v.z-1 else m.v.x=m.v.x-1 end;local A=turtle.forward()if A then f.s.position.set(m)end;return A end;local function B()local m=f.s.position.get()if m.dir==e.c.Turtle.Direction.Front then m.v.z=m.v.z-1 elseif m.dir==e.c.Turtle.Direction.Right then m.v.x=m.v.x-1 elseif m.dir==e.c.Turtle.Direction.Back then m.v.z=m.v.z+1 else m.v.x=m.v.x+1 end;local A=turtle.back()if A then f.s.position.set(m)end;return A end;local function C()local m=f.s.position.get()m.v.y=m.v.y+1;local A=turtle.up()if A then f.s.position.set(m)end;return A end;local function D()local m=f.s.position.get()m.v.y=m.v.y-1;local A=turtle.down()if A then f.s.position.set(m)end;return A end;local function E()local m=f.s.position.get()m.dir=m.dir-1;if m.dir<1 then m.dir=e.c.Turtle.Direction.Left end;local A=turtle.turnLeft()if A then f.s.position.set(m)end;return A end;local function F()local m=f.s.position.get()m.dir=m.dir+1;if m.dir>4 then m.dir=e.c.Turtle.Direction.Front end;local A=turtle.turnRight()if A then f.s.position.set(m)end;return A end;local G={e.c.Turtle.Direction.Left,e.c.Turtle.Direction.Front,e.c.Turtle.Direction.Right,e.c.Turtle.Direction.Back}local function H(p)a.expect(1,p,"number","nil")if p==nil then p=e.c.Turtle.Direction.Front end;a.range(p,1,4)local I=e.PathfindTurnEvent(p,nil)I:send()local m=f.s.position.get()local A=false;if G[m.dir]==p then A=E()else while m.dir~=p do A=F()if not A then break end;m=f.s.position.get()end end;I.success=A;I:send()return A end;local function J(p,K)a.expect(1,p,"number")a.expect(2,K,"number","nil")if K==nil then K=1 end;local L;if p==e.c.Turtle.Direction.Up then L=C elseif p==e.c.Turtle.Direction.Down then L=D elseif p==e.c.Turtle.Direction.Front then L=z else L=B end;local A=false;while K>0 do A=L()if not A then return false end;K=K-1 end;return true end;local function M(K)a.expect(1,K,"number","nil")return J(e.c.Turtle.Direction.Front,K)end;local function N(K)a.expect(1,K,"number","nil")return J(e.c.Turtle.Direction.Back,K)end;local function O(K)a.expect(1,K,"number","nil")return J(e.c.Turtle.Direction.Up,K)end;local function P(K)a.expect(1,K,"number","nil")return J(e.c.Turtle.Direction.Down,K)end;local function Q(K)a.expect(1,K,"number","nil")if K==nil then K=1 end;if K>0 then return M(K)else return N(math.abs(K))end end;local function R(K)a.expect(1,K,"number","nil")if K==nil then K=1 end;if K>0 then return O(K)else return P(math.abs(K))end end;local function S(T,U,V,p)a.expect(1,T,"number")a.expect(2,U,"number")a.expect(3,V,"number","nil")a.expect(4,p,"number","nil")if p~=nil then a.range(p,1,4)end;local W=f.s.position.get()if V==nil then V=W.v.y end;local X=g(vector.new(T,V,U),p)local I=e.PathfindGoToEvent(X,W,e.c.Turtle.GoTo.Node,nil)I:send()local A=true;local Y=-(W.v.x-T)if Y~=0 then if Y>0 then H(e.c.Turtle.Direction.Right)else H(e.c.Turtle.Direction.Left)Y=-Y end;A=Q(Y)and A end;local Z=-(W.v.z-U)if Z~=0 then if Z>0 then H(e.c.Turtle.Direction.Front)else H(e.c.Turtle.Direction.Back)Z=-Z end;A=Q(Z)and A end;local _=-(W.v.y-V)if _~=0 then A=R(_)and A end;if not A then local m=f.s.position.get()if W.v.x==m.v.x and W.v.y==m.v.y and W.v.z==m.v.z then I.success=false;I:send()return false end;return S(T,U,V,p)end;if A and p~=nil then H(p)end;I.success=A;I:send()return A end;local function a0(u)a.expect(1,u,"boolean","nil")if u==nil then u=false end;local v;if u then v=f.s.returnNodes.get()else v=f.s.nodes.get()end;if#v==0 then return false,{}end;local m=v[#v]local A=S(m.v.x,m.v.z,m.v.y,m.dir)if A then table.remove(v,#v)if u then v=f.s.returnNodes.set(v)else v=f.s.nodes.set(v)end end;return A,m end;local function a1()local W=f.s.position.get()local a2=f.s.position.default:copy()local I=e.PathfindGoToEvent(W,a2,e.c.Turtle.GoTo.Origin,nil)I:send()x(true)t(nil,true)local v=f.s.nodes.get()local A=true;local m=W;while#v>0 do A,m=a0()if not A then I.success=false;I:send()return false end;t(nil,true)v=f.s.nodes.get()end;x(false)A=S(a2.v.x,a2.v.z,a2.v.y,a2.dir)I.success=A;I:send()return A end;local function a3()local v=f.s.returnNodes.get()local X=nil;if#v>0 then X=v[1]end;if X==nil then return false end;local W=f.s.position.get()local I=e.PathfindGoToEvent(W,X,e.c.Turtle.GoTo.Return,nil)I:send()x(false)t()local A=true;local m=W;while#v>0 do A,m=a0(true)if not A then I.success=false;I:send()return false end;t()v=f.s.returnNodes.get()end;x(true)I.success=A;I:send()return true end;local function a4()local m=f.s.position.get()return m.v.x==0 and m.v.y==0 and m.v.z==0 end;f.dirFromString=o;f.addNode=t;f.getLastNode=w;f.resetNodes=x;f.resetPosition=y;f.forward=z;f.back=B;f.up=C;f.down=D;f.turnLeft=E;f.turnRight=F;f.turnTo=H;f.goForward=M;f.goBack=N;f.goUp=O;f.goDown=P;f.goHorizontal=Q;f.goVertical=R;f.goTo=S;f.goToPreviousNode=a0;f.goToOrigin=a1;f.goToReturn=a3;f.atOrigin=a4;return f
