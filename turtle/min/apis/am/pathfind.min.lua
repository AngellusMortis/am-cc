local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.helpers")local e=require("am.event")local f={}local g=b:extend("am.p.TurtlePosition")f.TurtlePosition=g;function g:init(vector,h)a.expect(1,vector,"table")a.expect(2,h,"number","nil")if h~=nil then a.range(h,1,4)end;d.requireVector(1,vector)g.super.init(self)self.v=vector;self.dir=h;return self end;function g:deserialize(i,j)a.expect(2,j,"boolean","nil")if j==nil then j=false end;if j then local k={}for l,m in ipairs(i)do k[l]=g(vector.new(m.v.x,m.v.y,m.v.z),m.dir)end;return k end;return g(vector.new(i.v.x,i.v.y,i.v.z),i.dir)end;function g:copy()return g(vector.new(self.v.x,self.v.y,self.v.z),self.dir)end;local n={}n.position={name="position",default=g(vector.new(0,0,0),e.c.Turtle.Direction.Front),type="table"}n.nodes={name="nodes",default={},type="table"}n.returnNodes={name="returnNodes",default={},type="table"}f.d=c.makeDataWrapper(n,"pf")f.c={}f.c.Turtle=e.c.Turtle;f.c.DirType={Turn=1,Move=2}local function o()return g.deserialize(nil,f.d.position.get())end;local function p(m)f.d.position.set(m)e.PositionUpdateEvent(m):send()end;local function q()return g.deserialize(nil,f.d.nodes.get(),true)end;local function r()return g.deserialize(nil,f.d.returnNodes.get(),true)end;local function s(t,u)a.expect(2,u,"number","nil")if t==nil then return nil end;local v=false;local w=false;if u~=nil then a.range(u,1,2)if u==f.c.DirType.Turn then v=true else w=true end end;if not w and t=="left"then t=e.c.Turtle.Direction.Left elseif not w and t=="right"then t=e.c.Turtle.Direction.Right elseif t=="front"then t=e.c.Turtle.Direction.Front elseif not w and t=="back"then t=e.c.Turtle.Direction.Back elseif not v and t=="up"then t=e.c.Turtle.Direction.Up elseif not v and t=="down"then t=e.c.Turtle.Direction.Down else t=tonumber(t)end;a.expect(1,t,"number")a.range(t,-1,4)return t end;local function x(m,y)a.expect(1,m,"table","nil")a.expect(2,y,"boolean","nil")if m==nil then m=o():copy()end;if y==nil then y=false end;d.requirePosition(1,m)local z;if y then z=r()z[#z+1]=m;f.d.returnNodes.set(z)else z=q()z[#z+1]=m;f.d.nodes.set(z)end;e.NewNodeEvent(m,false):send()return m end;local function A(y)if y==nil then y=false end;local z;if y then z=r()else z=q()end;return z[#z]end;local function B(y)if y==nil then y=false end;if y then f.d.returnNodes.set({})else f.d.nodes.set({})end;e.ResetNodesEvent(y):send()end;local function C()p(f.d.position.default:copy())B(false)B(true)e.ResetPathfindEvent():send()end;local function D()local m=o()if m.dir==e.c.Turtle.Direction.Front then m.v.z=m.v.z+1 elseif m.dir==e.c.Turtle.Direction.Right then m.v.x=m.v.x+1 elseif m.dir==e.c.Turtle.Direction.Back then m.v.z=m.v.z-1 else m.v.x=m.v.x-1 end;local E=turtle.forward()if E then p(m)end;return E end;local function F()local m=o()if m.dir==e.c.Turtle.Direction.Front then m.v.z=m.v.z-1 elseif m.dir==e.c.Turtle.Direction.Right then m.v.x=m.v.x-1 elseif m.dir==e.c.Turtle.Direction.Back then m.v.z=m.v.z+1 else m.v.x=m.v.x+1 end;local E=turtle.back()if E then p(m)end;return E end;local function G()local m=o()m.v.y=m.v.y+1;local E=turtle.up()if E then p(m)end;return E end;local function H()local m=o()m.v.y=m.v.y-1;local E=turtle.down()if E then p(m)end;return E end;local function I()local m=o()m.dir=m.dir-1;if m.dir<1 then m.dir=e.c.Turtle.Direction.Left end;local E=turtle.turnLeft()if E then p(m)end;return E end;local function J()local m=o()m.dir=m.dir+1;if m.dir>4 then m.dir=e.c.Turtle.Direction.Front end;local E=turtle.turnRight()if E then p(m)end;return E end;local K={e.c.Turtle.Direction.Left,e.c.Turtle.Direction.Front,e.c.Turtle.Direction.Right,e.c.Turtle.Direction.Back}local function L(t)a.expect(1,t,"number","nil")if t==nil then t=e.c.Turtle.Direction.Front end;a.range(t,1,4)local M=e.PathfindTurnEvent(t,nil)M:send()local m=o()local E=false;if K[m.dir]==t then E=I()else while m.dir~=t do E=J()if not E then break end;m=o()end end;M.success=E;M:send()return E end;local function N(t,O,P)a.expect(1,t,"number")a.expect(2,O,"number","nil")a.expect(3,P,"boolean","nil")if O==nil then O=1 end;if P==nil then P=false end;local Q;local R=nil;if t==e.c.Turtle.Direction.Up then Q=G;R=turtle.digUp elseif t==e.c.Turtle.Direction.Down then Q=H;R=turtle.digDown elseif t==e.c.Turtle.Direction.Front then Q=D;R=turtle.dig else Q=F end;local E=false;while O>0 do if P and R~=nil then R()end;E=Q()if not E then return false end;O=O-1 end;return true end;local function S(O,P)a.expect(1,O,"number","nil")a.expect(2,P,"boolean","nil")return N(e.c.Turtle.Direction.Front,O,P)end;local function T(O)a.expect(1,O,"number","nil")return N(e.c.Turtle.Direction.Back,O)end;local function U(O,P)a.expect(1,O,"number","nil")a.expect(2,P,"boolean","nil")return N(e.c.Turtle.Direction.Up,O,P)end;local function V(O,P)a.expect(1,O,"number","nil")a.expect(2,P,"boolean","nil")if P==nil then P=false end;return N(e.c.Turtle.Direction.Down,O,P)end;local function W(O,P)a.expect(1,O,"number","nil")a.expect(2,P,"boolean","nil")if O==nil then O=1 end;if P==nil then P=false end;if O>0 then return S(O,P)else return T(math.abs(O))end end;local function X(O,P)a.expect(1,O,"number","nil")a.expect(2,P,"boolean","nil")if O==nil then O=1 end;if P==nil then P=false end;if O>0 then return U(O,P)else return V(math.abs(O),P)end end;local function Y(Z,_,a0,t,P)a.expect(1,Z,"number")a.expect(2,_,"number")a.expect(3,a0,"number","nil")a.expect(4,t,"number","nil")a.expect(5,P,"boolean","nil")if t~=nil then a.range(t,1,4)end;if P==nil then P=false end;local a1=o()if a0==nil then a0=a1.v.y end;local a2=g(vector.new(Z,a0,_),t)local M=e.PathfindGoToEvent(a2,a1,e.c.Turtle.GoTo.Node,nil)M:send()local E=true;local a3=-(a1.v.x-Z)if a3~=0 then if a3>0 then L(e.c.Turtle.Direction.Right)else L(e.c.Turtle.Direction.Left)a3=-a3 end;E=W(a3,P)and E end;local a4=-(a1.v.z-_)if a4~=0 then if a4>0 then L(e.c.Turtle.Direction.Front)else L(e.c.Turtle.Direction.Back)a4=-a4 end;E=W(a4,P)and E end;local a5=-(a1.v.y-a0)if a5~=0 then E=X(a5,P)and E end;if not E then local m=o()if a1.v.x==m.v.x and a1.v.y==m.v.y and a1.v.z==m.v.z then M.success=false;M:send()return false end;return Y(Z,_,a0,t)end;if E and t~=nil then L(t)end;M.success=E;M:send()return E end;local function a6(y)a.expect(1,y,"boolean","nil")if y==nil then y=false end;local z;if y then z=r()else z=q()end;if#z==0 then return false,{}end;local m=z[#z]local E=Y(m.v.x,m.v.z,m.v.y,m.dir)if E then table.remove(z,#z)if y then z=f.d.returnNodes.set(z)else z=f.d.nodes.set(z)end end;return E,m end;local function a7()local a1=o()local a8=f.d.position.default:copy()local M=e.PathfindGoToEvent(a1,a8,e.c.Turtle.GoTo.Origin,nil)M:send()B(true)x(nil,true)local z=q()local E=true;local m=a1;while#z>0 do E,m=a6()if not E then M.success=false;M:send()return false end;x(nil,true)z=q()end;B(false)E=Y(a8.v.x,a8.v.z,a8.v.y,a8.dir)M.success=E;M:send()return E end;local function a9()local z=r()local a2=nil;if#z>0 then a2=z[1]end;if a2==nil then return false end;local a1=o()local M=e.PathfindGoToEvent(a1,a2,e.c.Turtle.GoTo.Return,nil)M:send()B(false)x()local E=true;local m=a1;while#z>0 do E,m=a6(true)if not E then M.success=false;M:send()return false end;x()z=r()end;B(true)M.success=E;M:send()return true end;local function aa()local m=o()return m.v.x==0 and m.v.y==0 and m.v.z==0 end;f.getPos=o;f.setPos=p;f.getReturnNodes=r;f.getNodes=q;f.dirFromString=s;f.addNode=x;f.getLastNode=A;f.resetNodes=B;f.resetPosition=C;f.forward=D;f.back=F;f.up=G;f.down=H;f.turnLeft=I;f.turnRight=J;f.turnTo=L;f.goForward=S;f.goBack=T;f.goUp=U;f.goDown=V;f.goHorizontal=W;f.goVertical=X;f.goTo=Y;f.goToPreviousNode=a6;f.goToOrigin=a7;f.goToReturn=a9;f.atOrigin=aa;return f
