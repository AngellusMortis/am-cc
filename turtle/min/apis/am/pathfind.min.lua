local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.helpers")local e=require("am.event")local f={}local g=b:extend("am.p.TurtlePosition")f.TurtlePosition=g;function g:init(vector,h)a.expect(1,vector,"table")a.expect(2,h,"number","nil")if h~=nil then a.range(h,1,4)end;d.requireVector(1,vector)g.super.init(self)self.v=vector;self.dir=h;return self end;function g:deserialize(i,j)a.expect(2,j,"boolean","nil")if j==nil then j=false end;if j then local k={}for l,m in ipairs(i)do k[l]=g(vector.new(m.v.x,m.v.y,m.v.z),m.dir)end;return k end;return g(vector.new(i.v.x,i.v.y,i.v.z),i.dir)end;function g:copy()return g(vector.new(self.v.x,self.v.y,self.v.z),self.dir)end;local n={}n.position={name="pathfind.position",default=g(vector.new(0,0,0),e.c.Turtle.Direction.Front),type="table"}n.nodes={name="pathfind.nodes",default={},type="table"}n.returnNodes={name="pathfind.returnNodes",default={},type="table"}f.s=c.makeSettingWrapper(n)f.s.position.get=function()return g.deserialize(nil,settings.get(f.s.position.name))end;f.s.position.set=function(m)settings.set(f.s.position.name,m)settings.save()e.PositionUpdateEvent(m):send()end;f.s.nodes.get=function()return g.deserialize(nil,settings.get(f.s.nodes.name),true)end;f.s.returnNodes.get=function()return g.deserialize(nil,settings.get(f.s.returnNodes.name),true)end;f.c={}f.c.Turtle=e.c.Turtle;f.c.DirType={Turn=1,Move=2}local function o(p,q)a.expect(2,q,"number","nil")if p==nil then return nil end;local r=false;local s=false;if q~=nil then a.range(q,1,2)if q==f.c.DirType.Turn then r=true else s=true end end;if not s and p=="left"then p=e.c.Turtle.Direction.Left elseif not s and p=="right"then p=e.c.Turtle.Direction.Right elseif p=="front"then p=e.c.Turtle.Direction.Front elseif not s and p=="back"then p=e.c.Turtle.Direction.Back elseif not r and p=="up"then p=e.c.Turtle.Direction.Up elseif not r and p=="down"then p=e.c.Turtle.Direction.Down else p=tonumber(p)end;a.expect(1,p,"number")a.range(p,-1,4)return p end;local function t(m,u)a.expect(1,m,"table","nil")a.expect(2,u,"boolean","nil")if m==nil then m=f.s.position.get():copy()end;if u==nil then u=false end;d.requirePosition(1,m)local v;if u then v=f.s.returnNodes.get()v[#v+1]=m;f.s.returnNodes.set(v)else v=f.s.nodes.get()v[#v+1]=m;f.s.nodes.set(v)end;e.NewNodeEvent(m,false):send()return m end;local function w(u)if u==nil then u=false end;local v;if u then v=f.s.returnNodes.get()else v=f.s.nodes.get()end;return v[#v]end;local function x(u)if u==nil then u=false end;local v;if u then f.s.returnNodes.set({})else f.s.nodes.set({})end;e.ResetNodesEvent(u):send()end;local function y()f.s.position.set(f.s.position.default:copy())x(false)x(true)e.ResetPathfindEvent():send()end;local function z()local m=f.s.position.get()if m.dir==e.c.Turtle.Direction.Front then m.v.z=m.v.z+1 elseif m.dir==e.c.Turtle.Direction.Right then m.v.x=m.v.x+1 elseif m.dir==e.c.Turtle.Direction.Back then m.v.z=m.v.z-1 else m.v.x=m.v.x-1 end;local A=turtle.forward()if A then f.s.position.set(m)end;return A end;local function B()local m=f.s.position.get()if m.dir==e.c.Turtle.Direction.Front then m.v.z=m.v.z-1 elseif m.dir==e.c.Turtle.Direction.Right then m.v.x=m.v.x-1 elseif m.dir==e.c.Turtle.Direction.Back then m.v.z=m.v.z+1 else m.v.x=m.v.x+1 end;local A=turtle.back()if A then f.s.position.set(m)end;return A end;local function C()local m=f.s.position.get()m.v.y=m.v.y+1;local A=turtle.up()if A then f.s.position.set(m)end;return A end;local function D()local m=f.s.position.get()m.v.y=m.v.y-1;local A=turtle.down()if A then f.s.position.set(m)end;return A end;local function E()local m=f.s.position.get()m.dir=m.dir-1;if m.dir<1 then m.dir=e.c.Turtle.Direction.Left end;local A=turtle.turnLeft()if A then f.s.position.set(m)end;return A end;local function F()local m=f.s.position.get()m.dir=m.dir+1;if m.dir>4 then m.dir=e.c.Turtle.Direction.Front end;local A=turtle.turnRight()if A then f.s.position.set(m)end;return A end;local G={e.c.Turtle.Direction.Left,e.c.Turtle.Direction.Front,e.c.Turtle.Direction.Right,e.c.Turtle.Direction.Back}local function H(p)a.expect(1,p,"number","nil")if p==nil then p=e.c.Turtle.Direction.Front end;a.range(p,1,4)local I=e.PathfindTurnEvent(p,nil)I:send()local m=f.s.position.get()local A=false;if G[m.dir]==p then A=E()else while m.dir~=p do A=F()if not A then break end;m=f.s.position.get()end end;I.success=A;I:send()return A end;local function J(p,K,L)a.expect(1,p,"number")a.expect(2,K,"number","nil")a.expect(3,L,"boolean","nil")if K==nil then K=1 end;if L==nil then L=false end;local M;local N=nil;if p==e.c.Turtle.Direction.Up then M=C;N=turtle.digUp elseif p==e.c.Turtle.Direction.Down then M=D;N=turtle.digDown elseif p==e.c.Turtle.Direction.Front then M=z;N=turtle.dig else M=B end;local A=false;while K>0 do if L and N~=nil then N()end;A=M()if not A then return false end;K=K-1 end;return true end;local function O(K,L)a.expect(1,K,"number","nil")a.expect(2,L,"boolean","nil")return J(e.c.Turtle.Direction.Front,K,L)end;local function P(K)a.expect(1,K,"number","nil")return J(e.c.Turtle.Direction.Back,K)end;local function Q(K,L)a.expect(1,K,"number","nil")a.expect(2,L,"boolean","nil")return J(e.c.Turtle.Direction.Up,K,L)end;local function R(K,L)a.expect(1,K,"number","nil")a.expect(2,L,"boolean","nil")if L==nil then L=false end;return J(e.c.Turtle.Direction.Down,K,L)end;local function S(K,L)a.expect(1,K,"number","nil")a.expect(2,L,"boolean","nil")if K==nil then K=1 end;if L==nil then L=false end;if K>0 then return O(K,L)else return P(math.abs(K))end end;local function T(K,L)a.expect(1,K,"number","nil")a.expect(2,L,"boolean","nil")if K==nil then K=1 end;if L==nil then L=false end;if K>0 then return Q(K,L)else return R(math.abs(K),L)end end;local function U(V,W,X,p,L)a.expect(1,V,"number")a.expect(2,W,"number")a.expect(3,X,"number","nil")a.expect(4,p,"number","nil")a.expect(5,L,"boolean","nil")if p~=nil then a.range(p,1,4)end;if L==nil then L=false end;local Y=f.s.position.get()if X==nil then X=Y.v.y end;local Z=g(vector.new(V,X,W),p)local I=e.PathfindGoToEvent(Z,Y,e.c.Turtle.GoTo.Node,nil)I:send()local A=true;local _=-(Y.v.x-V)if _~=0 then if _>0 then H(e.c.Turtle.Direction.Right)else H(e.c.Turtle.Direction.Left)_=-_ end;A=S(_,L)and A end;local a0=-(Y.v.z-W)if a0~=0 then if a0>0 then H(e.c.Turtle.Direction.Front)else H(e.c.Turtle.Direction.Back)a0=-a0 end;A=S(a0,L)and A end;local a1=-(Y.v.y-X)if a1~=0 then A=T(a1,L)and A end;if not A then local m=f.s.position.get()if Y.v.x==m.v.x and Y.v.y==m.v.y and Y.v.z==m.v.z then I.success=false;I:send()return false end;return U(V,W,X,p)end;if A and p~=nil then H(p)end;I.success=A;I:send()return A end;local function a2(u)a.expect(1,u,"boolean","nil")if u==nil then u=false end;local v;if u then v=f.s.returnNodes.get()else v=f.s.nodes.get()end;if#v==0 then return false,{}end;local m=v[#v]local A=U(m.v.x,m.v.z,m.v.y,m.dir)if A then table.remove(v,#v)if u then v=f.s.returnNodes.set(v)else v=f.s.nodes.set(v)end end;return A,m end;local function a3()local Y=f.s.position.get()local a4=f.s.position.default:copy()local I=e.PathfindGoToEvent(Y,a4,e.c.Turtle.GoTo.Origin,nil)I:send()x(true)t(nil,true)local v=f.s.nodes.get()local A=true;local m=Y;while#v>0 do A,m=a2()if not A then I.success=false;I:send()return false end;t(nil,true)v=f.s.nodes.get()end;x(false)A=U(a4.v.x,a4.v.z,a4.v.y,a4.dir)I.success=A;I:send()return A end;local function a5()local v=f.s.returnNodes.get()local Z=nil;if#v>0 then Z=v[1]end;if Z==nil then return false end;local Y=f.s.position.get()local I=e.PathfindGoToEvent(Y,Z,e.c.Turtle.GoTo.Return,nil)I:send()x(false)t()local A=true;local m=Y;while#v>0 do A,m=a2(true)if not A then I.success=false;I:send()return false end;t()v=f.s.returnNodes.get()end;x(true)I.success=A;I:send()return true end;local function a6()local m=f.s.position.get()return m.v.x==0 and m.v.y==0 and m.v.z==0 end;f.dirFromString=o;f.addNode=t;f.getLastNode=w;f.resetNodes=x;f.resetPosition=y;f.forward=z;f.back=B;f.up=C;f.down=D;f.turnLeft=E;f.turnRight=F;f.turnTo=H;f.goForward=O;f.goBack=P;f.goUp=Q;f.goDown=R;f.goHorizontal=S;f.goVertical=T;f.goTo=U;f.goToPreviousNode=a2;f.goToOrigin=a3;f.goToReturn=a5;f.atOrigin=a6;return f
