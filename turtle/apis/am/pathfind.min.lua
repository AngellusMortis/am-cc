local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui.base").BaseObject;local c=require("am.core")local d=require("am.helpers")local e=require("am.event")local f={}local g=b:extend("am.p.TurtlePosition")f.TurtlePosition=g;function g:init(vector,h)a.expect(1,vector,"table")a.expect(2,h,"number","nil")if h~=nil then a.range(h,1,4)end;d.requireVector(1,vector)g.super.init(self)self.v=vector;self.dir=h;return self end;function g:deserialize(i,j)a.expect(2,j,"boolean","nil")if j==nil then j=false end;if j then local k={}for l,m in ipairs(i)do k[l]=g(vector.new(m.v.x,m.v.y,m.v.z),m.dir)end;return k end;return g(vector.new(i.v.x,i.v.y,i.v.z),i.dir)end;function g:copy()return g(vector.new(self.v.x,self.v.y,self.v.z),self.dir)end;local n={}n.position={name="pathfind.position",default=g(vector.new(0,0,0),e.c.Turtle.Direction.Front),type="table"}n.nodes={name="pathfind.nodes",default={},type="table"}n.returnNodes={name="pathfind.returnNodes",default={},type="table"}f.s=c.makeSettingWrapper(n)f.s.position.get=function()return g.deserialize(nil,settings.get(f.s.position.name))end;f.s.nodes.get=function()return g.deserialize(nil,settings.get(f.s.nodes.name),true)end;f.s.returnNodes.get=function()return g.deserialize(nil,settings.get(f.s.returnNodes.name),true)end;f.c={}f.c.DirType={Turn=1,Move=2}local function o(p,q)a.expect(2,q,"number","nil")if p==nil then return nil end;local r=false;local s=false;if q~=nil then a.range(q,1,2)if q==f.c.DirType.Turn then r=true else s=true end end;if not s and p=="left"then p=e.c.Turtle.Direction.Left elseif not s and p=="right"then p=e.c.Turtle.Direction.Right elseif p=="front"then p=e.c.Turtle.Direction.Front elseif not s and p=="back"then p=e.c.Turtle.Direction.Back elseif not r and p=="up"then p=e.c.Turtle.Direction.Up elseif not r and p=="down"then p=e.c.Turtle.Direction.Down else p=tonumber(p)end;a.expect(1,p,"number")a.range(p,-1,4)return p end;local function t(m,u)a.expect(1,m,"table","nil")a.expect(2,u,"boolean","nil")if m==nil then m=f.s.position.get():copy()end;if u==nil then u=false end;d.requirePosition(1,m)local v;if u then v=f.s.returnNodes.get()v[#v+1]=m;f.s.returnNodes.set(v)else v=f.s.nodes.get()v[#v+1]=m;f.s.nodes.set(v)end;e.NewNodeEvent(m,false):send()return m end;local function w(u)if u==nil then u=false end;local v;if u then v=f.s.returnNodes.get()else v=f.s.nodes.get()end;return v[#v]end;local function x(u)if u==nil then u=false end;local v;if u then f.s.returnNodes.set({})else f.s.nodes.set({})end;e.ResetNodesEvent(u):send()end;local function y()f.s.position.set(f.s.position.default:copy())x(false)x(true)e.ResetPathfindEvent():send()end;local function z()local m=f.s.position.get()if m.dir==e.c.Turtle.Direction.Front then m.v.z=m.v.z+1 elseif m.dir==e.c.Turtle.Direction.Right then m.v.x=m.v.x+1 elseif m.dir==e.c.Turtle.Direction.Back then m.v.z=m.v.z-1 else m.v.x=m.v.x-1 end;local A=turtle.forward()if A then f.s.position.set(m)end;return A end;local function B()local m=f.s.position.get()if m.dir==e.c.Turtle.Direction.Front then m.v.z=m.v.z-1 elseif m.dir==e.c.Turtle.Direction.Right then m.v.x=m.v.x-1 elseif m.dir==e.c.Turtle.Direction.Back then m.v.z=m.v.z+1 else m.v.x=m.v.x+1 end;local A=turtle.back()if A then f.s.position.set(m)end;return A end;local function C()local m=f.s.position.get()m.v.y=m.v.y+1;local A=turtle.up()if A then f.s.position.set(m)end;return A end;local function D()local m=f.s.position.get()m.v.y=m.v.y-1;local A=turtle.down()if A then f.s.position.set(m)end;return A end;local function E()local m=f.s.position.get()m.dir=m.dir-1;if m.dir<1 then m.dir=e.c.Turtle.Direction.Left end;local A=turtle.turnLeft()if A then f.s.position.set(m)end;return A end;local function F()local m=f.s.position.get()m.dir=m.dir+1;if m.dir>4 then m.dir=e.c.Turtle.Direction.Front end;local A=turtle.turnRight()if A then f.s.position.set(m)end;return A end;local G={e.c.Turtle.Direction.Left,e.c.Turtle.Direction.Front,e.c.Turtle.Direction.Right,e.c.Turtle.Direction.Back}local function H(p)a.expect(1,p,"number","nil")if p==nil then p=e.c.Turtle.Direction.Front end;a.range(p,1,4)e.PathfindTurnEvent(p,nil):send()local m=f.s.position.get()local A=false;if G[m.dir]==p then A=E()else while m.dir~=p do A=F()if not A then break end;m=f.s.position.get()end end;e.PathfindTurnEvent(p,A):send()return A end;local function I(p,J)a.expect(1,p,"number")a.expect(2,J,"number","nil")if J==nil then J=1 end;local K;if p==e.c.Turtle.Direction.Up then K=C elseif p==e.c.Turtle.Direction.Down then K=D elseif p==e.c.Turtle.Direction.Front then K=z else K=B end;local A=false;while J>0 do A=K()if not A then return false end;J=J-1 end;return true end;local function L(J)a.expect(1,J,"number","nil")return I(e.c.Turtle.Direction.Front,J)end;local function M(J)a.expect(1,J,"number","nil")return I(e.c.Turtle.Direction.Back,J)end;local function N(J)a.expect(1,J,"number","nil")return I(e.c.Turtle.Direction.Up,J)end;local function O(J)a.expect(1,J,"number","nil")return I(e.c.Turtle.Direction.Down,J)end;local function P(J)a.expect(1,J,"number","nil")if J==nil then J=1 end;if J>0 then return L(J)else return M(math.abs(J))end end;local function Q(J)a.expect(1,J,"number","nil")if J==nil then J=1 end;if J>0 then return N(J)else return O(math.abs(J))end end;local function R(S,T,U,p)a.expect(1,S,"number")a.expect(2,T,"number")a.expect(3,U,"number","nil")a.expect(4,p,"number","nil")if p~=nil then a.range(p,1,4)end;local V=f.s.position.get()if U==nil then U=V.v.y end;local W=g(vector.new(S,U,T),p)e.PathfindGoToEvent(W,V,e.c.Turtle.GoTo.Node,nil):send()local A=true;local X=-(V.v.x-S)if X~=0 then if X>0 then H(e.c.Turtle.Direction.Right)else H(e.c.Turtle.Direction.Left)X=-X end;A=P(X)and A end;local Y=-(V.v.z-T)if Y~=0 then if Y>0 then H(e.c.Turtle.Direction.Front)else H(e.c.Turtle.Direction.Back)Y=-Y end;A=P(Y)and A end;local Z=-(V.v.y-U)if Z~=0 then A=Q(Z)and A end;if not A then local m=f.s.position.get()if V.v.x==m.v.x and V.v.y==m.v.y and V.v.z==m.v.z then e.PathfindGoToEvent(W,V,e.c.Turtle.GoTo.Node,false):send()return false end;return R(S,T,U,p)end;if A and p~=nil then H(p)end;e.PathfindGoToEvent(W,V,e.c.Turtle.GoTo.Node,A):send()return A end;local function _(u)a.expect(1,u,"boolean","nil")if u==nil then u=false end;local v;if u then v=f.s.returnNodes.get()else v=f.s.nodes.get()end;if#v==0 then return false,{}end;local m=v[#v]local A=R(m.v.x,m.v.z,m.v.y,m.dir)if A then table.remove(v,#v)if u then v=f.s.returnNodes.set(v)else v=f.s.nodes.set(v)end end;return A,m end;local function a0()local V=f.s.position.get()local a1=f.s.position.default:copy()e.PathfindGoToEvent(V,a1,e.c.Turtle.GoTo.Origin,nil):send()x(true)t(nil,true)local v=f.s.nodes.get()local A=true;local m=V;while#v>0 do A,m=_()if not A then e.PathfindGoToEvent(V,a1,e.c.Turtle.GoTo.Origin,false):send()return false end;t(nil,true)v=f.s.nodes.get()end;x(false)A=R(a1.v.x,a1.v.z,a1.v.y,a1.dir)e.PathfindGoToEvent(V,a1,e.c.Turtle.GoTo.Origin,A):send()return A end;local function a2()local v=f.s.returnNodes.get()local W=nil;if#v>0 then W=v[1]end;if W==nil then return false end;local V=f.s.position.get()e.PathfindGoToEvent(V,W,e.c.Turtle.GoTo.Return,nil):send()x(false)t()local A=true;local m=V;while#v>0 do A,m=_(true)if not A then e.PathfindGoToEvent(V,W,e.c.Turtle.GoTo.Return,false):send()return false end;t()v=f.s.returnNodes.get()end;x(true)e.PathfindGoToEvent(V,W,e.c.Turtle.GoTo.Return,true):send()return true end;f.dirFromString=o;f.addNode=t;f.getLastNode=w;f.resetNodes=x;f.resetPosition=y;f.forward=z;f.back=B;f.up=C;f.down=D;f.turnLeft=E;f.turnRight=F;f.turnTo=H;f.goForward=L;f.goBack=M;f.goUp=N;f.goDown=O;f.goHorizontal=P;f.goVertical=Q;f.goTo=R;f.goToPreviousNode=_;f.goToOrigin=a0;f.goToReturn=a2;return f
