local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.ui").b.BaseObject;local c=require("am.core")local d=require("am.helpers")local e=require("am.event")local f={}local g=b:extend("am.p.TurtlePosition")f.TurtlePosition=g;function g:init(vector,h)a.expect(1,vector,"table")a.expect(2,h,"number")a.range(h,1,4)d.requireVector(vector)g.super.init(self)self.v=vector;self.dir=h;return self end;function g:copy()return g(vector.new(self.v.x,self.v.y,self.v.z),self.dir)end;local i={}i.position={name="pathfind.position",default=g(vector.new(0,0,0),e.c.Turtle.Direction.Front),type="table"}i.nodes={name="pathfind.nodes",default={},type="table"}i.returnNodes={name="pathfind.returnNodes",default={},type="table"}f.s=c.makeSettingWrapper(i)f.c={}f.c.DirType{Turn=1,Move=2}local function j(k,l)a.expect(2,l,"number","nil")if k==nil then return nil end;local m=false;local n=false;if l~=nil then a.range(l,1,2)if l==f.c.DirType.Turn then m=true else n=true end end;if not n and k=="left"then k=e.c.Turtle.Direction.Left elseif not n and k=="right"then k=e.c.Turtle.Direction.Right elseif k=="front"then k=e.c.Turtle.Direction.Front elseif not n and k=="back"then k=e.c.Turtle.Direction.Back elseif not m and k=="up"then k=e.c.Turtle.Direction.Up elseif not m and k=="down"then k=e.c.Turtle.Direction.Down else k=tonumber(k)end;a.expect(1,k,"number")a.range(k,-1,4)return k end;local function o(p,q)a.expect(1,p,"table","nil")a.expect(2,q,"boolean","nil")if p==nil then p=f.s.position.get():copy()end;if q==nil then q=false end;d.requirePosition(p)local r;if q then r=f.s.returnNodes.get()r[#r+1]=p;f.s.returnNodes.set(r)else r=f.s.nodes.get()r[#r+1]=p;f.s.nodes.set(r)end;e.NewNodeEvent(p,false):send()return p end;local function s(q)if q==nil then q=false end;local r;if q then r=f.s.returnNodes.get()else r=f.s.nodes.get()end;return r[#r]end;local function t(q)if q==nil then q=false end;local r;if q then f.s.returnNodes.set({})else f.s.nodes.set({})end;e.ResetNodesEvent(q):send()end;local function u()f.s.position.set(f.s.default:copy())t(false)t(true)e.ResetPathfindEvent():send()end;local function v()local p=f.s.position.get()if p.dir==e.c.Turtle.Direction.Front then p.v.z=p.v.z+1 elseif p.dir==e.c.Turtle.Direction.Right then p.v.x=p.v.x+1 elseif p.dir==e.c.Turtle.Direction.Back then p.v.z=p.v.z-1 else p.v.x=p.v.x-1 end;local w=turtle.forward()if w then f.s.position.set(p)end;return w end;local function x()local p=f.s.position.get()if p.dir==e.c.Turtle.Direction.Front then p.v.z=p.v.z-1 elseif p.dir==e.c.Turtle.Direction.Right then p.v.x=p.v.x-1 elseif p.dir==e.c.Turtle.Direction.Back then p.v.z=p.v.z+1 else p.v.x=p.v.x+1 end;local w=turtle.back()if w then f.s.position.set(p)end;return w end;local function y()local p=f.s.position.get()p.v.y=p.v.y+1;local w=turtle.up()if w then f.s.position.set(p)end;return w end;local function z()local p=f.s.position.get()p.v.y=p.v.y-1;local w=turtle.down()if w then f.s.position.set(p)end;return w end;local function A()local p=f.s.position.get()p.dir=p.dir-1;if p.dir<1 then p.dir=e.c.Turtle.Direction.Left end;local w=turtle.turnLeft()if w then f.s.position.set(p)end;return w end;local function B()local p=f.s.position.get()p.dir=p.dir+1;if p.dir>4 then p.dir=e.c.Turtle.Direction.Front end;local w=turtle.turnRight()if w then f.s.position.set(p)end;return w end;local C={e.c.Turtle.Direction.Left,e.c.Turtle.Direction.Front,e.c.Turtle.Direction.Right,e.c.Turtle.Direction.Back}local function D(k)a.expect(1,k,"number","nil")if k==nil then k=e.c.Turtle.Direction.Front end;a.range(k,1,4)e.PathfindTurnEvent(k,nil):send()local p=f.s.position.get()local w=false;if C[p.dir]==k then w=A()else while p.dir~=k do w=B()if not w then break end;p=f.s.position.get()end end;e.PathfindTurnEvent(k,w):send()return w end;local function E(k,F)a.expect(1,k,"number")a.expect(2,F,"number","nil")a.range(k,-1,1)if F==nil then F=1 end;local G;if k==e.c.Turtle.Direction.Up then G=y elseif k==e.c.Turtle.Direction.Down then G=z elseif k==e.c.Turtle.Direction.Front then G=v else G=x end;local w=false;while F>0 do w=G()if not w then return false end;F=F-1 end;return true end;local function H(F)a.expect(1,F,"number","nil")return E(e.c.Turtle.Direction.Front,F)end;local function I(F)a.expect(1,F,"number","nil")return E(e.c.Turtle.Direction.Back,F)end;local function J(F)a.expect(1,F,"number","nil")return E(e.c.Turtle.Direction.Up,F)end;local function K(F)a.expect(1,F,"number","nil")return E(e.c.Turtle.Direction.Down,F)end;local function L(F)a.expect(1,F,"number","nil")if F==nil then F=1 end;if F>0 then return H(F)else return I(math.abs(F))end end;local function M(F)a.expect(1,F,"number","nil")if F==nil then F=1 end;if F>0 then return J(F)else return K(math.abs(F))end end;local function N(O,P,Q,k)a.expect(1,O,"number")a.expect(2,P,"number")a.expect(3,Q,"number","nil")a.expect(4,k,"number","nil")if k~=nil then a.range(k,1,4)end;local R=f.s.position.get()if Q==nil then Q=R.y end;local S=g(vector.new(O,Q,P),k)e.PathfindGoToEvent(S,R,e.c.Turtle.GoTo.Node,nil):send()local w=true;local T=-(R.x-O)if T~=0 then if T>0 then D(e.c.Turtle.Direction.Right)else D(e.c.Turtle.Direction.Left)T=-T end;w=L(T)and w end;local U=-(R.z-P)if U~=0 then if U>0 then D(e.c.Turtle.Direction.Front)else D(e.c.Turtle.Direction.Back)U=-U end;w=L(U)and w end;local V=-(R.y-Q)if V~=0 then w=M(V)and w end;if not w then local p=f.s.position.get()if R.x==p.x and R.y==p.y and R.z==p.z then e.PathfindGoToEvent(S,R,e.c.Turtle.GoTo.Node,false):send()return false end;return N(O,P,Q,k)end;if w and k~=nil then D(k)end;e.PathfindGoToEvent(S,R,e.c.Turtle.GoTo.Node,w):send()return w end;local function W(q)a.expect(1,q,"boolean","nil")if q==nil then q=false end;local r;if q then r=f.s.returnNodes.get()else r=f.s.nodes.get()end;if#r==0 then return false,{}end;local p=r[#r]local w=N(p.x,p.z,p.y,p.dir)if w then table.remove(r,#r)if q then r=f.s.returnNodes.set(r)else r=f.s.nodes.set(r)end end;return w,p end;local function X()local R=f.s.position.get()local Y=f.s.position.default:copy()e.PathfindGoToEvent(R,Y,e.c.Turtle.GoTo.Origin,nil):send()t(true)o(nil,true)local r=f.s.nodes.get()local w=true;local p=R;while#r>0 do w,p=W()if not w then e.PathfindGoToEvent(R,Y,e.c.Turtle.GoTo.Origin,false):send()return false end;o(nil,true)r=f.s.node.get()end;t(false)w=N(Y.v.x,Y.v.z,Y.v.y,Y.dir)e.PathfindGoToEvent(R,Y,e.c.Turtle.GoTo.Origin,w):send()return w end;local function Z()local r=f.s.returnNodes.get()local S=nil;if#r>0 then S=r[1]end;local R=f.s.position.get()e.PathfindGoToEvent(R,S,e.c.Turtle.GoTo.Return,nil):send()if S==nil then e.PathfindGoToEvent(R,S,e.c.Turtle.GoTo.Return,false):send()return false end;t(false)o()local w=true;local p=R;while#r>0 do w,p=W(true)if not w then e.PathfindGoToEvent(R,S,e.c.Turtle.GoTo.Return,false):send()return false end;o()r=f.s.returnNodes.get()end;t(true)e.PathfindGoToEvent(R,S,e.c.Turtle.GoTo.Return,true):send()return true end;f.dirFromString=j;f.addNode=o;f.getLastNode=s;f.resetNodes=t;f.resetPosition=u;f.forward=v;f.back=x;f.up=y;f.down=z;f.turnLeft=A;f.turnRight=B;f.turnTo=D;f.goForward=H;f.goBack=I;f.goUp=J;f.goDown=K;f.goTo=N;f.goToPreviousNode=W;return f
