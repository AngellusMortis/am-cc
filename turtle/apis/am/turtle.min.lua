local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("log")local c=require("pathfind")local d=require("eventLib")local e={}local f={"forge:chests","forge:barrels"}local g={}local function h(i,j,k)a.expect(1,i,"number")a.expect(2,j,"number","nil")a.expect(3,k,"boolean")a.range(i,-1,1)if j==nil then j=1 end;d.TurtleDigEvent(k,i,j):send()end;local function l(m)a.expect(1,m,"string")b.info(string.format("%s. Retrying...",m))d.TurtleErrorEvent(m):send()end;local function n()local o={}for p=1,16,1 do o[p]=turtle.getItemDetail(p)end;return o end;local function q(r,s)if r==nil and s==nil then return nil end;if r~=nil and s==nil then return nil end;if r==nil and s~=nil then return s end;if r.name~=s.name then return s end;s.count=r.count-s.count;return s end;local function t(u)local v={}for p=1,16,1 do local w=turtle.getItemDetail(p)v[p]=q(u[p],w)end;return v end;local function x(j)a.expect(1,j,"number")a.range(j,1)local y=turtle.getFuelLevel()if y=="unlimited"then return true end;return y>j end;local function z()local A=0;for p=1,16,1 do if turtle.getItemCount(p)==0 then A=A+1 end end;return A end;local function B()return z()>=4 end;local function C()d.TurtleEmptyEvent(false,nil):send()b("Returning to origin...")while not c.goToOrigin()do l("Cannot Return to Origin")sleep(5)end;c.turnTo(d.c.Turtle.Direction.Left)b("Emptying inventory...")local o=n()for p=2,16,1 do if turtle.getItemCount(p)>0 then turtle.select(p)e.insert(nil,nil,"Missing Drop Chest")end end;local D=t(o)local E={}for F,w in ipairs(D)do if w~=nil and w.count<0 then w.count=math.abs(w.count)E[#E+1]=E end end;d.TurtleEmptyEvent(true,E):send()d.TurtleFetchFillEvent(false,nil):send()o=n()turtle.select(1)c.turnTo(d.c.Turtle.Direction.Right)e.pull(turtle.getItemSpace(),"Failed to Pull Fill Block","Missing Fill Chest")c.turnTo(d.c.Turtle.Direction.Front)D=t(o)for F,w in ipairs(D)do if w~=nil and w.count>0 then d.TurtleFetchFillEvent(true,w):send()end end end;local function G(H)a.expect(1,H,"boolean","nil")if H==nil then H=false end;C()if H then b.info("Returning...")while not c.goToReturn()do l("Cannot Return to Return")sleep(5)end end end;local function I(j)a.expect(1,j,"number")a.range(j,1)local J=j-turtle.getFuelLevel()local K="Missing Refuel Chest Above"turtle.select(2)while j>turtle.getFuelLevel()do e.pullUp(nil,string.format("Need %d More Fuel",J),K)turtle.refuel()J=j-turtle.getFuelLevel()end;turtle.dropUp()turtle.select(1)return true end;local function L(j,M)a.expect(1,j,"number")a.expect(2,M,"boolean","nil")if M==nil then M=false end;a.range(j,1)if x(j)then return end;local N=turtle.getFuelLevel()d.TurtleRefuelEvent(false,j,N):send()if M then G()d.TurtleRefuelEvent(false,j,N):send()end;b.info(string.format("Refueling (%d)...",j))L(j)d.TurtleRefuelEvent(true,j,N,turtle.getFuelLevel()):send()end;local function O(i)a.expect(1,i,"number")a.range(i,-1,1)if i==d.c.Turtle.Direction.Front then return""elseif i==d.c.Turtle.Direction.Down then return" Down"else return" Up"end end;local function P(i)a.expect(1,i,"number")a.range(i,-1,1)if i==d.c.Turtle.Direction.Front then return turtle.dig()elseif i==d.c.Turtle.Direction.Down then return turtle.digDown()else return turtle.digUp()end end;local function Q(i)a.expect(1,i,"number")a.range(i,-1,1)if i==d.c.Turtle.Direction.Front then return turtle.place()elseif i==d.c.Turtle.Direction.Down then return turtle.placeDown()else return turtle.placeUp()end end;local function R(i,j)a.expect(1,i,"number")a.expect(2,j,"number","nil")a.range(i,-1,1)if i==d.c.Turtle.Direction.Front then return turtle.drop(j)elseif i==d.c.Turtle.Direction.Down then return turtle.dropDown(j)else return turtle.dropUp(j)end end;local function S(i,j)a.expect(1,i,"number")a.expect(2,j,"number","nil")a.range(i,-1,1)if i==d.c.Turtle.Direction.Front then return turtle.suck(j)elseif i==d.c.Turtle.Direction.Down then return turtle.suckDown(j)else return turtle.suckUp(j)end end;local function T(i)a.expect(1,i,"number")a.range(i,-1,1)if i==d.c.Turtle.Direction.Front then return turtle.detect()elseif i==d.c.Turtle.Direction.Down then return turtle.detectDown()else return turtle.detectUp()end end;local function U(i)a.expect(1,i,"number")a.range(i,-1,1)if i==d.c.Turtle.Direction.Front then return turtle.inspect()elseif i==d.c.Turtle.Direction.Down then return turtle.inspectDown()else return turtle.inspectUp()end end;local function V(i)a.expect(1,i,"number")a.range(i,-1,1)if i==d.c.Turtle.Direction.Front then return c.forward()elseif i==d.c.Turtle.Direction.Down then return c.down()else return c.up()end end;local function W(i)a.expect(1,i,"number")a.range(i,-1,1)local success,X=U(i)if not success then return false end;for F,Y in ipairs(f)do if X.tags[Y]~=nil then return true end end;return false end;local function Z()return W(d.c.Turtle.Direction.Front)end;local function _()return W(d.c.Turtle.Direction.Down)end;local function a0()return W(d.c.Turtle.Direction.Up)end;local function a1(i)a.expect(1,i,"number")a.range(i,-1,1)local success=false;local X=nil;if not T(i)then success,X=U(i)end;if not success then return false end;return success and X.state.level==0 end;local function a2()return a1(d.c.Turtle.Direction.Front)end;local function a3()return a1(d.c.Turtle.Direction.Down)end;local function a4()return a1(d.c.Turtle.Direction.Up)end;local function a5(i)local success,X=U(i)if not success then return false elseif X.tags["forge:ores"]~=nil or string.find(X.name,"_ore")then return true elseif string.find(X.name,"raw_")and string.find(X.name,"_block")then return true else for F,a6 in ipairs(g)do if a6==X.name then return true end end end;return false end;local function a7()return a5(d.c.Turtle.Direction.Front)end;local function a8()return a5(d.c.Turtle.Direction.Down)end;local function a9()return a5(d.c.Turtle.Direction.Up)end;local function aa(i,ab)a.expect(1,i,"number")a.expect(2,ab,"boolean","nil")a.range(i,-1,1)if ab==nil then ab=false end;turtle.select(1)if turtle.getItemCount()==0 then G(true)end;if ab and a5(i)then P(i)end;Q(i)end;local function ac(ab)aa(d.c.Turtle.Direction.Front,ab)end;local function ad(ab)aa(d.c.Turtle.Direction.Down,ab)end;local function ae(ab)aa(d.c.Turtle.Direction.Up,ab)end;local function af(i,j)if j==nil then j=1 end;a.expect(1,i,"number")a.expect(2,j,"number")a.range(i,1,3)h(i,j,false)local ag=false;for p=1,j,1 do success=false;while not success do local ah=false;if T(i)then if not B()then ah=true;G(true)end;if not ah and W(i)then ah=true;l("Cannot Dig Chest"..O(i))sleep(5)end;if not ah and not P(i)then ah=true;l("Cannot Dig Block"..O(i))sleep(1)end;if not ah and ag then ah=true;sleep(1)end elseif a1(i)then ah=true;if ag then l("Cannot Remove Source Block"..O(i))sleep(3)else ag=true;aa(i)end end;if not ah and not V(i)then ah=true;l("Cannot Move"..O(i))sleep(1)end;if not ah then success=true end end end;h(i,j,true)end;local function ai(j)af(d.c.Turtle.Direction.Front,j)end;local function aj(j)af(d.c.Turtle.Direction.Down,j)end;local function ak(j)af(d.c.Turtle.Direction.Up,j)end;local function al(i,j,m,K)if j==nil then j=1 end;a.expect(1,i,"number")a.expect(2,j,"number")a.range(i,1,3)if m==nil then m="Failed to Insert Item"..O(i)end;if K==nil then K="No Chest For Insert"..O(i)end;while not W(i)do l(K)sleep(5)end;while not R(i,j)do l(m)sleep(5)end end;local function am(j,m,K)al(d.c.Turtle.Direction.Front,j,m,K)end;local function an(j,m,K)al(d.c.Turtle.Direction.Down,j,m,K)end;local function ao(j,m,K)al(d.c.Turtle.Direction.Up,j,m,K)end;local function ap(i,j,m,K)if j==nil then j=1 end;a.expect(1,i,"number")a.expect(2,j,"number")a.range(i,1,3)if m==nil then m="Failed to Pull Item"..O(i)end;if K==nil then K="No Chest For Pull"..O(i)end;while not W(i)do l(K)sleep(5)end;while not S(i,j)do l(m)sleep(5)end end;local function aq(j,m,K)return ap(d.c.Turtle.Direction.Front,j,m,K)end;local function ar(j,m,K)return ap(d.c.Turtle.Direction.Down,j,m,K)end;local function as(j,m,K)return ap(d.c.Turtle.Direction.Up,j,m,K)end;e.error=l;e.hasRequiredFuel=x;e.emptySlots=z;e.hasRoom=B;e.emptyInventory=G;e.refuel=L;e.isChest=Z;e.isChestDown=_;e.isChestUp=a0;e.isSourceBlock=a2;e.isSourceBlockDown=a3;e.isSourceBlockUp=a4;e.isOreBlock=a7;e.isOreBlockDown=a8;e.isOreBlockUp=a9;e.fill=ac;e.fillDown=ad;e.fillUp=ae;e.dig=ai;e.digDown=aj;e.digUp=ak;e.insert=am;e.insertDown=an;e.insertUp=ao;e.pull=aq;e.pullDown=ar;e.pullUp=as;return e
