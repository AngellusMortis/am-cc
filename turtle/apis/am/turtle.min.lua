local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.pathfind")local d=require("am.event")local e=require("am.helpers")local f={}local g={"forge:chests","forge:barrels"}local h={}local function i(j,k,l)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.expect(3,l,"boolean")a.range(j,-1,1)if k==nil then k=1 end;d.TurtleDigEvent(l,j,k):send()end;local function m(n)a.expect(1,n,"string")b.info(string.format("%s. Retrying...",n))d.TurtleErrorEvent(n):send()end;local function o()local p={}for q=1,16,1 do p[q]=turtle.getItemDetail(q)end;return p end;local function r(s,t)if s==nil and t==nil then return nil end;if s~=nil and t==nil then return nil end;if s==nil and t~=nil then return t end;if s.name~=t.name then return t end;t.count=s.count-t.count;return t end;local function u(v)local w={}for q=1,16,1 do local x=turtle.getItemDetail(q)w[q]=r(v[q],x)end;return w end;local function y(k)a.expect(1,k,"number")a.range(k,1)local z=turtle.getFuelLevel()if z=="unlimited"then return true end;return z>k end;local function A()local B=0;for q=1,16,1 do if turtle.getItemCount(q)==0 then B=B+1 end end;return B end;local function C()return A()>=4 end;local function D()d.TurtleEmptyEvent(false,nil):send()b.info("Returning to origin...")while not c.goToOrigin()do m("Cannot Return to Origin")sleep(5)end;c.turnTo(d.c.Turtle.Direction.Left)b.info("Emptying inventory...")local p=o()for q=2,16,1 do if turtle.getItemCount(q)>0 then turtle.select(q)f.insert(nil,nil,"Missing Drop Chest")end end;local E=u(p)local F={}for G,x in ipairs(E)do if x~=nil and x.count<0 then x.count=math.abs(x.count)F[#F+1]=F end end;d.TurtleEmptyEvent(true,F):send()d.TurtleFetchFillEvent(false,nil):send()p=o()turtle.select(1)c.turnTo(d.c.Turtle.Direction.Right)f.pull(turtle.getItemSpace(),"Failed to Pull Fill Block","Missing Fill Chest")c.turnTo(d.c.Turtle.Direction.Front)E=u(p)for G,x in ipairs(E)do if x~=nil and x.count>0 then d.TurtleFetchFillEvent(true,x):send()end end end;local function H(I)a.expect(1,I,"boolean","nil")if I==nil then I=false end;D()local J=c.s.position.get()if I and not e.isOrigin(J)then b.info("Returning...")while not c.goToReturn()do m("Cannot Return to Return")sleep(5)end end end;local function K(k)a.expect(1,k,"number")a.range(k,1)local L=turtle.getFuelLevel()local M=k-L;local N="Missing Refuel Chest Above"local O=nil;turtle.select(2)while k>L do f.pullUp(O,string.format("Need %d More Fuel",M),N)turtle.refuel()if O==nil then local P=turtle.getFuelLevel()-L;O=math.ceil(M/P)if O<1 then O=nil elseif O>64 then O=64 end end;L=turtle.getFuelLevel()M=k-L end;turtle.dropUp()turtle.select(1)return true end;local function Q(k,R)a.expect(1,k,"number")a.expect(2,R,"boolean","nil")if R==nil then R=false end;a.range(k,1)if y(k)then return end;local S=turtle.getFuelLevel()d.TurtleRefuelEvent(false,k,S):send()if R then H()d.TurtleRefuelEvent(false,k,S):send()end;local J=c.s.position.get()if not e.isOrigin(J)then b.info("Returning...")while not c.goToOrigin()do m("Cannot Return to Origin")sleep(5)end end;b.info(string.format("Refueling (%d)...",k))K(k)d.TurtleRefuelEvent(true,k,S,turtle.getFuelLevel()):send()end;local function T(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return""elseif j==d.c.Turtle.Direction.Down then return" Down"else return" Up"end end;local function U(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.dig()elseif j==d.c.Turtle.Direction.Down then return turtle.digDown()else return turtle.digUp()end end;local function V(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.place()elseif j==d.c.Turtle.Direction.Down then return turtle.placeDown()else return turtle.placeUp()end end;local function W(j,k)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.drop(k)elseif j==d.c.Turtle.Direction.Down then return turtle.dropDown(k)else return turtle.dropUp(k)end end;local function X(j,k)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.suck(k)elseif j==d.c.Turtle.Direction.Down then return turtle.suckDown(k)else return turtle.suckUp(k)end end;local function Y(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.detect()elseif j==d.c.Turtle.Direction.Down then return turtle.detectDown()else return turtle.detectUp()end end;local function Z(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.inspect()elseif j==d.c.Turtle.Direction.Down then return turtle.inspectDown()else return turtle.inspectUp()end end;local function _(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return c.forward()elseif j==d.c.Turtle.Direction.Down then return c.down()else return c.up()end end;local function a0(j)a.expect(1,j,"number")a.range(j,-1,1)local success,a1=Z(j)if not success then return false end;for G,a2 in ipairs(g)do if a1.tags[a2]~=nil then return true end end;return false end;local function a3()return a0(d.c.Turtle.Direction.Front)end;local function a4()return a0(d.c.Turtle.Direction.Down)end;local function a5()return a0(d.c.Turtle.Direction.Up)end;local function a6(j)a.expect(1,j,"number")a.range(j,-1,1)local success=false;local a1=nil;if not Y(j)then success,a1=Z(j)end;if not success then return false end;return success and a1.state.level==0 end;local function a7()return a6(d.c.Turtle.Direction.Front)end;local function a8()return a6(d.c.Turtle.Direction.Down)end;local function a9()return a6(d.c.Turtle.Direction.Up)end;local function aa(j)local success,a1=Z(j)if not success then return false elseif a1.tags["forge:ores"]~=nil or string.find(a1.name,"_ore")then return true elseif string.find(a1.name,"raw_")and string.find(a1.name,"_block")then return true else for G,ab in ipairs(h)do if ab==a1.name then return true end end end;return false end;local function ac()return aa(d.c.Turtle.Direction.Front)end;local function ad()return aa(d.c.Turtle.Direction.Down)end;local function ae()return aa(d.c.Turtle.Direction.Up)end;local function af(j,ag)a.expect(1,j,"number")a.expect(2,ag,"boolean","nil")a.range(j,-1,1)if ag==nil then ag=false end;turtle.select(1)if turtle.getItemCount()==0 then H(true)end;if ag and aa(j)then U(j)end;V(j)end;local function ah(ag)af(d.c.Turtle.Direction.Front,ag)end;local function ai(ag)af(d.c.Turtle.Direction.Down,ag)end;local function aj(ag)af(d.c.Turtle.Direction.Up,ag)end;local function ak(j,k)if k==nil then k=1 end;a.expect(1,j,"number")a.expect(2,k,"number")a.range(j,-1,1)i(j,k,false)local al=false;for q=1,k,1 do success=false;while not success do local am=false;if Y(j)then if not C()then am=true;H(true)end;if not am and a0(j)then am=true;m("Cannot Dig Chest"..T(j))sleep(5)end;if not am and not U(j)then am=true;m("Cannot Dig Block"..T(j))sleep(1)end;if not am and al then am=true;sleep(1)end elseif a6(j)then am=true;if al then m("Cannot Remove Source Block"..T(j))sleep(3)else al=true;af(j)end end;if not am and not _(j)then am=true;m("Cannot Move"..T(j))sleep(1)end;if not am then success=true end end end;i(j,k,true)end;local function an(k)ak(d.c.Turtle.Direction.Front,k)end;local function ao(k)ak(d.c.Turtle.Direction.Down,k)end;local function ap(k)ak(d.c.Turtle.Direction.Up,k)end;local function aq(j,k,n,N)if k==nil then k=1 end;a.expect(1,j,"number")a.expect(2,k,"number")a.range(j,-1,1)if n==nil then n="Failed to Insert Item"..T(j)end;if N==nil then N="No Chest For Insert"..T(j)end;while not a0(j)do m(N)sleep(5)end;while not W(j,k)do m(n)sleep(5)end end;local function ar(k,n,N)aq(d.c.Turtle.Direction.Front,k,n,N)end;local function as(k,n,N)aq(d.c.Turtle.Direction.Down,k,n,N)end;local function at(k,n,N)aq(d.c.Turtle.Direction.Up,k,n,N)end;local function au(j,k,n,N)if k==nil then k=1 end;a.expect(1,j,"number")a.expect(2,k,"number")a.range(j,-1,1)if n==nil then n="Failed to Pull Item"..T(j)end;if N==nil then N="No Chest For Pull"..T(j)end;while not a0(j)do m(N)sleep(5)end;while not X(j,k)do m(n)sleep(5)end end;local function av(k,n,N)return au(d.c.Turtle.Direction.Front,k,n,N)end;local function aw(k,n,N)return au(d.c.Turtle.Direction.Down,k,n,N)end;local function ax(k,n,N)return au(d.c.Turtle.Direction.Up,k,n,N)end;f.error=m;f.hasRequiredFuel=y;f.emptySlots=A;f.hasRoom=C;f.emptyInventory=H;f.refuel=Q;f.isChest=a3;f.isChestDown=a4;f.isChestUp=a5;f.isSourceBlock=a7;f.isSourceBlockDown=a8;f.isSourceBlockUp=a9;f.isOreBlock=ac;f.isOreBlockDown=ad;f.isOreBlockUp=ae;f.fill=ah;f.fillDown=ai;f.fillUp=aj;f.dig=an;f.digDown=ao;f.digUp=ap;f.insert=ar;f.insertDown=as;f.insertUp=at;f.pull=av;f.pullDown=aw;f.pullUp=ax;return f
