local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.pathfind")local d=require("am.event")local e=require("am.helpers")local f=require("am.core")local g={}local h={["minecraft:coal"]=true,["minecraft:coal_block"]=true,["minecraft:charcoal"]=true,["quark:charcoal_block"]=true,["minecraft:lava_bucket"]=true}local i={}local j={}j.chestMap={name="tc.chestMape",default={fuel="top",fill="right",dump="left"},type="table"}g.s=f.makeSettingWrapper(j)local function k(l,m,n)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.expect(3,n,"boolean")a.range(l,-1,1)if m==nil then m=1 end;d.TurtleDigEvent(n,l,m):send()end;local function o(p)a.expect(1,p,"string")b.info(string.format("%s. Retrying...",p))d.TurtleErrorEvent(p):send()end;local function q()local r=peripheral.getNames()local s={}for t,u in ipairs(r)do local v=peripheral.wrap(u)if peripheral.hasType(v,"inventory")then s[#s+1]=v end end;return s end;local function w()local x=peripheral.find("modem",function(t,v)return not v.isWireless()end)if x==nil then return nil end;return x.getNameLocal()end;local function y()local z=nil;local A=nil;local B=nil;while z==nil or A==nil or B==nil do local s=q()for t,C in ipairs(s)do local D=C.list()local E=false;local F=false;for t,G in pairs(D)do E=true;if h[G.name]then F=true;B=peripheral.getName(C)end;break end;if not F then if E then A=peripheral.getName(C)else z=peripheral.getName(C)end end end;local H=true;if z==nil then H=false;o("No Dump Chest")elseif A==nil then H=false;o("No Fill Chest")elseif B==nil then H=false;o("No Fuel Chest")end;if not H then sleep(5)end end;g.s.chestMap.set({fuel=B,fill=A,dump=z})end;local function I(J,m)a.expect(2,m,"number","nil")if m~=nil then a.range(m,0,64)end;if m==0 then return end;local K=false;local L=g.s.chestMap.get()[J]if L=="top"then K=turtle.dropUp(m)elseif L=="bottom"then K=turtle.dropDown(m)elseif L=="left"then c.turnTo(d.c.Turtle.Direction.Left)K=turtle.drop(m)elseif L=="right"then c.turnTo(d.c.Turtle.Direction.Right)K=turtle.drop(m)else c.turnTo(d.c.Turtle.Direction.Front)local M=peripheral.wrap(L)local N=nil;local D=M.list()for C=1,M.size(),1 do if D[C]==nil then N=C;break end end;local O=turtle.getSelectedSlot()if N~=nil then K=pcall(function()M.pullItems(w(),O,m,N)end)end end;return K end;local function P(J,m,p)if m==nil then m=1 end;a.expect(2,m,"number")if p==nil then p=string.format("Failed to Push Item (%s)",J)end;while not I(J,m)do o(p)sleep(5)end end;local function Q(J,m)a.expect(2,m,"number","nil")if m~=nil then a.range(m,0,64)end;if m==0 then return end;local K=false;local L=g.s.chestMap.get()[J]if L=="top"then K=turtle.suckUp(m)elseif L=="bottom"then K=turtle.suckDown(m)elseif L=="left"then c.turnTo(d.c.Turtle.Direction.Left)K=turtle.suck(m)elseif L=="right"then c.turnTo(d.c.Turtle.Direction.Right)K=turtle.suck(m)else c.turnTo(d.c.Turtle.Direction.Front)local M=peripheral.wrap(L)local O=nil;for R,t in pairs(M.list())do O=R;break end;local N=turtle.getSelectedSlot()if O~=nil then K=pcall(function()M.pushItems(w(),O,m,N)end)end end;return K end;local function S(J,m,p)if m==nil then m=1 end;a.expect(2,m,"number")if p==nil then p=string.format("Failed to Pull Item (%s)",J)end;while not Q(J,m)do o(p)sleep(5)end end;local function T()local D={}for C=1,16,1 do D[C]=turtle.getItemDetail(C,true)end;return D end;local function U(V,W)if V==nil and W==nil then return nil end;if V~=nil and W==nil then V.count=-V.count;return V end;if V==nil and W~=nil then return W end;if V.name~=W.name then return W end;W.count=V.count-W.count;if W.count==0 then return nil end;return W end;local function X(Y)local Z={}for C=1,16,1 do local G=turtle.getItemDetail(C)Z[C]=U(Y[C],G)end;return Z end;local function _(m)a.expect(1,m,"number")a.range(m,1)local a0=turtle.getFuelLevel()if a0=="unlimited"then return true end;return a0>m end;local function a1()local a2=0;for C=1,16,1 do if turtle.getItemCount(C)==0 then a2=a2+1 end end;return a2 end;local function a3()return a1()>=4 end;local function a4()local a5=d.TurtleEmptyEvent(false,nil)a5:send()b.info("Returning to origin...")while not c.goToOrigin()do o("Cannot Return to Origin")sleep(5)end;b.info("Emptying inventory...")local D=T()for C=2,16,1 do if turtle.getItemCount(C)>0 then turtle.select(C)I("dump")end end;local a6=X(D)local a7={}for t,G in pairs(a6)do if G~=nil and G.count<0 then G.count=math.abs(G.count)a7[#a7+1]=G end end;a5.completed=true;a5.items=a7;a5:send()a5=d.TurtleFetchFillEvent(false,nil)a5:send()D=T()turtle.select(1)Q("fill",turtle.getItemSpace())a6=X(D)for t,G in ipairs(a6)do if G~=nil and G.count>0 then a5.completed=true;a5.item=G;a5:send()end end;c.turnTo(d.c.Turtle.Direction.Front)end;local function a8(a9)a.expect(1,a9,"boolean","nil")if a9==nil then a9=false end;a4()local aa=c.s.position.get()if a9 and e.isOrigin(aa)then b.info("Returning...")while not c.goToReturn()do o("Cannot Return to Return")sleep(5)end end end;local function ab(m)a.expect(1,m,"number")a.range(m,1)local ac=turtle.getFuelLevel()local ad=m-ac;local ae=nil;turtle.select(2)while m>ac do S("fuel",ae or 1,string.format("Need %d More Fuel",ad))turtle.refuel()if ae==nil then local af=turtle.getFuelLevel()-ac;ae=math.ceil(ad/af)if ae<1 then ae=nil elseif ae>64 then ae=64 end end;ac=turtle.getFuelLevel()ad=m-ac end;P("fuel")turtle.select(1)return true end;local function ag(m,ah)a.expect(1,m,"number")a.expect(2,ah,"boolean","nil")if ah==nil then ah=false end;a.range(m,1)if _(m)then return end;local ai=turtle.getFuelLevel()local a5=d.TurtleRefuelEvent(false,m,ai)a5:send()if ah then a8()a5:send()end;local aa=c.s.position.get()if not e.isOrigin(aa)then b.info("Returning...")while not c.goToOrigin()do o("Cannot Return to Origin")sleep(5)end end;b.info(string.format("Refueling (%d)...",m))ab(m)a5.completed=true;a5.newLevel=turtle.getFuelLevel()a5:send()end;local function aj(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return""elseif l==d.c.Turtle.Direction.Down then return" Down"else return" Up"end end;local function ak(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.dig()elseif l==d.c.Turtle.Direction.Down then return turtle.digDown()else return turtle.digUp()end end;local function al(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.place()elseif l==d.c.Turtle.Direction.Down then return turtle.placeDown()else return turtle.placeUp()end end;local function am(l,m)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.drop(m)elseif l==d.c.Turtle.Direction.Down then return turtle.dropDown(m)else return turtle.dropUp(m)end end;local function an(l,m)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.suck(m)elseif l==d.c.Turtle.Direction.Down then return turtle.suckDown(m)else return turtle.suckUp(m)end end;local function ao(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.detect()elseif l==d.c.Turtle.Direction.Down then return turtle.detectDown()else return turtle.detectUp()end end;local function ap(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.inspect()elseif l==d.c.Turtle.Direction.Down then return turtle.inspectDown()else return turtle.inspectUp()end end;local function aq(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return c.forward()elseif l==d.c.Turtle.Direction.Down then return c.down()else return c.up()end end;local function ar(l)a.expect(1,l,"number")a.range(l,-1,1)local as="top"if l==d.c.Turtle.Direction.Front then as="front"elseif l==d.c.Turtle.Direction.Down then as="bottom"end;local at=peripheral.wrap(as)return at~=nil end;local function au()return ar(d.c.Turtle.Direction.Front)end;local function av()return ar(d.c.Turtle.Direction.Down)end;local function aw()return ar(d.c.Turtle.Direction.Up)end;local function ax(l)a.expect(1,l,"number")a.range(l,-1,1)local K=false;local ay=nil;if not ao(l)then K,ay=ap(l)end;if not K then return false end;return K and ay.state.level==0 end;local function az()return ax(d.c.Turtle.Direction.Front)end;local function aA()return ax(d.c.Turtle.Direction.Down)end;local function aB()return ax(d.c.Turtle.Direction.Up)end;local function aC(l)local K,ay=ap(l)if not K then return false elseif ay.tags["forge:ores"]~=nil or string.find(ay.name,"_ore")then return true elseif string.find(ay.name,"raw_")and string.find(ay.name,"_block")then return true else for t,u in ipairs(i)do if u==ay.name then return true end end end;return false end;local function aD()return aC(d.c.Turtle.Direction.Front)end;local function aE()return aC(d.c.Turtle.Direction.Down)end;local function aF()return aC(d.c.Turtle.Direction.Up)end;local function aG(l,aH)a.expect(1,l,"number")a.expect(2,aH,"boolean","nil")a.range(l,-1,1)if aH==nil then aH=false end;turtle.select(1)if turtle.getItemCount()==0 then a8(true)end;if aH and aC(l)then ak(l)end;al(l)end;local function aI(aH)aG(d.c.Turtle.Direction.Front,aH)end;local function aJ(aH)aG(d.c.Turtle.Direction.Down,aH)end;local function aK(aH)aG(d.c.Turtle.Direction.Up,aH)end;local function aL(l,m)if m==nil then m=1 end;a.expect(1,l,"number")a.expect(2,m,"number")a.range(l,-1,1)k(l,m,false)local aM=false;for C=1,m,1 do local K=false;local aN=false;while not K do local aO=false;if ao(l)then if not a3()then aO=true;aN=true;a8(true)end;if not aO and ar(l)then aO=true;aN=true;o("Ignored Block"..aj(l))sleep(5)end;if not aO and not ak(l)then local aP,ay=ap(l)if aP and ay.name=="minecraft:bedrock"then return false end;aO=true;aN=true;o("Cannot Dig Block"..aj(l))sleep(1)end;if not aO and aM then aO=true;aN=true;sleep(1)end elseif ax(l)then aO=true;aN=true;if aM then o("Infinite Source"..aj(l))sleep(3)else aM=true;aG(l)end end;if not aO and not aq(l)then aO=true;aN=true;o("Cannot Move"..aj(l))sleep(1)end;if not aO then K=true end end;if aN then d.TurtleErrorClearEvent():send()end end;k(l,m,true)return true end;local function aQ(m)return aL(d.c.Turtle.Direction.Front,m)end;local function aR(m)return aL(d.c.Turtle.Direction.Down,m)end;local function aS(m)return aL(d.c.Turtle.Direction.Up,m)end;local function aT(l,m,p,aU)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if p==nil then p="Failed to Insert Item"..aj(l)end;if aU==nil then aU="No Chest For Insert"..aj(l)end;while not ar(l)do o(aU)sleep(5)end;while not am(l,m)do o(p)sleep(5)end end;local function aV(m,p,aU)aT(d.c.Turtle.Direction.Front,m,p,aU)end;local function aW(m,p,aU)aT(d.c.Turtle.Direction.Down,m,p,aU)end;local function aX(m,p,aU)aT(d.c.Turtle.Direction.Up,m,p,aU)end;local function aY(l,m,p,aU)if m==nil then m=1 end;a.expect(1,l,"number")a.expect(2,m,"number")a.range(l,-1,1)if p==nil then p="Failed to Pull Item"..aj(l)end;if aU==nil then aU="No Chest For Pull"..aj(l)end;while not ar(l)do o(aU)sleep(5)end;while not an(l,m)do o(p)sleep(5)end end;local function aZ(m,p,aU)return aY(d.c.Turtle.Direction.Front,m,p,aU)end;local function a_(m,p,aU)return aY(d.c.Turtle.Direction.Down,m,p,aU)end;local function b0(m,p,aU)return aY(d.c.Turtle.Direction.Up,m,p,aU)end;g.discoverChests=y;g.error=o;g.hasRequiredFuel=_;g.emptySlots=a1;g.hasRoom=a3;g.emptyInventory=a8;g.refuel=ag;g.isPerherial=au;g.isPerherialDown=av;g.isPerherialUp=aw;g.isSourceBlock=az;g.isSourceBlockDown=aA;g.isSourceBlockUp=aB;g.isOreBlock=aD;g.isOreBlockDown=aE;g.isOreBlockUp=aF;g.fill=aI;g.fillDown=aJ;g.fillUp=aK;g.dig=aQ;g.digDown=aR;g.digUp=aS;g.insert=aV;g.insertDown=aW;g.insertUp=aX;g.pull=aZ;g.pullDown=a_;g.pullUp=b0;return g
