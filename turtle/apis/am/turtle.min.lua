local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.pathfind")local d=require("am.event")local e=require("am.helpers")local f={}local g={"forge:chests","forge:barrels"}local h={}local function i(j,k,l)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.expect(3,l,"boolean")a.range(j,-1,1)if k==nil then k=1 end;d.TurtleDigEvent(l,j,k):send()end;local function m(n)a.expect(1,n,"string")b.info(string.format("%s. Retrying...",n))d.TurtleErrorEvent(n):send()end;local function o()local p={}for q=1,16,1 do p[q]=turtle.getItemDetail(q)end;return p end;local function r(s,t)if s==nil and t==nil then return nil end;if s~=nil and t==nil then return nil end;if s==nil and t~=nil then return t end;if s.name~=t.name then return t end;t.count=s.count-t.count;return t end;local function u(v)local w={}for q=1,16,1 do local x=turtle.getItemDetail(q)w[q]=r(v[q],x)end;return w end;local function y(k)a.expect(1,k,"number")a.range(k,1)local z=turtle.getFuelLevel()if z=="unlimited"then return true end;return z>k end;local function A()local B=0;for q=1,16,1 do if turtle.getItemCount(q)==0 then B=B+1 end end;return B end;local function C()return A()>=4 end;local function D()local E=d.TurtleEmptyEvent(false,nil)E:send()b.info("Returning to origin...")while not c.goToOrigin()do m("Cannot Return to Origin")sleep(5)end;c.turnTo(d.c.Turtle.Direction.Left)b.info("Emptying inventory...")local p=o()for q=2,16,1 do if turtle.getItemCount(q)>0 then turtle.select(q)f.insert(nil,nil,"Missing Drop Chest")end end;local F=u(p)local G={}for H,x in ipairs(F)do if x~=nil and x.count<0 then x.count=math.abs(x.count)G[#G+1]=G end end;E.completed=true;E.items=G;E:send()E=d.TurtleFetchFillEvent(false,nil)E:send()p=o()turtle.select(1)c.turnTo(d.c.Turtle.Direction.Right)f.pull(turtle.getItemSpace(),"Failed to Pull Fill Block","Missing Fill Chest")c.turnTo(d.c.Turtle.Direction.Front)F=u(p)for H,x in ipairs(F)do if x~=nil and x.count>0 then E.completed=true;E.item=x;E:send()end end end;local function I(J)a.expect(1,J,"boolean","nil")if J==nil then J=false end;D()local K=c.s.position.get()if J and not e.isOrigin(K)then b.info("Returning...")while not c.goToReturn()do m("Cannot Return to Return")sleep(5)end end end;local function L(k)a.expect(1,k,"number")a.range(k,1)local M=turtle.getFuelLevel()local N=k-M;local O="Missing Refuel Chest Above"local P=nil;turtle.select(2)while k>M do f.pullUp(P,string.format("Need %d More Fuel",N),O)turtle.refuel()if P==nil then local Q=turtle.getFuelLevel()-M;P=math.ceil(N/Q)if P<1 then P=nil elseif P>64 then P=64 end end;M=turtle.getFuelLevel()N=k-M end;turtle.dropUp()turtle.select(1)return true end;local function R(k,S)a.expect(1,k,"number")a.expect(2,S,"boolean","nil")if S==nil then S=false end;a.range(k,1)if y(k)then return end;local T=turtle.getFuelLevel()local E=d.TurtleRefuelEvent(false,k,T)E:send()if S then I()E:send()end;local K=c.s.position.get()if not e.isOrigin(K)then b.info("Returning...")while not c.goToOrigin()do m("Cannot Return to Origin")sleep(5)end end;b.info(string.format("Refueling (%d)...",k))L(k)E.completed=true;E.newLevel=turtle.getFuelLevel()E:send()end;local function U(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return""elseif j==d.c.Turtle.Direction.Down then return" Down"else return" Up"end end;local function V(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.dig()elseif j==d.c.Turtle.Direction.Down then return turtle.digDown()else return turtle.digUp()end end;local function W(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.place()elseif j==d.c.Turtle.Direction.Down then return turtle.placeDown()else return turtle.placeUp()end end;local function X(j,k)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.drop(k)elseif j==d.c.Turtle.Direction.Down then return turtle.dropDown(k)else return turtle.dropUp(k)end end;local function Y(j,k)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.suck(k)elseif j==d.c.Turtle.Direction.Down then return turtle.suckDown(k)else return turtle.suckUp(k)end end;local function Z(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.detect()elseif j==d.c.Turtle.Direction.Down then return turtle.detectDown()else return turtle.detectUp()end end;local function _(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.inspect()elseif j==d.c.Turtle.Direction.Down then return turtle.inspectDown()else return turtle.inspectUp()end end;local function a0(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return c.forward()elseif j==d.c.Turtle.Direction.Down then return c.down()else return c.up()end end;local function a1(j)a.expect(1,j,"number")a.range(j,-1,1)local success,a2=_(j)if not success then return false end;for H,a3 in ipairs(g)do if a2.tags[a3]~=nil then return true end end;return false end;local function a4()return a1(d.c.Turtle.Direction.Front)end;local function a5()return a1(d.c.Turtle.Direction.Down)end;local function a6()return a1(d.c.Turtle.Direction.Up)end;local function a7(j)a.expect(1,j,"number")a.range(j,-1,1)local success=false;local a2=nil;if not Z(j)then success,a2=_(j)end;if not success then return false end;return success and a2.state.level==0 end;local function a8()return a7(d.c.Turtle.Direction.Front)end;local function a9()return a7(d.c.Turtle.Direction.Down)end;local function aa()return a7(d.c.Turtle.Direction.Up)end;local function ab(j)local success,a2=_(j)if not success then return false elseif a2.tags["forge:ores"]~=nil or string.find(a2.name,"_ore")then return true elseif string.find(a2.name,"raw_")and string.find(a2.name,"_block")then return true else for H,ac in ipairs(h)do if ac==a2.name then return true end end end;return false end;local function ad()return ab(d.c.Turtle.Direction.Front)end;local function ae()return ab(d.c.Turtle.Direction.Down)end;local function af()return ab(d.c.Turtle.Direction.Up)end;local function ag(j,ah)a.expect(1,j,"number")a.expect(2,ah,"boolean","nil")a.range(j,-1,1)if ah==nil then ah=false end;turtle.select(1)if turtle.getItemCount()==0 then I(true)end;if ah and ab(j)then V(j)end;W(j)end;local function ai(ah)ag(d.c.Turtle.Direction.Front,ah)end;local function aj(ah)ag(d.c.Turtle.Direction.Down,ah)end;local function ak(ah)ag(d.c.Turtle.Direction.Up,ah)end;local function al(j,k)if k==nil then k=1 end;a.expect(1,j,"number")a.expect(2,k,"number")a.range(j,-1,1)i(j,k,false)local am=false;for q=1,k,1 do success=false;while not success do local an=false;if Z(j)then if not C()then an=true;I(true)end;if not an and a1(j)then an=true;m("Cannot Dig Chest"..U(j))sleep(5)end;if not an and not V(j)then an=true;m("Cannot Dig Block"..U(j))sleep(1)end;if not an and am then an=true;sleep(1)end elseif a7(j)then an=true;if am then m("Cannot Remove Source Block"..U(j))sleep(3)else am=true;ag(j)end end;if not an and not a0(j)then an=true;m("Cannot Move"..U(j))sleep(1)end;if not an then success=true end end end;i(j,k,true)end;local function ao(k)al(d.c.Turtle.Direction.Front,k)end;local function ap(k)al(d.c.Turtle.Direction.Down,k)end;local function aq(k)al(d.c.Turtle.Direction.Up,k)end;local function ar(j,k,n,O)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.range(j,-1,1)if n==nil then n="Failed to Insert Item"..U(j)end;if O==nil then O="No Chest For Insert"..U(j)end;while not a1(j)do m(O)sleep(5)end;while not X(j,k)do m(n)sleep(5)end end;local function as(k,n,O)ar(d.c.Turtle.Direction.Front,k,n,O)end;local function at(k,n,O)ar(d.c.Turtle.Direction.Down,k,n,O)end;local function au(k,n,O)ar(d.c.Turtle.Direction.Up,k,n,O)end;local function av(j,k,n,O)if k==nil then k=1 end;a.expect(1,j,"number")a.expect(2,k,"number")a.range(j,-1,1)if n==nil then n="Failed to Pull Item"..U(j)end;if O==nil then O="No Chest For Pull"..U(j)end;while not a1(j)do m(O)sleep(5)end;while not Y(j,k)do m(n)sleep(5)end end;local function aw(k,n,O)return av(d.c.Turtle.Direction.Front,k,n,O)end;local function ax(k,n,O)return av(d.c.Turtle.Direction.Down,k,n,O)end;local function ay(k,n,O)return av(d.c.Turtle.Direction.Up,k,n,O)end;f.error=m;f.hasRequiredFuel=y;f.emptySlots=A;f.hasRoom=C;f.emptyInventory=I;f.refuel=R;f.isChest=a4;f.isChestDown=a5;f.isChestUp=a6;f.isSourceBlock=a8;f.isSourceBlockDown=a9;f.isSourceBlockUp=aa;f.isOreBlock=ad;f.isOreBlockDown=ae;f.isOreBlockUp=af;f.fill=ai;f.fillDown=aj;f.fillUp=ak;f.dig=ao;f.digDown=ap;f.digUp=aq;f.insert=as;f.insertDown=at;f.insertUp=au;f.pull=aw;f.pullDown=ax;f.pullUp=ay;return f
