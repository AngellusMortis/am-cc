local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.pathfind")local d=require("am.event")local e=require("am.helpers")local f=require("am.core")local g={}local h={["minecraft:coal"]=true,["minecraft:coal_block"]=true,["minecraft:charcoal"]=true,["quark:charcoal_block"]=true,["minecraft:lava_bucket"]=true}local i={}local j={}j.chestMap={name="tc.chestMape",default={fuel="top",fill="right",dump="left"},type="table"}g.s=f.makeSettingWrapper(j)local function k(l,m,n)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.expect(3,n,"boolean")a.range(l,-1,1)if m==nil then m=1 end;d.TurtleDigEvent(n,l,m):send()end;local function o(p)a.expect(1,p,"string")b.info(string.format("%s. Retrying...",p))d.TurtleErrorEvent(p):send()end;local function q()local r=peripheral.getNames()local s={}for t,u in ipairs(r)do local v=peripheral.wrap(u)if peripheral.hasType(v,"inventory")then s[#s+1]=v end end;return s end;local function w()local x=peripheral.find("modem",function(t,v)return not v.isWireless()end)if x==nil then return nil end;return x.getNameLocal()end;local function y()local z=nil;local A=nil;local B=nil;while z==nil or A==nil or B==nil do local s=q()for t,C in ipairs(s)do local D=C.list()local E=false;for t,F in pairs(D)do E=true;if h[F.name]then B=peripheral.getName(C)break end end;if E then A=peripheral.getName(C)else z=peripheral.getName(C)end end;local G=true;if z==nil then G=false;o("No Dump Chest")elseif A==nil then G=false;o("No Fill Chest")elseif B==nil then G=false;o("No Fuel Chest")end;if not G then sleep(5)end end;g.s.chestMap.set({fuel=B,fill=A,dump=z})end;local function H(I,m)a.expect(2,m,"number","nil")if m~=nil then a.range(m,0,64)end;if m==0 then return end;local J=false;local K=g.s.chestMap.get()[I]if K=="top"then J=turtle.dropUp(m)elseif K=="bottom"then J=turtle.dropDown(m)elseif K=="left"then c.turnTo(d.c.Turtle.Direction.Left)J=turtle.drop(m)elseif K=="right"then c.turnTo(d.c.Turtle.Direction.Right)J=turtle.drop(m)else c.turnTo(d.c.Turtle.Direction.Front)local L=peripheral.wrap(K)local M=nil;local D=L.list()for C=1,L.size(),1 do if D[C]==nil then M=C;break end end;local N=turtle.getSelectedSlot()if M~=nil then J=pcall(function()L.pullItems(w(),N,m,M)end)end end;return J end;local function O(I,m,p)if m==nil then m=1 end;a.expect(2,m,"number")if p==nil then p=string.format("Failed to Push Item (%s)",I)end;while not H(I,m)do o(p)sleep(5)end end;local function P(I,m)a.expect(2,m,"number","nil")if m~=nil then a.range(m,0,64)end;if m==0 then return end;local J=false;local K=g.s.chestMap.get()[I]if K=="top"then J=turtle.suckUp(m)elseif K=="bottom"then J=turtle.suckDown(m)elseif K=="left"then c.turnTo(d.c.Turtle.Direction.Left)J=turtle.suck(m)elseif K=="right"then c.turnTo(d.c.Turtle.Direction.Right)J=turtle.suck(m)else c.turnTo(d.c.Turtle.Direction.Front)local L=peripheral.wrap(K)local N=nil;for Q,t in pairs(L.list())do N=Q;break end;local M=turtle.getSelectedSlot()if N~=nil then J=pcall(function()L.pushItems(w(),N,m,M)end)end end;return J end;local function R(I,m,p)if m==nil then m=1 end;a.expect(2,m,"number")if p==nil then p=string.format("Failed to Pull Item (%s)",I)end;while not P(I,m)do o(p)sleep(5)end end;local function S()local D={}for C=1,16,1 do D[C]=turtle.getItemDetail(C,true)end;return D end;local function T(U,V)if U==nil and V==nil then return nil end;if U~=nil and V==nil then U.count=-U.count;return U end;if U==nil and V~=nil then return V end;if U.name~=V.name then return V end;V.count=U.count-V.count;if V.count==0 then return nil end;return V end;local function W(X)local Y={}for C=1,16,1 do local F=turtle.getItemDetail(C)Y[C]=T(X[C],F)end;return Y end;local function Z(m)a.expect(1,m,"number")a.range(m,1)local _=turtle.getFuelLevel()if _=="unlimited"then return true end;return _>m end;local function a0()local a1=0;for C=1,16,1 do if turtle.getItemCount(C)==0 then a1=a1+1 end end;return a1 end;local function a2()return a0()>=4 end;local function a3()local a4=d.TurtleEmptyEvent(false,nil)a4:send()b.info("Returning to origin...")while not c.goToOrigin()do o("Cannot Return to Origin")sleep(5)end;b.info("Emptying inventory...")local D=S()for C=2,16,1 do if turtle.getItemCount(C)>0 then turtle.select(C)H("dump")end end;local a5=W(D)local a6={}for t,F in pairs(a5)do if F~=nil and F.count<0 then F.count=math.abs(F.count)a6[#a6+1]=F end end;a4.completed=true;a4.items=a6;a4:send()a4=d.TurtleFetchFillEvent(false,nil)a4:send()D=S()turtle.select(1)P("fill",turtle.getItemSpace())a5=W(D)for t,F in ipairs(a5)do if F~=nil and F.count>0 then a4.completed=true;a4.item=F;a4:send()end end;c.turnTo(d.c.Turtle.Direction.Front)end;local function a7(a8)a.expect(1,a8,"boolean","nil")if a8==nil then a8=false end;a3()local a9=c.s.position.get()if a8 and e.isOrigin(a9)then b.info("Returning...")while not c.goToReturn()do o("Cannot Return to Return")sleep(5)end end end;local function aa(m)a.expect(1,m,"number")a.range(m,1)local ab=turtle.getFuelLevel()local ac=m-ab;local ad=nil;turtle.select(2)while m>ab do R("fuel",ad or 1,string.format("Need %d More Fuel",ac))turtle.refuel()if ad==nil then local ae=turtle.getFuelLevel()-ab;ad=math.ceil(ac/ae)if ad<1 then ad=nil elseif ad>64 then ad=64 end end;ab=turtle.getFuelLevel()ac=m-ab end;O("fuel")turtle.select(1)return true end;local function af(m,ag)a.expect(1,m,"number")a.expect(2,ag,"boolean","nil")if ag==nil then ag=false end;a.range(m,1)if Z(m)then return end;local ah=turtle.getFuelLevel()local a4=d.TurtleRefuelEvent(false,m,ah)a4:send()if ag then a7()a4:send()end;local a9=c.s.position.get()if not e.isOrigin(a9)then b.info("Returning...")while not c.goToOrigin()do o("Cannot Return to Origin")sleep(5)end end;b.info(string.format("Refueling (%d)...",m))aa(m)a4.completed=true;a4.newLevel=turtle.getFuelLevel()a4:send()end;local function ai(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return""elseif l==d.c.Turtle.Direction.Down then return" Down"else return" Up"end end;local function aj(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.dig()elseif l==d.c.Turtle.Direction.Down then return turtle.digDown()else return turtle.digUp()end end;local function ak(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.place()elseif l==d.c.Turtle.Direction.Down then return turtle.placeDown()else return turtle.placeUp()end end;local function al(l,m)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.drop(m)elseif l==d.c.Turtle.Direction.Down then return turtle.dropDown(m)else return turtle.dropUp(m)end end;local function am(l,m)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.suck(m)elseif l==d.c.Turtle.Direction.Down then return turtle.suckDown(m)else return turtle.suckUp(m)end end;local function an(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.detect()elseif l==d.c.Turtle.Direction.Down then return turtle.detectDown()else return turtle.detectUp()end end;local function ao(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return turtle.inspect()elseif l==d.c.Turtle.Direction.Down then return turtle.inspectDown()else return turtle.inspectUp()end end;local function ap(l)a.expect(1,l,"number")a.range(l,-1,1)if l==d.c.Turtle.Direction.Front then return c.forward()elseif l==d.c.Turtle.Direction.Down then return c.down()else return c.up()end end;local function aq(l)a.expect(1,l,"number")a.range(l,-1,1)local ar="top"if l==d.c.Turtle.Direction.Front then ar="front"elseif l==d.c.Turtle.Direction.Down then ar="bottom"end;local as=peripheral.wrap(ar)return as~=nil end;local function at()return aq(d.c.Turtle.Direction.Front)end;local function au()return aq(d.c.Turtle.Direction.Down)end;local function av()return aq(d.c.Turtle.Direction.Up)end;local function aw(l)a.expect(1,l,"number")a.range(l,-1,1)local J=false;local ax=nil;if not an(l)then J,ax=ao(l)end;if not J then return false end;return J and ax.state.level==0 end;local function ay()return aw(d.c.Turtle.Direction.Front)end;local function az()return aw(d.c.Turtle.Direction.Down)end;local function aA()return aw(d.c.Turtle.Direction.Up)end;local function aB(l)local J,ax=ao(l)if not J then return false elseif ax.tags["forge:ores"]~=nil or string.find(ax.name,"_ore")then return true elseif string.find(ax.name,"raw_")and string.find(ax.name,"_block")then return true else for t,u in ipairs(i)do if u==ax.name then return true end end end;return false end;local function aC()return aB(d.c.Turtle.Direction.Front)end;local function aD()return aB(d.c.Turtle.Direction.Down)end;local function aE()return aB(d.c.Turtle.Direction.Up)end;local function aF(l,aG)a.expect(1,l,"number")a.expect(2,aG,"boolean","nil")a.range(l,-1,1)if aG==nil then aG=false end;turtle.select(1)if turtle.getItemCount()==0 then a7(true)end;if aG and aB(l)then aj(l)end;ak(l)end;local function aH(aG)aF(d.c.Turtle.Direction.Front,aG)end;local function aI(aG)aF(d.c.Turtle.Direction.Down,aG)end;local function aJ(aG)aF(d.c.Turtle.Direction.Up,aG)end;local function aK(l,m)if m==nil then m=1 end;a.expect(1,l,"number")a.expect(2,m,"number")a.range(l,-1,1)k(l,m,false)local aL=false;for C=1,m,1 do local J=false;local aM=false;while not J do local aN=false;if an(l)then if not a2()then aN=true;aM=true;a7(true)end;if not aN and aq(l)then aN=true;aM=true;o("Ignored Block"..ai(l))sleep(5)end;if not aN and not aj(l)then local aO,ax=ao(l)if aO and ax.name=="minecraft:bedrock"then return false end;aN=true;aM=true;o("Cannot Dig Block"..ai(l))sleep(1)end;if not aN and aL then aN=true;aM=true;sleep(1)end elseif aw(l)then aN=true;aM=true;if aL then o("Infinite Source"..ai(l))sleep(3)else aL=true;aF(l)end end;if not aN and not ap(l)then aN=true;aM=true;o("Cannot Move"..ai(l))sleep(1)end;if not aN then J=true end end;if aM then d.TurtleErrorClearEvent():send()end end;k(l,m,true)return true end;local function aP(m)return aK(d.c.Turtle.Direction.Front,m)end;local function aQ(m)return aK(d.c.Turtle.Direction.Down,m)end;local function aR(m)return aK(d.c.Turtle.Direction.Up,m)end;local function aS(l,m,p,aT)a.expect(1,l,"number")a.expect(2,m,"number","nil")a.range(l,-1,1)if p==nil then p="Failed to Insert Item"..ai(l)end;if aT==nil then aT="No Chest For Insert"..ai(l)end;while not aq(l)do o(aT)sleep(5)end;while not al(l,m)do o(p)sleep(5)end end;local function aU(m,p,aT)aS(d.c.Turtle.Direction.Front,m,p,aT)end;local function aV(m,p,aT)aS(d.c.Turtle.Direction.Down,m,p,aT)end;local function aW(m,p,aT)aS(d.c.Turtle.Direction.Up,m,p,aT)end;local function aX(l,m,p,aT)if m==nil then m=1 end;a.expect(1,l,"number")a.expect(2,m,"number")a.range(l,-1,1)if p==nil then p="Failed to Pull Item"..ai(l)end;if aT==nil then aT="No Chest For Pull"..ai(l)end;while not aq(l)do o(aT)sleep(5)end;while not am(l,m)do o(p)sleep(5)end end;local function aY(m,p,aT)return aX(d.c.Turtle.Direction.Front,m,p,aT)end;local function aZ(m,p,aT)return aX(d.c.Turtle.Direction.Down,m,p,aT)end;local function a_(m,p,aT)return aX(d.c.Turtle.Direction.Up,m,p,aT)end;g.discoverChests=y;g.error=o;g.hasRequiredFuel=Z;g.emptySlots=a0;g.hasRoom=a2;g.emptyInventory=a7;g.refuel=af;g.isPerherial=at;g.isPerherialDown=au;g.isPerherialUp=av;g.isSourceBlock=ay;g.isSourceBlockDown=az;g.isSourceBlockUp=aA;g.isOreBlock=aC;g.isOreBlockDown=aD;g.isOreBlockUp=aE;g.fill=aH;g.fillDown=aI;g.fillUp=aJ;g.dig=aP;g.digDown=aQ;g.digUp=aR;g.insert=aU;g.insertDown=aV;g.insertUp=aW;g.pull=aY;g.pullDown=aZ;g.pullUp=a_;return g
