local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.log")local c=require("am.pathfind")local d=require("am.event")local e=require("am.helpers")local f={}local g={"forge:chests","forge:barrels"}local h={}local function i(j,k,l)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.expect(3,l,"boolean")a.range(j,-1,1)if k==nil then k=1 end;d.TurtleDigEvent(l,j,k):send()end;local function m(n)a.expect(1,n,"string")b.info(string.format("%s. Retrying...",n))d.TurtleErrorEvent(n):send()end;local function o()local p={}for q=1,16,1 do p[q]=turtle.getItemDetail(q,true)end;return p end;local function r(s,t)if s==nil and t==nil then return nil end;if s~=nil and t==nil then s.count=-s.count;return s end;if s==nil and t~=nil then return t end;if s.name~=t.name then return t end;t.count=s.count-t.count;if t.count==0 then return nil end;return t end;local function u(v)local w={}for q=1,16,1 do local x=turtle.getItemDetail(q)w[q]=r(v[q],x)end;return w end;local function y(k)a.expect(1,k,"number")a.range(k,1)local z=turtle.getFuelLevel()if z=="unlimited"then return true end;return z>k end;local function A()local B=0;for q=1,16,1 do if turtle.getItemCount(q)==0 then B=B+1 end end;return B end;local function C()return A()>=4 end;local function D()local E=d.TurtleEmptyEvent(false,nil)E:send()b.info("Returning to origin...")while not c.goToOrigin()do m("Cannot Return to Origin")sleep(5)end;c.turnTo(d.c.Turtle.Direction.Left)b.info("Emptying inventory...")local p=o()for q=2,16,1 do if turtle.getItemCount(q)>0 then turtle.select(q)f.insert(nil,nil,"Missing Drop Chest")end end;local F=u(p)local G={}for H,x in pairs(F)do if x~=nil and x.count<0 then x.count=math.abs(x.count)G[#G+1]=x end end;E.completed=true;E.items=G;E:send()E=d.TurtleFetchFillEvent(false,nil)E:send()p=o()turtle.select(1)c.turnTo(d.c.Turtle.Direction.Right)f.pull(turtle.getItemSpace(),"Failed to Pull Fill Block","Missing Fill Chest")c.turnTo(d.c.Turtle.Direction.Front)F=u(p)for H,x in ipairs(F)do if x~=nil and x.count>0 then E.completed=true;E.item=x;E:send()end end end;local function I(J)a.expect(1,J,"boolean","nil")if J==nil then J=false end;D()local K=c.s.position.get()if J and e.isOrigin(K)then b.info("Returning...")while not c.goToReturn()do m("Cannot Return to Return")sleep(5)end end end;local function L(k)a.expect(1,k,"number")a.range(k,1)local M=turtle.getFuelLevel()local N=k-M;local O="Missing Refuel Chest Above"local P=nil;turtle.select(2)while k>M do f.pullUp(P,string.format("Need %d More Fuel",N),O)turtle.refuel()if P==nil then local Q=turtle.getFuelLevel()-M;P=math.ceil(N/Q)if P<1 then P=nil elseif P>64 then P=64 end end;M=turtle.getFuelLevel()N=k-M end;turtle.dropUp()turtle.select(1)return true end;local function R(k,S)a.expect(1,k,"number")a.expect(2,S,"boolean","nil")if S==nil then S=false end;a.range(k,1)if y(k)then return end;local T=turtle.getFuelLevel()local E=d.TurtleRefuelEvent(false,k,T)E:send()if S then I()E:send()end;local K=c.s.position.get()if not e.isOrigin(K)then b.info("Returning...")while not c.goToOrigin()do m("Cannot Return to Origin")sleep(5)end end;b.info(string.format("Refueling (%d)...",k))L(k)E.completed=true;E.newLevel=turtle.getFuelLevel()E:send()end;local function U(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return""elseif j==d.c.Turtle.Direction.Down then return" Down"else return" Up"end end;local function V(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.dig()elseif j==d.c.Turtle.Direction.Down then return turtle.digDown()else return turtle.digUp()end end;local function W(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.place()elseif j==d.c.Turtle.Direction.Down then return turtle.placeDown()else return turtle.placeUp()end end;local function X(j,k)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.drop(k)elseif j==d.c.Turtle.Direction.Down then return turtle.dropDown(k)else return turtle.dropUp(k)end end;local function Y(j,k)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.suck(k)elseif j==d.c.Turtle.Direction.Down then return turtle.suckDown(k)else return turtle.suckUp(k)end end;local function Z(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.detect()elseif j==d.c.Turtle.Direction.Down then return turtle.detectDown()else return turtle.detectUp()end end;local function _(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return turtle.inspect()elseif j==d.c.Turtle.Direction.Down then return turtle.inspectDown()else return turtle.inspectUp()end end;local function a0(j)a.expect(1,j,"number")a.range(j,-1,1)if j==d.c.Turtle.Direction.Front then return c.forward()elseif j==d.c.Turtle.Direction.Down then return c.down()else return c.up()end end;local function a1(j)a.expect(1,j,"number")a.range(j,-1,1)local a2="top"if j==d.c.Turtle.Direction.Front then a2="front"elseif j==d.c.Turtle.Direction.Down then a2="bottom"end;local a3=peripheral.wrap(a2)return a3~=nil end;local function a4()return a1(d.c.Turtle.Direction.Front)end;local function a5()return a1(d.c.Turtle.Direction.Down)end;local function a6()return a1(d.c.Turtle.Direction.Up)end;local function a7(j)a.expect(1,j,"number")a.range(j,-1,1)local a8=false;local a9=nil;if not Z(j)then a8,a9=_(j)end;if not a8 then return false end;return a8 and a9.state.level==0 end;local function aa()return a7(d.c.Turtle.Direction.Front)end;local function ab()return a7(d.c.Turtle.Direction.Down)end;local function ac()return a7(d.c.Turtle.Direction.Up)end;local function ad(j)local a8,a9=_(j)if not a8 then return false elseif a9.tags["forge:ores"]~=nil or string.find(a9.name,"_ore")then return true elseif string.find(a9.name,"raw_")and string.find(a9.name,"_block")then return true else for H,ae in ipairs(h)do if ae==a9.name then return true end end end;return false end;local function af()return ad(d.c.Turtle.Direction.Front)end;local function ag()return ad(d.c.Turtle.Direction.Down)end;local function ah()return ad(d.c.Turtle.Direction.Up)end;local function ai(j,aj)a.expect(1,j,"number")a.expect(2,aj,"boolean","nil")a.range(j,-1,1)if aj==nil then aj=false end;turtle.select(1)if turtle.getItemCount()==0 then I(true)end;if aj and ad(j)then V(j)end;W(j)end;local function ak(aj)ai(d.c.Turtle.Direction.Front,aj)end;local function al(aj)ai(d.c.Turtle.Direction.Down,aj)end;local function am(aj)ai(d.c.Turtle.Direction.Up,aj)end;local function an(j,k)if k==nil then k=1 end;a.expect(1,j,"number")a.expect(2,k,"number")a.range(j,-1,1)i(j,k,false)local ao=false;for q=1,k,1 do local a8=false;local ap=false;while not a8 do local aq=false;if Z(j)then if not C()then aq=true;ap=true;I(true)end;if not aq and a1(j)then aq=true;ap=true;m("Ignored Block"..U(j))sleep(5)end;if not aq and not V(j)then local ar,a9=_(j)if ar and a9.name=="minecraft:bedrock"then return false end;aq=true;ap=true;m("Cannot Dig Block"..U(j))sleep(1)end;if not aq and ao then aq=true;ap=true;sleep(1)end elseif a7(j)then aq=true;ap=true;if ao then m("Infinite Source"..U(j))sleep(3)else ao=true;ai(j)end end;if not aq and not a0(j)then aq=true;ap=true;m("Cannot Move"..U(j))sleep(1)end;if not aq then a8=true end end;if ap then d.TurtleErrorClearEvent():send()end end;i(j,k,true)return true end;local function as(k)return an(d.c.Turtle.Direction.Front,k)end;local function at(k)return an(d.c.Turtle.Direction.Down,k)end;local function au(k)return an(d.c.Turtle.Direction.Up,k)end;local function av(j,k,n,O)a.expect(1,j,"number")a.expect(2,k,"number","nil")a.range(j,-1,1)if n==nil then n="Failed to Insert Item"..U(j)end;if O==nil then O="No Chest For Insert"..U(j)end;while not a1(j)do m(O)sleep(5)end;while not X(j,k)do m(n)sleep(5)end end;local function aw(k,n,O)av(d.c.Turtle.Direction.Front,k,n,O)end;local function ax(k,n,O)av(d.c.Turtle.Direction.Down,k,n,O)end;local function ay(k,n,O)av(d.c.Turtle.Direction.Up,k,n,O)end;local function az(j,k,n,O)if k==nil then k=1 end;a.expect(1,j,"number")a.expect(2,k,"number")a.range(j,-1,1)if n==nil then n="Failed to Pull Item"..U(j)end;if O==nil then O="No Chest For Pull"..U(j)end;while not a1(j)do m(O)sleep(5)end;while not Y(j,k)do m(n)sleep(5)end end;local function aA(k,n,O)return az(d.c.Turtle.Direction.Front,k,n,O)end;local function aB(k,n,O)return az(d.c.Turtle.Direction.Down,k,n,O)end;local function aC(k,n,O)return az(d.c.Turtle.Direction.Up,k,n,O)end;f.error=m;f.hasRequiredFuel=y;f.emptySlots=A;f.hasRoom=C;f.emptyInventory=I;f.refuel=R;f.isPerherial=a4;f.isPerherialDown=a5;f.isPerherialUp=a6;f.isSourceBlock=aa;f.isSourceBlockDown=ab;f.isSourceBlockUp=ac;f.isOreBlock=af;f.isOreBlockDown=ag;f.isOreBlockUp=ah;f.fill=ak;f.fillDown=al;f.fillUp=am;f.dig=as;f.digDown=at;f.digUp=au;f.insert=aw;f.insertDown=ax;f.insertUp=ay;f.pull=aA;f.pullDown=aB;f.pullUp=aC;return f
