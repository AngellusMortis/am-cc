local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.core")local c=require("am.event")local d=require("am.log")local e=require("am.peripheral")local f={}local g={}g.mods={name="colonies.blacklistedMods",default={["minecraft"]=true,["domum_ornamentum"]=true,["minecolonies"]=true},type="table"}g.maxStacks={name="colonies.maxStacks",default=4,type="number"}g.importChest={name="colonies.importChest",default="",type="string"}g.transferChest={name="colonies.transferChest",default="",type="string"}f.s=b.makeSettingWrapper(g)local h=nil;local i=nil;local function j()if h==nil then h=peripheral.find("colonyIntegrator")if h==nil then error("Could not find Colony Integrator")end end;return h end;local function k()if i==nil then i=peripheral.find("meBridge")if i==nil then error("Could not find ME Bridge")end end;return i end;local function l()local m=f.s.transferChest.get()if m~=""then return peripheral.wrap(m)end;return nil end;local function n()local m=f.s.importChest.get()if m~=""then return peripheral.wrap(m)end;return nil end;local function o(p)a.expect(1,p,"table")local q=nil;local r=p.list()for s=1,p.size(),1 do if r[s]==nil then q=s;break end end;return q end;local function t()if colony==nil or not colony.isValid()then error("Could not find colony info")end;local u=j()local v=colony.getInfo()if not v.active then error("Colony is not active")end;v.graves=u.amountOfGraves()v.constructionCount=u.amountOfConstructionSites()v.players=colony.getPlayers().players;v.requests=colony.getRequests()local w=colony.getBuildings()v.buildings={}v.tavernCount=0;for x,y in ipairs(w)do if y.type=="tavern"and y.level>0 then v.tavernCount=v.tavernCount+1 end;if y.type~="postbox"and y.type~="stash"then v.buildings[#v.buildings+1]=y end end;local z=colony.getVisitors()v.visitorCount=#z;v.visitors={}for x,A in ipairs(z)do v.visitors[A.id]=A end;local B=colony.getCitizens()v.citizenCount=#B;v.citizens={}for x,C in ipairs(B)do v.citizens[C.id]=C end;c.ColonyStatusPollEvent(v):send()return v end;local function D()d.info("Scanning Warehouse...")local E=e.getInventoryNames()local r={}for x,F in ipairs(E)do if F:sub(1,18)=="minecolonies:rack_"then d.debug(string.format(".Scanning %s...",F))local G=peripheral.wrap(F)for H,I in pairs(G.list())do local J=I.name;if I.nbt~=nil then J=J..":"..I.nbt end;if r[J]==nil then I=G.getItemDetail(H)if I~=nil then I.inventories={[F]={H}}r[J]=I end else local K=r[J]K.count=K.count+I.count;local L=K.inventories[F]if L==nil then L={H}else L[#L+1]=H end;K.inventories[F]=L;r[J]=K end end end end;return r end;local function M(I,N)a.expect(1,I,"table")a.expect(2,N,"number","nil")if N==nil then N=I.count end;d.info(string.format(".Empty %s %s",I.name,N))local p=n()if p==nil then error("Could not find dump chest")return end;local O=0;for F,P in pairs(I.inventories)do local Q=peripheral.wrap(F)for x,H in ipairs(P)do local R=nil;while R==nil do R=o(p)if R==nil then d.info("Waiting for dump chest to empty...")sleep(5)end end;local S=Q.getItemDetail(H)if S~=nil and S.name==I.name then local T=S.count;if T>N then T=N end;O=O+T;d.debug(string.format("%s %s %s %s %s",peripheral.getName(p),F,H,T,R))p.pullItems(F,H,T,R)if O>=N then break end end end end end;local function U(r)d.debug("Emptying Items...")for x,I in pairs(r)do local V=b.split(I.name,":")if not f.s.mods.get()[V[1]]then M(I)else local W=I.count/I.maxCount;local X=W-f.s.maxStacks.get()if X>0 then M(I,X*I.maxCount)end end end end;local function Y()local r=D()U(r)end;local function Z()return n()~=nil and l()~=nil end;f.pollColony=t;f.scanItems=D;f.emptyWarehouse=Y;f.canResume=Z;return f
