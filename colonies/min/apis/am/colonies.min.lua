local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.core")local c=require("am.log")local d=require("am.peripheral")local e={}local f={}f.mods={name="colonies.blacklistedMods",default={["minecraft"]=true,["domum_ornamentum"]=true,["minecolonies"]=true},type="table"}f.maxStacks={name="colonies.maxStacks",default=4,type="number"}f.importChest={name="colonies.importChest",default="",type="string"}f.transferChest={name="colonies.transferChest",default="",type="string"}e.s=b.makeSettingWrapper(f)local g=nil;local h=nil;local function i()if g==nil then g=peripheral.find("colonyIntegrator")if g==nil then error("Could not find Colony Integrator")end end;return g end;local function j()if h==nil then h=peripheral.find("meBridge")if h==nil then error("Could not find ME Bridge")end end;return h end;local function k()local l=e.s.transferChest.get()if l~=""then return peripheral.wrap(l)end;return nil end;local function m()local l=e.s.importChest.get()if l~=""then return peripheral.wrap(l)end;return nil end;local function n(o)a.expect(1,o,"table")local p=nil;local q=o.list()for r=1,o.size(),1 do if q[r]==nil then p=r;break end end;return p end;local function s()if colony==nil or not colony.isValid()then error("Could not find colony info")end;local t=i()local u=colony.getInfo()if not u.active then error("Colony is not active")end;u.graves=t.amountOfGraves()u.constructionCount=t.amountOfConstructionSites()u.players=colony.getPlayers().players;u.requests=colony.getRequests()local v=colony.getBuildings()u.buildings={}u.tavernCount=0;for w,x in ipairs(v)do if x.type=="tavern"and x.level>0 then u.tavernCount=u.tavernCount+1 end;if x.type~="postbox"and x.type~="stash"then u.buildings[#u.buildings+1]=x end end;local y=colony.getVisitors()u.visitorCount=#y;u.visitors={}for w,z in ipairs(y)do u.visitors[z.id]=z end;local A=colony.getCitizens()u.citizenCount=#A;u.citizens={}for w,B in ipairs(A)do u.citizens[B.id]=B end;return u end;local function C()c.info("Scanning Warehouse...")local D=d.getInventoryNames()local q={}for w,E in ipairs(D)do if E:sub(1,18)=="minecolonies:rack_"then c.debug(string.format(".Scanning %s...",E))local F=peripheral.wrap(E)for G,H in pairs(F.list())do local I=H.name;if H.nbt~=nil then I=I..":"..H.nbt end;if q[I]==nil then H=F.getItemDetail(G)if H~=nil then H.inventories={[E]={G}}q[I]=H end else local J=q[I]J.count=J.count+H.count;local K=J.inventories[E]if K==nil then K={G}else K[#K+1]=G end;J.inventories[E]=K;q[I]=J end end end end;return q end;local function L(H,M)a.expect(1,H,"table")a.expect(2,M,"number","nil")if M==nil then M=H.count end;c.info(string.format(".Empty %s %s",H.name,M))local o=m()if o==nil then error("Could not find dump chest")return end;local N=0;for E,O in pairs(H.inventories)do local P=peripheral.wrap(E)for w,G in ipairs(O)do local Q=nil;while Q==nil do Q=n(o)if Q==nil then c.info("Waiting for dump chest to empty...")sleep(5)end end;local R=P.getItemDetail(G)if R~=nil and R.name==H.name then local S=R.count;if S>M then S=M end;N=N+S;c.debug(string.format("%s %s %s %s %s",peripheral.getName(o),E,G,S,Q))o.pullItems(E,G,S,Q)if N>=M then break end end end end end;local function T(q)c.debug("Emptying Items...")for w,H in pairs(q)do local U=b.split(H.name,":")if not e.s.mods.get()[U[1]]then L(H)else local V=H.count/H.maxCount;local W=V-e.s.maxStacks.get()if W>0 then L(H,W*H.maxCount)end end end end;local function X()local q=C()T(q)end;local function Y()return m()~=nil and k()~=nil end;e.pollColony=s;e.scanItems=C;e.emptyWarehouse=X;e.canResume=Y;return e
