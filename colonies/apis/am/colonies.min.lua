local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.core")local c=require("am.event")local d=require("am.log")local e={}local f={}f.mods={name="colonies.blacklistedMods",default={["minecraft"]=true,["domum_ornamentum"]=true,["minecolonies"]=true},type="table"}f.maxStacks={name="colonies.maxStacks",default=4,type="number"}e.s=b.makeSettingWrapper(f)local g=nil;local h=nil;local i=peripheral.wrap("minecraft:barrel_12")local j=peripheral.wrap("minecraft:barrel_13")local function k()if g==nil then g=peripheral.find("colonyIntegrator")if g==nil then error("Could not find Colony Integrator")end end;return g end;local function l()if h==nil then h=peripheral.find("meBridge")if h==nil then error("Could not find ME Bridge")end end;return h end;local function m()local n=peripheral.getNames()local o={}for p,q in ipairs(n)do if q~="left"then local r=peripheral.wrap(q)if peripheral.hasType(r,"inventory")then o[#o+1]=r end end end;return o end;local function s()if j~=nil then return j end;local o=m()local t={}for p,u in ipairs(o)do if peripheral.getName(u):sub(1,18)~="minecolonies:rack_"then t[#t+1]=u end end;if#t==0 then return 0 end;j=t[1]return j end;local function v()if i~=nil then return i end;local o=m()local t={}for p,u in ipairs(o)do if peripheral.getName(u):sub(1,18)~="minecolonies:rack_"then t[#t+1]=u end end;if#t==0 then return 0 end;i=t[1]return i end;local function w(x)local y=nil;local z=x.list()for u=1,x.size(),1 do if z[u]==nil then y=u;break end end;return y end;local function A()if colony==nil or not colony.isValid()then error("Could not find colony info")end;local B=k()local C=colony.getInfo()if not C.active then error("Colony is not active")end;C.graves=B.amountOfGraves()C.constructionCount=B.amountOfConstructionSites()C.players=colony.getPlayers().players;C.requests=colony.getRequests()local D=colony.getBuildings()C.buildings={}C.tavernCount=0;for p,E in ipairs(D)do if E.type=="tavern"and E.level>0 then C.tavernCount=C.tavernCount+1 end;if E.type~="postbox"and E.type~="stash"then C.buildings[#C.buildings+1]=E end end;local F=colony.getVisitors()C.visitorCount=#F;C.visitors={}for p,G in ipairs(F)do C.visitors[G.id]=G end;local H=B.getCitizens()C.citizenCount=#H;C.citizens={}for p,I in ipairs(H)do C.citizens[I.id]=I end;c.ColonyStatusPollEvent(C):send()return C end;local function J()d.info("Scanning Warehouse...")local K=peripheral.getNames()local z={}for p,q in ipairs(K)do if q:sub(1,18)=="minecolonies:rack_"then d.debug(string.format(".Scanning %s...",q))local L=peripheral.wrap(q)for M,N in pairs(L.list())do local O=N.name;if N.nbt~=nil then O=O..":"..N.nbt end;if z[O]==nil then N=L.getItemDetail(M)if N~=nil then N.inventories={[q]={M}}z[O]=N end else local P=z[O]P.count=P.count+N.count;local Q=P.inventories[q]if Q==nil then Q={M}else Q[#Q+1]=M end;P.inventories[q]=Q;z[O]=P end end end end;return z end;local function R(N,S)a.expect(1,N,"table")a.expect(2,S,"number","nil")if S==nil then S=N.count end;d.info(string.format(".Empty %s %s",N.name,S))local x=v()if x==nil then error("Could not find dump chest")return end;local T=0;for q,U in pairs(N.inventories)do local V=peripheral.wrap(q)for p,M in ipairs(U)do local W=nil;while W==nil do W=w(x)if W==nil then d.info("Waiting for dump chest to empty...")sleep(5)end end;local X=V.getItemDetail(M)if X~=nil and X.name==N.name then local Y=X.count;if Y>S then Y=S end;T=T+Y;x.pullItems(q,M,Y,W)if T>=S then break end end end end end;local function Z(z)d.debug("Emptying Items...")for p,N in pairs(z)do local _=b.split(N.name,":")if not e.s.mods.get()[_[1]]then R(N)else local a0=N.count/N.maxCount;local a1=a0-e.s.maxStacks.get()if a1>0 then R(N,a1*N.maxCount)end end end end;local function a2()local z=J()Z(z)end;e.pollColony=A;e.scanItems=J;e.emptyWarehouse=a2;return e
